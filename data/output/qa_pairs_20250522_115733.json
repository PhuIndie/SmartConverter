[
  {
    "question": "Sharing data between different parts of the same thread\nwithout having to pass it around explicitly.\n• Storing data that is specific to a particular user or request.\n• Implementing the singleton pattern.\nWhat is thread-local, weak references, volatile, finalize,\nfinally andserialization?",
    "answer": "1. Thread Local: Thread-local variables are unique to each thread and do not share their values with other threads. 2. Weak References: Weak references allow objects to be eligible for garbage collection when no strong references exist. 3. Volatile: The volatile keyword in Java ensures that a variable's value is always read and written from/to main memory, preventing thread-specific caching. 4. Finalize: The finalize method in Java is called by the garbage collector before an object is reclaimed. It's rarely used due to its unpredictability. 5. Finally: finally is a block in exception handling that is executed regardless of whether an exception is thrown or not. 6. Serialization: Serialization is the process of converting objects into a byte stream, often used for storage or network transmission.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "How to use the Spring Framework to develop Web applications\n• How to use Spring Web Flow to implement stateful interactions\n• How to secure Web applications with Spring Security Developer Exam\n• How to test Web applications for correctness and performance\n• How to create rich Web user interfaces with Ajax and JQuery\n• How to use Spring Roo to create a Spring Web application in minutes\nA Study Guide\n—\nIuliana Cosmina\nISBN 978-1-4842-0809-0 Shelve in:\n54999\nProgramming Languages/Java\nUser level:\nIntermediate–Advanced\n9781484208090 SOURCE CODE ONLINE\nPivotal Certified Spring\nWeb Application\nDeveloper Exam\nA Study Guide\nIuliana Cosmina\nPivotal Certified Spring Web Application Developer Exam\nCopyright © 2015 by Iuliana Cosmina\nThis work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the\nmaterial is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation,\nbroadcasting, reproduction on microfilms or in any other physical way, and transmission or information\nstorage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now\nknown or hereafter developed. Exempted from this legal reservation are brief excerpts in connection with\nreviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed\non a computer system, for exclusive use by the purchaser of the work. Duplication of this publication or\nparts thereof is permitted only under the provisions of the Copyright Law of the Publisher’s location, in its\ncurrent version, and permission for use must always be obtained from Springer. Permissions for use may be\nobtained through RightsLink at the Copyright Clearance Center. Violations are liable to prosecution under\nthe respective Copyright Law.\nISBN-13 (pbk): 978-1-4842-0809-0\nISBN-13 (electronic): 978-1-4842-0808-3\nTrademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with\nevery occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an\neditorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.\nThe use in this publication of trade names, trademarks, service marks, and similar terms, even if they are\nnot identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to\nproprietary rights.\nWhile the advice and information in this book are believed to be true and accurate at the date of publication,\nneither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or\nomissions that may be made. The publisher makes no warranty, express or implied, with respect to the\nmaterial contained herein.\nManaging Director: Welmoed Spahr\nLead Editor: Steve Anglin\nTechnical Reviewer: Manuel Jordan Elera\nEditorial Board: Steve Anglin, Louise Corrigan, James T. DeWolf, Jonathan Gennick,\nRobert Hutchinson, Michelle Lowman, James Markham, Susan McDermott, Matthew Moodie,\nJeffrey Pepper, Douglas Pundick, Ben Renow-Clarke, Gwenan Spearing\nCoordinating Editor: Mark Powers\nCopy Editor: Kimberly Burton\nCompositor: SPi Global\nIndexer: SPi Global\nArtist: SPi Global\nDistributed to the book trade worldwide by Springer Science+Business Media New York,\n233 Spring Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail\norders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC\nand the sole member (owner) is Springer Science + Business Media Finance Inc (SSBM Finance Inc). SSBM\nFinance Inc is a Delaware corporation.\nFor information on translations, please e-mail rights@apress.com, or visit www.apress.com.\nApress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.\neBook versions and licenses are also available for most titles. For more information, reference our Special\nBulk Sales–eBook Licensing web page at www.apress.com/bulk-sales.\nAny source code or other supplementary material referenced by the author in this text is available to readers\nat www.apress.com/9781484208090. For detailed information about how to locate your book’s source\ncode, go to www.apress.com/source-code/. Readers can also access source code at SpringerLink in the\nSupplementary Material section for each chapter.\nTo all passionate Java developers, never stop learning and never stop improving your skills.\nTo all my friends for supporting me to make this book happen;\nyou have no idea how dear you are to me.\nContents at a Glance\nAbout the Author ���������������������������������������������������������������������������������������������������xiii\nAbout the Technical Reviewer ���������������������������������������������������������������������������������xv\nAcknowledgments �������������������������������������������������������������������������������������������������xvii\nIntroduction ������������������������������������������������������������������������������������������������������������xix\n■ Chapter 1: Introduction �����������������������������������������������������������������������������������������1\n■ Chapter 2: Spring Fundamentals �������������������������������������������������������������������������17\n■ Chapter 3: Spring MVC ����������������������������������������������������������������������������������������53\n■ Chapter 4: Spring Portlets ���������������������������������������������������������������������������������151\n■ Chapter 5: Spring RESTful Services �������������������������������������������������������������������189\n■ Chapter 6: Spring Web with AJAX ���������������������������������������������������������������������229\n■ Chapter 7: Spring Web Flow ������������������������������������������������������������������������������257\n■ Chapter 8: Spring Boot and WebSocket �������������������������������������������������������������367\n■ Appendix: Resources and Quiz Answers �����������������������������������������������������������401\nIndex ���������������������������������������������������������������������������������������������������������������������417\nv\nContents\nAbout the Author ���������������������������������������������������������������������������������������������������xiii\nAbout the Technical Reviewer ���������������������������������������������������������������������������������xv\nAcknowledgments �������������������������������������������������������������������������������������������������xvii\nIntroduction ������������������������������������������������������������������������������������������������������������xix\n■ Chapter 1: Introduction �����������������������������������������������������������������������������������������1\nSpring and What It Does ���������������������������������������������������������������������������������������������������1\nThe Focus of this Study Guide ������������������������������������������������������������������������������������������4\nWho Should Use this Study Guide ������������������������������������������������������������������������������������5\nAbout the Spring Web Certification Exam�������������������������������������������������������������������������5\nHow to Use this Study Guide ��������������������������������������������������������������������������������������������6\nHow this Book Is Structured �������������������������������������������������������������������������������������������������������������������7\nHow Each Chapter Is Structured �������������������������������������������������������������������������������������������������������������7\nConventions ��������������������������������������������������������������������������������������������������������������������������������������������8\nDownloading the Code ����������������������������������������������������������������������������������������������������������������������������8\nContacting the Author �����������������������������������������������������������������������������������������������������������������������������8\nRecommended Development Environment ����������������������������������������������������������������������8\nRecommended Build Tools ���������������������������������������������������������������������������������������������������������������������9\nRecommended IDE �������������������������������������������������������������������������������������������������������������������������������10\nThe Project Sample ������������������������������������������������������������������������������������������������������������������������������11\nvii\n■ Contents\n■ Chapter 2: Spring Fundamentals �������������������������������������������������������������������������17\nThe Basics ����������������������������������������������������������������������������������������������������������������������17\nThe Spring Core Container ���������������������������������������������������������������������������������������������19\nSpring Configuration ������������������������������������������������������������������������������������������������������21\nXML �������������������������������������������������������������������������������������������������������������������������������������������������������21\nAnnotations �������������������������������������������������������������������������������������������������������������������������������������������25\nMixed Approach ������������������������������������������������������������������������������������������������������������������������������������26\nThe Beans ����������������������������������������������������������������������������������������������������������������������27\nLifecycle and Instantiation ��������������������������������������������������������������������������������������������������������������������27\nBean Scopes �����������������������������������������������������������������������������������������������������������������������������������������35\nAccessing Beans ����������������������������������������������������������������������������������������������������������������������������������38\nSpring AOP ���������������������������������������������������������������������������������������������������������������������41\nTesting Spring Applications ��������������������������������������������������������������������������������������������44\nSummary ������������������������������������������������������������������������������������������������������������������������45\nQuick Quiz ����������������������������������������������������������������������������������������������������������������������46\nPractical Exercise �����������������������������������������������������������������������������������������������������������46\n■ Chapter 3: Spring MVC ����������������������������������������������������������������������������������������53\nMVC Basics ���������������������������������������������������������������������������������������������������������������������53\nConfiguring MVC �������������������������������������������������������������������������������������������������������������55\nXML Configuration ��������������������������������������������������������������������������������������������������������������������������������56\nConfiguration Using Annotations ����������������������������������������������������������������������������������������������������������61\nConfiguration Without Using web�xml ���������������������������������������������������������������������������������������������������64\nMVC Components �����������������������������������������������������������������������������������������������������������67\nInfrastructure Beans �����������������������������������������������������������������������������������������������������������������������������68\nUser-Provided Components ������������������������������������������������������������������������������������������������������������������94\nView Technologies ��������������������������������������������������������������������������������������������������������109\nTiles Layouts ���������������������������������������������������������������������������������������������������������������������������������������110\nThymeleaf �������������������������������������������������������������������������������������������������������������������������������������������115\nviii\n■ Contents\nForms ���������������������������������������������������������������������������������������������������������������������������119\nData Formatting ����������������������������������������������������������������������������������������������������������������������������������125\nData Binding ���������������������������������������������������������������������������������������������������������������������������������������129\nData Validation ������������������������������������������������������������������������������������������������������������������������������������132\nManaging the Form Object �����������������������������������������������������������������������������������������������������������������137\nSummary ����������������������������������������������������������������������������������������������������������������������138\nQuick Quiz ��������������������������������������������������������������������������������������������������������������������139\nPractical Exercise ���������������������������������������������������������������������������������������������������������144\n■ Chapter 4: Spring Portlets ���������������������������������������������������������������������������������151\nPortlet Basics ���������������������������������������������������������������������������������������������������������������154\nConfiguration ����������������������������������������������������������������������������������������������������������������156\nThe XML Part of the Configuration �������������������������������������������������������������������������������157\nThe Annotation Part of the Configuration ���������������������������������������������������������������������164\nConfiguration Details and Recommendations ��������������������������������������������������������������168\nThe Development and Deployment of a Portlet Application �����������������������������������������169\nDownload, Install, Start, and Configure Liferay �����������������������������������������������������������������������������������170\nSummary ����������������������������������������������������������������������������������������������������������������������188\n■ Chapter 5: Spring RESTful Services �������������������������������������������������������������������189\nCore REST Concepts �����������������������������������������������������������������������������������������������������189\nHATEOAS ����������������������������������������������������������������������������������������������������������������������195\nAdvantages of REST �����������������������������������������������������������������������������������������������������197\nRESTful Applications Using Spring MVC �����������������������������������������������������������������������199\nRESTful Clients with Spring ����������������������������������������������������������������������������������������������������������������199\nAsynchronous REST Calls �������������������������������������������������������������������������������������������������������������������203\nImplementing REST with Spring MVC �������������������������������������������������������������������������������������������������204\nAsynchronous REST Services Using @Async Annotated Methods �����������������������������������������������������213\nUsing Spring HATEOAS �����������������������������������������������������������������������������������������������������������������������216\nix\n■ Contents\nSummary ����������������������������������������������������������������������������������������������������������������������220\nQuick Quiz ��������������������������������������������������������������������������������������������������������������������221\nPractical Exercise ���������������������������������������������������������������������������������������������������������222\n■ Chapter 6: Spring Web with AJAX ���������������������������������������������������������������������229\nWhat Is AJAX?",
    "answer": "��������������������������������������������������������������������������������������������������������������229 Making AJAX Requests�������������������������������������������������������������������������������������������������233 Introducing jQuery ��������������������������������������������������������������������������������������������������������236 jQuery HTML DOM Manipulation ���������������������������������������������������������������������������������������������������������240 jQuery AJAX Calls �������������������������������������������������������������������������������������������������������������������������������243 Spring MVC, AJAX, and jQuery ��������������������������������������������������������������������������������������245 Using REST-Style Remoting with JSON ����������������������������������������������������������������������������������������������246 Custom Tags �����������������������������������������������������������������������������������������������������������������250 Summary ����������������������������������������������������������������������������������������������������������������������253 Quick Quiz ��������������������������������������������������������������������������������������������������������������������253 Practical Exercise ���������������������������������������������������������������������������������������������������������254 ■ Chapter 7: Spring Web Flow ������������������������������������������������������������������������������257 What Is a Flow? ������������������������������������������������������������������������������������������������������������257 Web Flow Architecture �������������������������������������������������������������������������������������������������259 Web Flow Internal Logic �����������������������������������������������������������������������������������������������261 Configuration and Infrastructure Beans �����������������������������������������������������������������������262 Configuration Using XML ��������������������������������������������������������������������������������������������������������������������263 Configuration Using Annotations ��������������������������������������������������������������������������������������������������������267 Create a Flow ���������������������������������������������������������������������������������������������������������������272 Flow Definition ������������������������������������������������������������������������������������������������������������������������������������273 Action States ��������������������������������������������������������������������������������������������������������������������������������������304 Decision States ������������������������������������������������������������������������������������������������������������311 Exception Handling �������������������������������������������������������������������������������������������������������312 x ■ Contents Subflows ����������������������������������������������������������������������������������������������������������������������322 Flow Definition Inheritance ������������������������������������������������������������������������������������������326 Securing Web Flows �����������������������������������������������������������������������������������������������������327 Introduction to Spring Security �����������������������������������������������������������������������������������������������������������327 Why Spring Security Is Awesome �������������������������������������������������������������������������������������������������������328 Spring Security XML Configuration �����������������������������������������������������������������������������������������������������330 Spring Security Java Configuration ����������������������������������������������������������������������������������������������������343 Securing Flow Definitions �������������������������������������������������������������������������������������������������������������������350 Summary ����������������������������������������������������������������������������������������������������������������������357 Quick Quiz ��������������������������������������������������������������������������������������������������������������������358 Practical Exercise ���������������������������������������������������������������������������������������������������������364 ■ Chapter 8: Spring Boot and WebSocket �������������������������������������������������������������367 What Is Spring Boot? ����������������������������������������������������������������������������������������������������367 Usage and Configuration ����������������������������������������������������������������������������������������������368 Customizing Spring Boot ��������������������������������������������������������������������������������������������������������������������373 Importing Additional Configuration Elements �������������������������������������������������������������������������������������380 Running Spring Boot Applications ������������������������������������������������������������������������������������������������������381 Testing Spring Boot Applications ��������������������������������������������������������������������������������������������������������383 WebSocket Introduction �����������������������������������������������������������������������������������������������385 Spring WebSocket Implementation ������������������������������������������������������������������������������386 Spring WebSocket Configuration ����������������������������������������������������������������������������������390 WebSocket Client Application ���������������������������������������������������������������������������������������392 Configure the Server Application to Send Scheduled Messages ��������������������������������������������������������397 Monitoring and Debugging �����������������������������������������������������������������������������������������������������������������398 xi ■ Contents ■ A ppendix: Resources and Quiz Answers �����������������������������������������������������������403 Study Guide Projects ����������������������������������������������������������������������������������������������������401 Gradle Configuration Explained ����������������������������������������������������������������������������������������������������������403 Building and Troubleshooting �������������������������������������������������������������������������������������������������������������403 Deploy on Apache Tomcat �������������������������������������������������������������������������������������������������������������������407 Quiz Answers ����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 2 �����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 3 �����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 5 �����������������������������������������������������������������������������������������������������������������413 Quiz Solution for Chapter 6 �����������������������������������������������������������������������������������������������������������������414 Quiz Solution for Chapter 7 �����������������������������������������������������������������������������������������������������������������414 Index ���������������������������������������������������������������������������������������������������������������������417 xii About the Author Iuliana Cosmina is a software engineer and professional developer. She has been programming in Java for more than 10 years. She also taught Java at the Gheorge Asachi Technical University in Iasi, Romania. She has a Bachelor’s degree in computer science and a Master’s degree in distributed systems from the same university. She discovered Spring in June 2012 and loved it so much she trained for and passed the exam to become a Certified Spring Professional in November 2012. She trained for and passed the exam to become a Certified Web Application Developer in May 2014. Her plan is to become a Spring Enterprise Integration Specialist in the near future. She has contributed to the development of different types of enterprise applications such as search engines, ERPs, track and trace, and banking. During her career in outsourcing she has been a team leader, acting software architect and a DevOps professional. She likes to share her knowledge and expertise via tutoring, teaching, and mentoring, but in the summer of 2014 everything changed because of Steve Anglin, who approached her and gave her a chance to do it by writing this guide. She lives in Sibiu, Romania and works as a software engineer for BearingPoint, a multinational management and technology consulting company. When she is not programming, she spends her time reading, travelling, hiking, or biking.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "You can find some of her personal work on her GitHub account:\nhttps://github.com/iuliana.\n• You can find her complete CV on her LinkedIn account:\nhttps://ro.linkedin.com/in/iulianacosmina.\n• You can contact her at: Iuliana.Cosmina@gmail.com.\nxiii\nAbout the Technical Reviewer\nManuel Jordan Elera is an autodidactic developer and researcher who enjoys learning new technologies\nfor his own experiments and creating new integrations.\nManuel won the 2010 Springy Award – Community Champion and Spring Champion 2013. In his little\nfree time, he reads the Bible and composes music on his guitar. Manuel is known as dr_pompeii. He has tech\nreviewed numerous books for Apress, including Pro Spring, 4th Edition (2014), Practical Spring LDAP (2013),\nPro JPA 2, Second Edition (2013), and Pro Spring Security (2013).\nRead his thirteen detailed tutorials about many Spring technologies and contact him through his blog at\nhttp://www.manueljordanelera.blogspot.com and follow him on his Twitter account, @dr_pompeii.\nxv\nAcknowledgments\nCreating this guide involved a lot of teamwork. It is the first time I’ve written a technical book and I\nwouldn’t have made it without all the help and advice I received from Mark Powers, Matthew Moodie,\nand Manuel Jordan. Mark has been very supportive and shared with me his experience on book writing in\norder to help me and kept encouraging me when I was ready to give up on writing because I thought my\nwork was not good enough.\nMatthew and Manuel have been great collaborators; I loved our exchanges of technical ideas and I am\nvery thankful because working with them has helped me grow professionally. Many thanks to Kimberly\nBurton for her help turning my technical literature into human readable literature.\nMost of all I want to thank Steve Anglin for finding me and for trusting me to get this done.\nApress has published many of the books I read and used to improve myself professionally during my\nstudies and even after that. It is a great honor for me to write a book and publish it with Apress. It is great to\ncontribute to the education of the next generation of developers.\nI am grateful to all my friends that had the patience to listen to me complain about sleep loss, having too\nmuch work to do, and writer’s block. Thank you all for being supportive and making sure I still had some fun\nwhile writing this book.\nAnd I would also like to add a very special thank you to Levi9 Romania, the company that introduced\nme to Spring and its country manager Nicu Lazar that supported me to become a Spring Professional.\nxvii\nIntroduction\nThree years have passed since I wrote my first Spring project and I regret that this framework grew for ten\nyears without me knowing about it. Four major versions of Spring have been released so far and except for\nthe official study guide required to pass the certification exam, until the conception of this book there was no\nadditional resource such as this.\nThis study guide provides a complete overview of all the technologies involved in creating a Spring web\napplication from scratch. It guides you step by step into the Spring web world covering Spring 3 and Spring 4.\nIt also covers topics not required for the certification exam, such as Portlets and Thymeleaf, which most\ndevelopers encounter while in the field.\nThere are two multi-module projects associated with this book, covering every example presented\nin the book. As the book was written, new versions of Spring were released, a new version of Intellij IDEA\nwas released, and new versions of Gradle were released. I upgraded to the new versions in order to\nprovide the most recent information and keep this book synchronized with the official documentation.\nA group of reviewers has gone over the book, but if you notice any inconsistency, please send an email to\neditorial@apress.com and errata will be created.\nThe example source code for this book can be found on GitHub and will be maintained, synchronized\nwith new versions of the technologies, and enriched based on the recommendation of the developers using\nit to learn Spring.\nhttp://github.com/iuliana/personal-records\nhttps://github.com/iuliana/book-code\nI truly hope you will enjoy using this book to learn Spring as much as I enjoyed writing it.\nxix\nChapter 1\nIntroduction\nSo here you are: you want to learn how to develop web applications using Spring, and you chose this study\nguide to help you. This might be one of the best decisions that you could make, as this book was written not\nonly to help you to understand Spring Web, but to love it as well. This study guide may even help you pass\nthe certification exam—if you follow all the instructions properly and do all the exercises. This study guide\nexplores more Spring Web topics than those required by the exam; for example, it gives you a short overview\nof what Spring Web is all about, which you can skip reading, of course; but if you really want to learn Spring\nto develop web applications like a professional, then it would be wise not to skip this.\nSpring and What It Does\nWhen building a project using Java, a lot of functionality needs to be built from scratch. But a lot of\nuseful functionalities are already built and are free to use because of the open source world we live in.\nA long time ago, when the Java world was still quite small, you would say that you were using a library\nwhen you used open source code developed by somebody else, shipped as a *.jar file. But as time\npassed, the software development world evolved and the libraries grew too. They became frameworks.\nBecause they were no longer one *.jar file that you could import, they became a collection of\nmore-or-less decoupled libraries with different responsibilities, and you had the option to import only\nwhat you needed.\nReleased in October 2002 as an open source framework and an inversion of control container\ndeveloped using Java, Spring was built for the Java platform. It was conceived with the dependency injection\nsoftware design pattern in mind, and its main purpose is to make dependency handling easier. A Java\napplication is basically a group of objects exchanging data and influencing each other’s behavior. The Spring\nFramework simplified the way in which objects talk to each other and the way they depend on each other.\nThis is why Spring evangelists claim that the reason Java was invented was so that Spring would come into\nexistence one day. The development of Java applications became easier when Spring emerged, providing\ncomprehensive infrastructure support. Spring makes it easier to compose disparate components into a fully\nworking application.\nSpring comes with a lot of default behaviors already implemented (components called infrastructure\nbeans are a default configuration; they can be used to create functional basic applications without extra\ncustomization), because the Spring Framework was also built with the convention over configuration\nparadigm as a principle, which seeks to decrease the number of decisions a developer has to make when\nwriting code, but also makes it easier for the developer to customize the behavior of objects, offering\nincreased flexibility.\n1\nChapter 1 ■ IntroduCtIon\nSpring is currently the VIP of Java frameworks and it has been growing exponentially, especially since\n2009, when VMware acquired SpringSource, the company behind Spring. The merger of VMware and the\nEMC Corporation in April 2013, now known as Pivotal, was also advantageous for Spring, as it became one\nof Pivotal’s central elements in its strategy to provide innovative and modern software-driven experiences to\nits customers. Spring is now a full-blown technology that can be used to build enterprise-ready applications\nin a very short time, and it comes in 25 flavors.1 Figure 1-1 shows a diagram of all Spring-released projects.\nThe following list describes these projects.\nFigure 1-1. Official Spring projects. The projects drawn with dotted lines are only partially covered in this\nbook or are featured in the source code\n• Spring Framework provides core support for dependency injection, transaction\nmanagement, web applications, data access, messaging, and more.\n• Spring IO provides a cohesive, versioned platform for building modern applications.\nIt is a modular, enterprise-grade distribution that delivers a curated set of dependencies.\n• Spring Boot provides compact setups for different types of applications, helping you\nto focus on your code instead of infrastructure configuration.\n• Spring XD simplifies the development of Big Data applications.\n1You can read about these projects, as well as other projects that have not been released officially (Spring Session, for\nexample) in detail at http://spring.io/projects.\n2\nChapter 1 ■ IntroduCtIon\n• Spring Cloud provides a set of tools for distributed applications.\n• Spring Data provides a consistent approach to data access. (This study guide uses a\nsubproject called Spring Data JPA to help us manage data easily.)\n• Spring Integration supports the well-known Enterprise Integration Patterns via\nlightweight messaging and declarative adapters.\n• Spring Batch simplifies and optimizes the work of processing high-volume batch\noperations.\n• Spring Security provides tools for authentication and authorization. (Because web\nsecurity is one of the subjects of the certification exam, there is a section about web\nsecurity in this study guide that you will have to pay close attention to.)\n• Spring HATEOAS provides some APIs to help the development of REST\nrepresentations that follow the HATEOAS principle (Hypermedia as the Engine of\nApplication State, which means that a client interacts with a network application\nentirely through hypermedia provided dynamically by application servers).\n• Spring Social provides an API to connect Spring applications to the third-party APIs\nof social networks like Facebook and Twitter, as well as others.\n• Spring AMQP provides an API for AMQP-based messaging solutions.\n• Spring Mobile simplifies the development of mobile applications.\n• Spring for Android provides key spring components to use in the development of\nAndroid applications.\n• Spring Web Flow supports the building of web application with controlled\nnavigation (Spring Web Flow is another subject in the certification exam.)\n• Spring Web Services facilitates the development of SOAP-based applications.\n• Spring LDAP provides tools to develop LDAP applications.\n• Grails2 is a powerful open source web framework based on Groovy and inspired\nby Ruby on Rails. It is used to create web applications that run on the Java Virtual\nMachine(JVM).\n• Groovy3 started as a dynamic language for the Java platform. It brings high-productivity\ndevelopment features to the JVM, and resembles Python, Ruby, Perl, and Smalltalk\nin regards to syntax and features. SpringSource has taken over its development\nand maintenance.\n• Spring Scala mixed up Spring with Scala language features.\n• Spring Roo helps define application templates that can be built into a full Java\napplication within minutes.\n• Spring BlazeDS Integration tools integrate Spring with Adobe BlazeDS.\n• Spring Loaded reloads classes as files change, boosting productivity\n(similar project to JRebel).\n2Pivotal decided to stop funding this project in March 2015.\n3Funding for this project also ended in March 2015.\n3\nChapter 1 ■ IntroduCtIon\n• Spring Shell provides the capability to build command-line apps.\n• REST Shell makes the writing and testing of RESTful application easier\nwith CLI-based resource discovery and interaction.\nThe Focus of this Study Guide\nAs this study guide is being written, the Spring Framework consists of features organized into about 20\nmodules grouped into the following: Core Container, Data Access/Integration, Web, AOP (aspect-oriented\nprogramming), Instrumentation, Messaging, and Test.\nThe topics covered in this study guide are Spring Framework’s support components for the presentation\ntier (and specifically web-based presentation tiers). A bonus in this book is the Spring WebSocket chapter,\nwhich was added to the Spring Framework in version 4 and is also an optional part of the official Spring Web\ncourse not featured in the certification exam. In the Figure 1-2 you can see the Spring MVC stack, a tiered\nrepresentation of the modules commonly used to create Spring web applications.\nFigure 1-2. The Spring Web Stack (those with dotted lines will not be covered in this study guide)\nThis study guide focuses on helping developers understand how Spring’s web infrastructure is\ndesigned, and how to write Spring web applications in a few easy steps by maximizing Spring’s potential.\nThe study guide’s objectives are as follows:\n• Use Spring to develop web applications\n• Use Spring Web Flow to implement stateful interactions\n• Use Spring Security to secure web applications\n• Use Spring Test and other test frameworks (JUnit, JMock) to test web applications\n• Create Spring web applications using Gradle4\n4Gradle is an automated build tool that is easy to configure and use on any type of application. Its build files are written\nusing JSON and Groovy. Gradle combines the power and flexibility of Ant with the dependency management and\nconventions of Maven into a more effective way to build. Read more about it at https://www.gradle.org.\n4\nChapter 1 ■ IntroduCtIon\nWho Should Use this Study Guide\nThis study guide is designed to help any Spring developer become familiar and comfortable with\nSpring-associated technologies for web development. It can also be a big help to a developer who wants\nto become a Certified Spring Web Application Developer.5 That is why every topic in the official VMware\nSpring Web study guide is given the attention that it deserves.\nYou do not have to be a Certified Spring Professional to use this study guide; you just need\nminimal knowledge of Spring. Because this study guide has a full chapter dedicated to the Spring core\ncomponents, it might be possible for a non-Spring developer to use this study guide too, but the\nSpring Framework Reference6 official documentation should be consulted to retrieve any missing pieces\nof information.\nIn a nutshell, this study guide was written to be used by the following audiences:\n• Spring Core developers who want a taste of Spring Web\n• Spring developers (Certified Spring Professionals or not) who are looking forward\nto becoming Certified Spring Web Application Developers\n• Java developers who are curious about working with Spring technologies and\nwant to start fast\nAbout the Spring Web Certification Exam\nIf you are interested in becoming a Certified Spring Web Application Developer, the first step is to go to\nthe VMware official learning site (http://pivotal.io/training) and search for the Spring Certification\nsection. There you will find all the details you need regarding the official trainings, including where and\nwhen they take place. The training is four days long. There is online training available as well. After creating\nan account on the VMware site, you can select your desired training. After you make the payment, if you\nchoose an online training, after about a month you will receive (through the mail) an official training kit that\nconsists of the following:\n• A pair of conference headphones (usually Logitech) to be used during training to\nhear your trainer talk and to ask questions.7\n• A professional webcam (usually Logitech) to be used during training so that your\ntrainer and colleagues can see you, thus simulating a classroom experience.8\n• A Spring study guide book containing the printed version of the slides your tutor\nwill use during training.\n• A Spring study lab book containing explanations and instructions for the\npractical exercises you will do during training.\n• A SpringSource official flash drive containing the following:\n• A JDK installer.\n5Keep in mind that attending a Spring Web training course by Pivotal or at a VMware Authorized Training Center\nis a prerequisite to becoming a Certified Spring Web Application Developer, as stated on the official site at\nhttp://mylearn.vmware.com/mgrReg/plan.cfm?",
    "answer": "plan=31111 ui=www_cert. 6The Spring Framework Reference is at http://docs.spring.io/spring/docs/current/ spring-framework-reference/htmlsingle/. 7Depending on the area and the training center, this item is optional. 8Depending on the area and the training center, this item is also optional. 5 Chapter 1 ■ IntroduCtIon",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Sources necessary for your training. Each study lab has a small Spring web\napplication with missing configuration and code; the student’s task is to\ncomplete it to become a working application. The same model is used in the\ncode associated with this book.\n• An installer for the most recent stable version of the Spring Tool Suite (STS). The\nversion on the flash drive is mandatory for the course because the installer sets\nup a local Maven repository with all the needed dependencies, and a full eclipse\nproject configuration with the lab sources. The STS also has an internal tc Server\nto run the lab applications.\n• An HTML or PDF version of the Spring Study Lab.\nIf you do not choose to do online training, you will not receive the headphones nor the webcam. The\ntraining kit and the rest of the materials are given to you when you arrive at the location where the training\nis taking place. After your training, you receive a free voucher that is required to schedule the certification\nexam at an approved exam center near you. Basically, this voucher or voucher code is proof that you have\nattended official Spring Web training.\n! The exam duration is 90 minutes and consists of 50 questions. There are both single-answer and\nmultiple-choice questions. The questions cover (roughly) the following topics:\n• Spring overview (Spring core notions)\n• MVC essentials (configurations, beans to use, conventions)\n• MVC forms and views\n• Webflow\n• Web security\n• REST\nThe passing score for the exam is 76%. This means that 38 correct answers are needed to pass. Most\nof the questions present you with a piece of Java code or configuration and then ask you what it does, so\nmake sure that you understand the code attached to this book and write your own beans and configurations\nin order to understand the framework better. The good news is that all the code in the exam can be found\nin the sources that you are given while attending the official training. Other questions present you with\naffirmations about Spring Web and require you to select the correct or the invalid ones.\nIf you read this book, understand all the examples, solve the practice exercises, and then attend the\nofficial training, the recommendation is to take the certification exam as soon as possible afterward. Do not\nallow too much time to pass between finishing the training and taking the exam, because we are all human\nafter all, and information can be forgotten. Also, the certification voucher is only valid for a year. You can\nretake the exam if you fail the first time, but it will cost you ~$150.\nHow to Use this Study Guide\nThis study guide follows the same path as the official Spring Web training, and focuses on the topics that are\nfound in the certification exam; but there are a few differences, which are mentioned from now on.\nThis Spring study guide covers the Spring MVC Portlets. This topic is not in the exam, but you never\nknow when you may need them in your development career, so it is better to have an overview.\nThe other differences are related to the tools used for the practical examples, which are mentioned in\nthe next section.\n6\nChapter 1 ■ IntroduCtIon\nHow this Book Is Structured\nThis study guide has eight chapters. You might think: How is this possible—the official Spring study guide\nhas sixteen chapters, right?",
    "answer": "It is better to wrap related things together, so in this study guide you have two big chapters that cover 60% of the exam topics: Chapter 3 covers Spring MVC and Chapter 7 covers Spring Web Flow. Also, some topics that have their own dedicated chapter in the official study guide have been included in other chapters, as relevant, in this book. (For example, how to test a web application. There’s no need of a separate chapter just for this, as testing is a main portion in the development of an application.) A list of this study guide’s chapters, along with a short description, is presented in Table 1-1. Table 1-1. Study Guide Chapters Chapter Topic Details 1 Introduction An introduction to Spring history, technologies, and the tools used for practice in this study guide 2 Spring Fundamentals Spring core concepts, components, and configurations 3 Spring MVC Spring Web Framework core concepts, components, and configurations 4 Spring Portlets What portlets are, how they can be used, and how can Spring make this easier 5 Spring RESTful Services Advanced Spring MVC for REST applications 6 Spring Web with AJAX Advanced Spring MVC with AJAX web applications 7 Spring Web Flow Basic and advanced topics on working with Spring Web Flow 8 Spring Web Socket Basic configuration and usage of Spring Web Socket A Appendix Two mock exams, answers to review questions, and other comments How Each Chapter Is Structured The introductory chapter, the one you are reading now, covers the basics of Spring and Spring related-notions that every developer using this study guide should know: what Spring is, how it has evolved, the number of official Spring projects, the Spring Web technologies, the technologies used to build and run the practical exercises, how to register for the exam to become a Certified Spring Developer, and so on. This chapter is the exception; it is structured differently than the others because it is designed to prepare you for what is coming next. All the other chapters are designed to cover a Spring module and associated technologies, which will help you build a specific type of Spring web application. Each chapter is split into a few sections, but in a nutshell, a chapter could be split as follows:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Basics\n• Configuration\n• Components\n• Summary\n• Quick quiz\n• Practical exercise\n7\nChapter 1 ■ IntroduCtIon\nConventions\n! This symbol appears in front of paragraphs that you should pay particular\nattention to.\n** This symbol appears in front of a paragraph that is an observation or an\nexecution step that you can skip.\n?",
    "answer": "This symbol appears in front of a question for the user. ... This symbol replaces missing code that is not relevant in the example. CC This symbol appears in front of a paragraph that describes a convention over configuration practice in Spring, a default behavior that helps a developer reduce his or her work. [random text here] Text surrounded by square brackets means that the text within the brackets should be replaced by a context-related notion. Downloading the Code This study guide comes with code examples and practical exercises. There will be missing pieces of code that you will have to fill in to make applications work and to test your understanding of Spring Web. It is recommended that you go over the code samples and do the exercises, as similar pieces of code and configurations will appear in the certification exam. The following downloads are available:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Source code for the programming examples in the book chapters\n• Source code for the programming examples in the practice section\nYou can download these items from the Source Code area of the Apress web site (www.apress.com).\nContacting the Author\nMore information on Iuliana Cosmina can be found at http://ro.linkedin.com/in/iulianacosmina.\nShe can be reached at iuliana.cosmina@gmail.com. Follow her personal coding activity at\nhttps://github.com/iuliana.\nRecommended Development Environment\nIf you decide to attend the official course, you will notice that the development environment recommended\nin this book differs quite a lot from the one used for the course—a different editor is recommended, and a\ndifferent application server, and even a different build tool. The reason for this is to improve and expand\nyour experience as a developer and to offer a practical development infrastructure. Motivation for each\nchoice is mentioned in the corresponding sections.\n8\nChapter 1 ■ IntroduCtIon\nRecommended Build Tools\nThe recommended development environment should be composed of the following technologies:\nJava 8. Download and install the JDK matching your operating system from\nhttp://www.oracle.com.\n! It is recommended to set the JAVA_HOME environment variable to point to the directory where Java 8 is\ninstalled (the directory in which the JDK was unpacked) and add $JAVA_HOME/bin to the general path of the\nsystem. The reason behind this is to ensure that any other development application written in Java will use\nthis version of Java, and prevent strange incompatibility errors during development.\n! Verify that the version of Java that your operating system sees is the one you just installed. Open a\nterminal (Command+Prompt in Windows, or any type of terminal you have installed on Mac OS or Linux)\nand type the following:\njava -version\nYou should see something similar to this:\njava version \"1.8.0_40\"\nJava(TM) SE Runtime Environment (build 1.8.0_40)\nJava HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)\nGrade 2.x\n** The sources attached to this book can be compiled and executed using the Gradle Wrapper, which\nis a batch script on Windows, or by using a shell script on other operating systems. When you start a Gradle\nbuild via the wrapper, Gradle is automatically downloaded and used to run the build, thus you do to need to\ninstall Gradle as stated previously. Instructions on how to do this can be found on the public documentation\nat www.gradle.org/docs/current/userguide/gradle_wrapper.html.\nIt is a good practice to keep code and build tools separate, but this study guide uses the Wrapper\nto easily set up the practice environment by skipping the Gradle installation step, and also because the\nrecommended source code editor uses the Wrapper internally.\nIf you decide to use Gradle outside the editor, you can download the binaries only (or, if you are more\ncurious, you can download the full package, which contains binaries, sources, and documentation) from\nthe official site (https://www.gradle.org), unpack it and copy the contents somewhere on the hard drive.\nCreate a GRADLE_HOME environment variable and point it to the location where you have unpacked Gradle.\nAlso add $GRADLE_HOME/bin to the general path of the system.\nGradle was chosen as a build tool for the sources of this book because of the easy setup, small\nconfiguration files, flexibility in defining execution tasks, and the fact that the SpringSource team currently\nuses it to build all Spring projects.\n9\nChapter 1 ■ IntroduCtIon\n! Verify that the version of Gradle that your operating system sees is the one that you just installed. Open\na terminal (Command+Prompt in Windows, any type of terminal you have installed on Mac OS or Linux)\nand type gradle –version. You should see something similar to this:\n------------------------------------------------------------\nGradle 2.3\n------------------------------------------------------------\nBuild time: 2014-11-24 09:45:35 UTC\nBuild number: none\nRevision: 6fcb59c06f43a4e6b1bcb401f7686a8601a1fb4a\nGroovy: 2.3.9\nAnt: Apache Ant(TM) version 1.9.3 compiled on December 23 2013\nJVM: 1.8.0_40 (Oracle Corporation 25.25-b02)\nOS: -- whatever operating system you have --\nThe preceding text shows a confirmation that any Gradle command can be executed in your terminal;\nGradle was installed successfully.\nJetty 9 is an open source web server that is\nfree to use and easy to install; that’s why it was chosen to be used in this study guide instead of the\nSpringSource tc Server. No need to download and install this web server, though, because there is no need\nto. There is a Gradle plugin called Getty that will be used to download the Jetty web server and deploy your\n*.war artifact on it. If you want to read more about Jetty, you can do so at http://eclipse.org/jetty/.\nRecommended IDE\nThe recommended IDE to use in this study guide is Intellij IDEA. The reason for this is\nthat it is the most intelligent Java IDE. IntelliJ IDEA offers outstanding framework-specific coding assistance\nand productivity-boosting features for Java EE. Spring also includes support for Maven and Gradle. It is the\nperfect choice to help you focus on learning Spring, rather than how to use an IDE. It can be downloaded\nfrom the JetBrains official site (https://www.jetbrains.com/idea/). It is also quite light on your operating\nsystem and quite easy to use.\n10\nChapter 1 ■ IntroduCtIon\nBecause the web applications developed as practice in this study guide are deployed on Jetty, the\ncommunity edition of Intellij IDEA can be used because we do not need the server plugin. The main\ndisadvantage of the community edition, though, is that it does not come with the Spring plugin, which is\nvery useful in creating Spring configuration files because it adds the bean namespace by default. But solving\nthe exercises in this book won’t require that, so you can still consider IDEA an option. If you are curious\nabout the full power of this IDE, you can download the Ultimate Edition, which has a trial period of 30 days.\nAnd you can even try to deploy the code samples on a Tomcat instance from within IDEA. You will find an\nexample of how to do this in the appendix.\nIf you are already familiar with a different Java editor, you can use it—as long as it supports Gradle.\nThe Project Sample\nMost of the code used in this study guide, except the book code modules, makes up a project named\nPersonal Records Manager. This is a proof of concept application that aspires to manage the personal\ninformation of a group of people. The application is multimodular and each module is duplicated. The\nprojects suffixed with practice are missing pieces of code and configuration, and are the ones that need to\nbe solved by you to test your understanding of Spring Web. The projects suffixed with solution are proposal\nresolutions for the tasks. You can see the project structure and the modules in Figure 1-3.\n11\nChapter 1 ■ IntroduCtIon\nFigure 1-3. The Personal Records Manager Application diagram\n12\nChapter 1 ■ IntroduCtIon\nThe foundation module is the 00-pr-dao, which handles all database operations by using Hibernate\nand Spring Data JPA. All other modules are client web applications, which will help the end user introduce\nnew data, modify existing data, and perform searches. Each module is specific to a part of a chapter. Each\nmodule name is prefixed with a number, so no matter what IDE you use, you will always have the modules in\nthe exact order that they were intended to be used.\nThe general functionality of each web application is described in Figure 1-4.\nFigure 1-4. The Personal Records Manager Application structure\nThe foundation of this application is its DAO (data access objects) module, which contains entities\nclasses that are mapped on database tables, and classes used to handle entities, called repositories. The web\nprojects use the DAO project to manipulate data according to user requests. The UML diagram in Figure 1-5\ndescribes the general behavior of our application. In some chapters, however, diagrams that describe a more\ndetailed behavior are presented.\n13\nChapter 1 ■ IntroduCtIon\nFigure 1-5. UML diagram describing the general behavior of the application\nThe entities have common fields used by Hibernate to uniquely identify each entity instance (id) and\nthe fields used to audit each entity instance (createdAt and modifiedAt) and keep track of how many times\nan entity was modified (version). These fields have been grouped in the AbstractEntity class to avoid\nhaving duplicated code. The class hierarchy can be analyzed in Figure 1-6.\n14\nChapter 1 ■ IntroduCtIon\nFigure 1-6. This diagram shows the relationships between entity classes and the relationships between tables\nin the database. (The pnc is a personal numerical code that uniquely identifies a person and will be used to\ntest some Spring validations on it. The iban is an alphanumeric code that uniquely identifies a bank account.)\nThis chapter does not have any practice and sample code attached to it, so more information regarding\nthe setup of the project, and how it is built and executed, is provided in upcoming chapters.\n15\nChapter 2\nSpring Fundamentals\nThis chapter is necessary for building a Spring background, which will be very helpful in the upcoming\nchapters. This chapter will help you get familiar with the Spring container, context, beans, and most Spring\ncore modules and how they work together to allow developers to focus on solving problems instead of\nbuilding up support.\nThe Basics\nAny application system is made of components that work together to solve a problem. In object-\noriented design they are called classes. Figure 2-1 depicts the sequence of operations necessary to\ncreate a Person instance. Because this chapter is about Spring Core, a web application is not needed,\nso requests to manipulate Person instances will be directed to implementations of the PersonManager\ninterface. Implementations of this interface will provide access to the database using an implementation\nof PersonRepository interface. The operation is pretty simple and the setup to write and execute the\ncode should be too. This is where Spring comes in—providing a way to build an application using plain\nold Java objects (POJOs)1 and applying enterprise services (transaction execution, remote execution)\nnoninvasively.\n1A software term introduced by Martin Fowler, Rebecca Parsons, and Josh MacKenzie in September 2000 to refer to\nordinary Java objects not bound by any restriction.\n17\nChapter 2 ■ Spring FundamentalS\nFigure 2-1. UML sequence of operations necessary to create a Person instance\nThe components making up an application interact and depend on one another. Defining how these\nobjects are composed is quite difficult using plain Java. Even with the help of all the design patterns defined\nby experts in the software industry, the work is still cumbersome, as the pattern components still have to\nbe implemented before being used. The Spring inversion of control (IoC) container was designed to help\ndevelopers compose objects into fully working applications, ready to use.2\nThe Spring container is responsible for the creation of components, resolving their dependencies\nand providing them to other components. It does this by reading the configuration of an application from\n*.xml files or annotated configuration classes, and internally constructs a graph of dependencies between\nthe objects. It then proceeds to traverse the graph, and creates and injects dependencies according to\nthe configuration. The result of this initialization is an ApplicationContext, which provides access to\napplication components, resource loading, internationalization support, and other features that won’t\nbe mentioned in this guide because it is out of scope.3 Figure 2-2 depicts the process of creating an\nApplicationContext using the Spring IoC container.\n2The process through which an object is provided its dependencies, whether it is using a constructor or properties which\nare set using setter methods, is called dependency injection. inversion of control is the concept through which an external\ncomponent has control over what is provided as a dependency to an object.\n3For more information, see the public reference documentation at http://docs.spring.io/spring/docs/current/\nspring-framework-reference.\n18\nChapter 2 ■ Spring FundamentalS\nFigure 2-2. How Spring works\nThe Spring Core Container\nThe Spring core container is made of the following modules:\n• spring-beans\n• spring-core\n• spring-context and spring-context-support (provides support classes that\nhelp integration of third-party libraries for caching, mailing, scheduling, and\ntemplate engines)\n• spring-expression\nThe spring-core and spring-beans modules provide the fundamental part of the framework: the\nIoC and dependency injection features, which the container needs to solve and inject dependencies as\nspecified in the configuration. The spring-context module extends the previous two modules, adding\nsupport for internationalization, resource loading, event propagation, and transparent creation of contexts.\nThe core component of this module is the ApplicationContext interface. The spring-expression module\nprovides a powerful Expression Language for querying and manipulating an object graph at runtime, and for\noperations like setting and getting property values, property assignment, and others.\n19\nChapter 2 ■ Spring FundamentalS\nConsidering the diagram in Figure 2-1, the classes needed to support implementing the operation to\nsave a Person instance look like this:\npublic class PlainPersonManagerImpl implements PersonManager {\nPersonRepository repo;\n//injecting a dependency using the constructor\npublic PlainPersonManagerImpl(PersonRepository repo) {\nthis.repo = repo;\n}\n...\n}\npublic class PlainPersonRepository implements PersonRepository {\nprivate DataSource dataSource;\n@Override\npublic int save(Person person) {\n..\n}\n//injecting a dependency using a setter method\npublic void setDataSource(DataSource dataSource) {\nthis.dataSource = dataSource;\n}\n}\n■ ! the PlainPersonRepository class is a simple pOJO persistence handler. its sole responsibility is to ensure\nPerson instances are saved and retrieved from the database. its behavior is built on a javax.sql.DataSource\nimplementation. this is different from the Spring data Jpa repositories used in the personal records manager\nproject, which will be presented later. the approach specific to this chapter is Spring Core–based, which is more\n“old-style,” before Spring data Jpa existed; this is to best introduce the Spring core modules and possibilities.\nTo implement that functionality in plain Java language, you have to write something like this:\nPersonRepository repo = new PlainPersonRepository();\nDataSource dataSource = new com.oracle.jdbc.pool.OracleDataSource();\ndataSource.setUrl(\"jdbc:oracle:thin:@localhost:1521:orcl\");\n//set other dataSource properties\n...\nrepo.setDataSource(dataSource);\nPersonManager personManager = new PlainPersonManagerImpl(repo);\nPerson person = new Person(\"John\", \"Smith\",\"1980-04-13\");\n// Use the manager\npersonManager.save(person);\nAs you can easily see, except the last line, everything else is setup code—the preparation before the\nexecution of the method. It is a lot of code. What would happen if you decided to change method signatures\nor to use a different DataSource implementation?",
    "answer": "A big part of this code would have to be changed too. In the next section, let’s see how Spring does the same thing. 20 Chapter 2 ■ Spring FundamentalS Spring Configuration There are three ways to define the configuration of an application using Spring:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Special XML configuration files that allow usage of elements described in the\nassociated namespaces\n• Java-based configuration classes (classes annotated with @Configuration can be\nused by Spring IoC as a source for bean definitions)\n• Mixed configuration: XML and annotations\nAll three types of configurations are covered in the following sections. The code sources attached to this\nchapter will help you test your understanding of each.\nXML\nThe following code is the XML content of a file named app-simple-config.xml, which is the configuration\nfile for a simple Spring application:\n<beans>\n<bean id=\"personManager\" class=\"com.book.plain.PlainPersonManagerImpl\">\n<constructor-arg ref=\"personRepository\" />\n</bean>\n<bean id=\"personRepository\" class=\"com.book.plain.PlainPersonRepository\">\n<property name=\"dataSource\" ref=\"dataSource\" />\n</bean>\n<bean id=\"dataSource\" class=\"com.oracle.jdbc.pool.OracleDataSource\">\n<property name=\"URL\" value=\"jdbc:oracle:thin:@localhost:1521:orcl\" />\n...\n</bean>\n</beans>\nAnd here is how the code to save a Person instance looks with Spring:\n// Create the application from the configuration\nApplicationContext context =\nnew ClassPathXmlApplicationContext(\"app-simple-config.xml\");\n// Look up the application manager interface\nPersonManager manager = (PersonManager) context.getBean(\"personManager\");\n// Use the manager\nmanager.save(new Person(\"John\", \"Smith\",\"1980-04-13\"));\nAs you can see, the code is a lot smaller, because all the preparation of the environment was\nmoved into the XML configuration file. And the configuration file can be manipulated more easily. If an\nexternal property file is used as entry for some of the values in it, in some simple cases, the application\ndoesn’t even have to be recompiled to change behavior. The DataSource configuration can be separated\nfrom the general configuration file, which can later allow you to easily switch between DataSource\nimplementations—depending on the context in which a code should run.\n21\nChapter 2 ■ Spring FundamentalS\n<util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/>\n<bean id=\"dataSource\" class=\n\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/>\n<property name=\"url\" value=\"#{dbProp.url}\"/>\n<property name=\"username\" value=\"#{dbProp.username}\"/>\n<property name=\"password\" value=\"#{dbProp.password}\"/>\n</bean>\nIn the previous example, the property values that look like #{value} are loaded from the db.properties\nfile, which contains the following:\ndriverClassName=org.h2.Driver\nurl=jdbc:h2: ~/prod\nusername=prod\npassword=prod\nThe values for the properties are loaded into a java.util.Properties instance with an id of dbProp\nusing a functionality offered by the util namespace in the first line of the configuration, and then their\nvalues are accessed using the SpEL (Spring Expression Language) syntax and injected into the dataSource\nbean. (There is another way to do this using a component named PropertyPlaceholderConfigurer, which\nis covered in the “How Bean Factory Post Processors Work” section.) Spring knows how to do this because\nconfiguration files are constructed using XML namespaces.\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:util=\"http://www.springframework.org/schema/util\"\nxsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/util\nhttp://www.springframework.org/schema/util/spring-util.xsd\">\n...\n</beans>\nThe underlined values in the previous example show how a prefix is assigned to a namespace and\nhow a namespace is associated with an XSD schema that contains the XML elements that can be used in\nthe configuration file. Usually, each namespace contains definitions for all XML tags for a specific spring\nmodule, or a group of tags with related responsibilities.\nAs everything in Spring is a bean, most commonly used configuration styles use the bean’s root\nelement, and the namespace for it is declared using the xmlns attribute. When additional namespaces are\nused, the elements defined by them need to be used inside the current element (beans). They need to have\na prefix associated so that the Spring IoC knows in which namespace to look for those element definitions;\nnotations such as xmlns:[prefix]=\"[namespace URL]\" are used.\n22\nChapter 2 ■ Spring FundamentalS\n■ ! the running code in this example can be found in 02-chapter-solution project. this is a module of the\nbook-code project, which was designed to gradually test your knowledge acquired while reading this book. the\nbook-code contains one or more modules for each chapter. Some module names are postfixed with -practice\nand contain a series of TODO tasks that the developer should be able to complete after reading a chapter.\nthe modules prefixed with -solution contain the completed tasks and are meant to be used for comparison\nwith the developer’s own solution. Sometimes a solution module might contain extra code that is meant simply\nto show the developer other situations that he might encounter in Spring projects.\nFor example, by splitting up the configuration file to isolate the DataSource configuration, you could\nhave the following configuration for a production environment:\nApplicationContext context =\nnew ClassPathXmlApplicationContext(\"application-config.xml\",\"db-config.xml\");\nAnd this configuration could be for a test environment:\nApplicationContext context =\nnew ClassPathXmlApplicationContext(\"application-config.xml\",\"test-db-config.xml\");\nThe two environments are completely decoupled, and the tests are very easy to write. Figure 2-3\ndisplays a typical structure for a Spring Maven project with a split configuration for production and a test\nenvironment.\nFigure 2-3. Typical Maven structure for a project\n23\nChapter 2 ■ Spring FundamentalS\n■ ! in this example, the configuration files were created under a directory named spring to emphasize that\nthese are Spring configuration files, because in a more complex project there could be Xml configuration files\nfor other purposes (for example, logging or caching stored outside of the spring directory). the code in this\nbook intentionally skips the spring directory from the path to reduce the size of the quotes and to make the list\nof configuration files more readable.\nIn the configuration files, and when instantiating contexts, resources are usually prefixed with a word\nthat tells the Spring container where they are located. These prefixes can be used for any type of resources\nneeded in an application. Consider a standard Maven setup for a project like the one in Figure 2-3; Table 2-1\nshows the paths where a Spring container would look for resource files depending on the prefix.\nTable 2-1. Prefixes and Corresponding Paths\nPrefix Location Comment\nno prefix In root directory where the class In the main or test directory. The type of the resource\ncreating the context is executed. being loaded depends on the ApplicationContext\ninstance being used. (A detailed example is presented\nafter this table.)\nclasspath: The resource should be obtained In the resources directory; the resource is of type\nfrom the classpath. ClassPathResource.\nfile: In the absolute location following The resource is loaded as a URL from the filesystem\nthe prefix. and is of type UrlResource.\nhttp: In the web location following The resource is loaded as a URL and is of type\nthe prefix. UrlResource.\nThe following is an example of resource loading without using a prefix:\nResource template = ctx.getResource(\"application-config.xml\");\nDepending on the context class used, the resource loaded can have one of the following types:\n• If ctx is a ClassPathXmlApplicationContext instance, the resource type is\nClassPathResource\n• If ctx is a FileSystemXmlApplicationContext instance, the resource type is\nFileSystemResource\n• If ctx is a WebApplicationContext instance, the resource type is\nServletContextResource\n24\nChapter 2 ■ Spring FundamentalS\nAnnotations\nSpring also supports configuration via annotations. The previous XML configuration can be replaced by a\nclass annotated with @Configuration, and looks like this:\n@Configuration\n@PropertySource(value = \"classpath:datasource/db.properties\")\npublic class AppConfig {\n@Autowired\nEnvironment env;\n@Bean(name=\"personManager\")\npublic PersonManager getPersonManager(){\nreturn new PlainPersonManagerImpl(getPersonRepository());\n}\n@Bean(name=\"personRepository\")\npublic PersonRepository getPersonRepository(){\nPersonRepository repo = new PlainPersonRepository();\nrepo.setDataSource(getDataSource());\nreturn repo;\n}\n@Bean(name=\"dataSource\")\npublic DataSource getDataSource(){\nDriverManagerDataSource dataSource = new DriverManagerDataSource();\ndataSource.setDriverClassName(env.getProperty(\"driverClassName\"));\ndataSource.setUrl(env.getProperty(\"url\"));\ndataSource.setUsername(env.getProperty(\"username\"));\ndataSource.setPassword(env.getProperty(\"password\"));\nreturn dataSource;\n}\n}\nAll the code to save a Person instance looks like this:\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = {AppConfig.class})\npublic class SecondAnnotationPersonSaveTest {\n@Autowired\nPersonManager personManager;\n@Test\npublic void savePerson() {\npersonManager.save(new Person(\"John\", \"Smith\", \"1980-04-13\"));\n}\n}\n25\nChapter 2 ■ Spring FundamentalS\nWhen annotations are used, XML configuration files are no longer needed, nor namespaces. Specific\nannotations are used to mark configuration classes (@Configuration) and to mark methods as bean\ndefinitions (@Bean); this is not covered because it is outside the scope of this book. What you need to\nremember is that the @Bean annotation makes sure that every time the annotated method is called the same\nbean is returned. Without it, the method will return a newly created instance each time.\n■ CC in the previous code example, each @Bean annotation has the attribute name populated with a value\nto name the bean created by the method. this attribute is neither mandatory nor necessary. When it is not\nspecified, the Spring ioC determines a name for the bean based on the method name by removing the get and\nlowercasing the first letter of the remaining string.\nMixed Approach\nXML and annotations can be mixed. You could have the bean classes annotated with @Component (or any\nannotation extending @Repository for DAO repository classes, @Service for service classes, or @Controller\nfor MVC handler classes) and one or more XML files, which define just the DataSource configuration\nand specifies where the beans are located. In the following code sample, the DataSource configuration is\nseparated in another file (as shown in the “How Bean Factory Post Processors Work” section) to decouple\nconfigurations for production and test environments.\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:context=\"http://www.springframework.org/schema/context\"\nxsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\"\n<context:component-scan base-package=\"com.book.beans\"/>\n...\n</beans>\nIn XML configuration files, bean definitions describe the way a dependency should be provided to\nthem: using either constructors or setters. This is called autowiring. When using annotations, the way a\ndependency should be provided is described using the @Autowire annotation on a constructor or setter.4\nBut you need to tell the Spring IoC container to look for that type of annotation, and the declaration\n<context:component-scan ...> does exactly that.\nWhen using annotations, <bean> declarations are no longer needed because each bean type is\nannotated with @Component, or an extension of it, and the <context:component-scan..> declaration tell\nthe Spring IoC container to look for those types of annotations in the specific file. The process of identifying\nannotated bean types is called autodiscovery.\n4The @Autowiring annotation can also be used on the field directly, called field injection; but this approach is discouraged\nbecause it makes testing difficult. As the field is usually private, to test the containing bean, a full Spring context must be\nset up or reflection must be used to access the field.\n26\nChapter 2 ■ Spring FundamentalS\nThus what the following configuration element does is enable bean autowiring and autodiscovery\nanywhere in the classpath in packages (and subpackages) named as the value of the attribute base-package.\n<context:component-scan base-package=\"com.book.beans\"/>\nThe <context: ..> declarations are Spring’s way of compacting the declaration of infrastructure beans\nnamed *PostProcessor, which take care of interpreting annotations into beans definitions.\n• <context:annotation-config/> registers the following:\n– AutowiredAnnotationBeanPostProcessor (supports @Autowired, @Value,\n@Inject)\n– CommonAnnotationBeanPostProcessor (supports @Resource, @PostConstruct,\n@PreDestroy)\n– PersistenceAnnotationBeanPostProcessor (supports @PersistenceUnit,\n@PersistenceContext)\n– RequiredAnnotationBeanPostProcessor (supports @Required)\n• <context:component-scan base-package=\"com.book.beans\"/> implicitly enables\nthe functionality of <context:annotation-config> and adds support for more\nannotations (@Repository, @Service, @Controller, which are specializations of\n@Component, @Configuration, etc.)\nIf you want to extend your knowledge about this, you can always read the Spring Reference\nDocumentation.5 More detailed information is outside the scope of this book.\nThe Beans\nThe beans are the objects handled by the Spring IoC container. The following section will cover all you need\nto know about how beans are created, how the beans are categorized, how they are accessed, and how they\nare destroyed when they are no longer needed.\nLifecycle and Instantiation\nThe beans are created in order of dependency. If a bean of type B, needs a bean of type A for its creation,\nthe Spring container will know to first create bean A and then inject it into bean B. If an application has\nmultiple configuration files, the Spring container first reads all of them, internally creates a dependency tree\nof bean definitions, and then starts traversing the tree, starting with its lowest level where the simplest bean\ndefinitions are. In the cases mentioned in previous sections, the order for bean creation (instantiation) is\ndataSource, personRepository, and personManager. The steps are described in Figure 2-4.\n5The Spring Reference Documentation can be accessed at http://docs.spring.io/spring/docs/current/\nspring-framework-reference/htmlsingle/.\n27\nChapter 2 ■ Spring FundamentalS\nFigure 2-4. Order of bean instantiation\nA bean cannot be created if its required dependencies do not exist; an exception is thrown in case of\nmissing dependencies. But how does the Spring container know which dependencies are required?",
    "answer": "There are a few ways. One is the type of injection. Spring supports two types of injection: via constructor and via setter. The constructor injection is when the constructor of a bean is defined as having an argument of type another bean. In the previous example, the PersonManagerImpl constructor definition requires a PersonRepository instance as an argument, and thus the PersonManagerImpl requires a bean of type PersonRepository to be created before its creation. <!– Constructor injection –> <bean id=\"personManager\" class=\"com.book.PersonManagerImpl\"> <constructor-arg ref=\"personRepository\" /> </bean> <!– Setter injection–> <bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\"> <property name=\"dataSource\" ref=\"dataSource\" /> </bean> 28 Chapter 2 ■ Spring FundamentalS Any object that has a constructor with arguments cannot be constructed without passing in arguments. This restriction does not apply for the setter injection, but it can be enforced in two ways:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "By annotating the setter method with @Required. If the property is not set, a\nBeanInitializationException is thrown.\n• By annotating the setter method with @Autowire the Spring IoC container\ntries to inject a bean with the specific type. If such a bean is not found, a\nBeanCreationException is thrown.\nOne of the advantages of using the setter injection is that you can create hierarchical beans,\nand setters will be inherited. In a setter injection, bean creation and dependency injection are two\nseparate steps; for constructor injection there is only one step. So basically, setter injection makes your\nconfiguration more flexible.\nFor a bean to “come to life” and become available to be used for a purpose, it has to go through the steps\nshown in Figure 2-5.\nFigure 2-5. The steps for a bean creation\n29\nChapter 2 ■ Spring FundamentalS\nHow Bean Factory Post Processors Work\nA bean definition can be modified before instantiating the bean, and this is done by beans called bean\nfactory post processors. They are defined as classes implementing the BeanFactoryPostProcessor interface\nand are recognized by an application context and instantiated before any other beans in the container.\nThe most used and known in the Spring world is the PropertyPlaceholderConfigurer.\n<bean id=\"dataSource\" class=\n\"o.s.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"${driverClassName}\"/>\n<property name=\"url\" value=\"${url}\"/>\n<property name=\"username\" value=\"${username}\"/>\n<property name=\"password\" value=\"${password}\"/>\n</bean>\n<context:property-placeholder location=\"classpath:datasource/db.properties\"/>\nThe last line in this example is a simplified version of defining a PropertyPlaceholderConfigurer using\nthe Spring context namespace; it is equivalent to the following:\n<bean class=\n\"o.s.beans.factory.config.PropertyPlaceholderConfigurer\">\n<property name=\"location\" value=\"classpath:datasource/db.properties\"/>\n</bean>\nThis bean reads those properties from the db.properties file and then populates the dataSource\nsource bean with their values. Of course, the easier way to do this is to use SpEL expressions and the util\nnamespace:\n<util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/>\n<bean id=\"dataSource\" class=\n\"o.s.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/>\n<property name=\"url\" value=\"#{dbProp.url}\"/>\n<property name=\"username\" value=\"#{dbProp.username}\"/>\n<property name=\"password\" value=\"#{dbProp.password}\"/>\n</bean>\nBean Initialization and Destruction\nAn ApplicationContext instantiates all singleton (bean scopes are covered in detail in the “Bean Scopes”\nsection) beans by default and also destroys them at the end of their lives. After a bean has been created and\nits dependencies injected, it can be initialized automatically by telling the context to execute a specified\nmethod. Before a bean ends its life, a different method might be called to do some resource cleanup. The\ncontext can be told to automatically do that too. These methods must have a void no-argument signature.\nThere is no restriction on the accessor used for them. In the official documentation, the lifecycle methods\ngiven as example are all public. But there are opinions that state they should be protected or private\n(obviously, it does not apply to InitializingBean’s afterPropertiesSet and DisposableBean’s destroy)\nto prevent direct calls of these methods from the application code, as these methods should be called only\nonce and only by the Spring IoC container.\n30\nChapter 2 ■ Spring FundamentalS\nThere are multiple options for bean initialization:\n• Using @PostConstruct from JSR 250\n• Using @Bean’s initMethod attribute\n• Implementing InitializingBean and providing implementation for the\nafterPropertiesSet method (not recommended because it couples the application\ncode with Spring infrastructure code)\n• Using the init-method attribute on a <bean/> XML definition\nWhen a bean ends its life, some cleanup operations might be necessary; to implement this kind of\nbehavior, there are also multiple options:\n• Using @PreDestroy from JSR 250\n• Using @Bean’s destroyMethod attribute\n• Implementing DisposableBean and providing implementation for the destroy\nmethod (not recommended, as it couples the application code with Spring\ninfrastructure code)\n• Using the destroy-method attribute on a <bean/> XML definition\nIn the code sample there is a bean in the com.book.spring.components package that was implemented\nin such a way to clarify the Spring bean lifecycle. The bean is called CompleteLivingBean and has\n@PostConstruct and @PreDestroy annotated methods, implements InitializingBean and\nDisposableBean, and has methods in which names are used as values for attributes init-method and\ndestroy-method. This bean was implemented using a combined lifecycle strategy to clearly show when each\ninitializer/destruction method is called by the Spring IoC and to clearly display the bean creation steps in\nFigure 2-5.\nThis is the configuration:\n<context:component-scan base-package=\"com.book.beans\"/>\n<bean id=\"livingBean\" class=\"com.book.beans.CompleteLivingBean\"\ninit-method=\"initMethod\"\ndestroy-method=\"destroyMethod\">\n<property name=\"internal\" value=\"testValue\"/>\n</bean>\nThis is the definition of the bean class:\npublic class CompleteLivingBean implements InitializingBean, DisposableBean {\npublic String internal;\npublic CompleteLivingBean() {\nlogger.info(\"1. Constructor.\");\n}\npublic void setInternal(String internal) {\nlogger.info(\"2. Setter.\");\nthis.internal = internal;\n}\n31\nChapter 2 ■ Spring FundamentalS\n@PostConstruct\npublic void postConstruct(){\nlogger.info(\"3. @PostConstruct.\");\n}\n@Override\npublic void afterPropertiesSet() throws Exception {\nlogger.info(\"4. afterPropertiesSet.\");\n}\npublic void initMethod(){\nlogger.info(\"5. init-method.\");\n}\n@PreDestroy\npublic void preDestroy(){\nlogger.info(\"6. PreDestroy.\");\n}\n@Override\npublic void destroy() throws Exception {\nlogger.info(\"7. destroy.\");\n}\npublic void destroyMethod() throws Exception {\nlogger.info(\"8. destroy-method.\");\n}\n}\nAlso, there is no restriction on method names used as values for init-method and destroy-method\nattributes; initMethod and destroyMethod were used in this example to make their purpose really obvious.\n■ ! in the certification exam, you might be asked which method is executed first—the one annotated with\n@PostConstruct or the one mentioned by the init-method; so the CompleteLivingBean helps clear up when\nmethods are executed and why.\nWhen executing the test for the com.book.beans.BeanLifecycleTest bean, you will see the\nfollowing output:\nINFO c.b.b.CompleteLivingBean - 1. Constructor.\nINFO c.b.b.CompleteLivingBean - 2. Setter.\nINFO c.b.b.CompleteLivingBean - 3. @PostConstruct.\nINFO c.b.b.CompleteLivingBean - 4. afterPropertiesSet.\n32\nChapter 2 ■ Spring FundamentalS\nINFO c.b.b.CompleteLivingBean - 5. init-method.\n...\nINFO c.b.b.CompleteLivingBean - 6. @PreDestroy.\nINFO c.b.b.CompleteLivingBean - 7. destroy.\nINFO c.b.b.CompleteLivingBean - 8. destroy-method.\nAs represented in Figure 2-5, when a bean is created, the following succession of actions happens:\n1. The constructor is called first to create the bean.\n2. The dependencies are injected (setters are called).\n3. The pre-initialization BeanPostProcessors are consulted to see if they want to\ncall anything from this bean. The @PostConstruct annotation is registered by\nthe CommonAnnotationBeanPostProcessor, so this bean will call this annotated\nmethod. This method is executed right after the bean has been constructed and\nbefore the class is put into service,6 before the actual initialization of the bean\n(before afterPropertiesSet and init-method).\n4. The InitializingBean’s afterPropertiesSet is executed right after the\ndependencies were injected.\n5. The init-method attribute value method is executed last, as this is the actual\ninitialization method of the bean.\nWhen a bean is destroyed:\n1. The @PreDestroy method is executed, as this has to be executed before a destroy\nmethod, if one exists. The PreDestroy annotation is used on methods as a\ncallback notification to signal that the instance is in the process of being removed\nby the container.7\n2. The DisposableBean’s destroy method is executed next, as the Spring standard\norder defines it so.\n3. The destroy-method attribute value method is executed last, as this is the actual\ndestroy method of the bean, and the Spring standard order defines it so.\nThis is the simplified and more natural explanation of the bean lifecycle; in most cases, this is all you\nwill need. If you want to view the full picture with full plumbing details and other things the context does,\nyou can read the official JEE and Spring documentation.8\n■ ! the main reason for init-method and destroy-method creation was to give the developer a little\ncontrol over beans definitions from third-party libraries, which have classes that cannot be modified or\nextended. this way, the developer can decide what gets executed after creation and what executes before\ndestruction by using Xml configuration.\n6A snippet from the JEE official Java doc at http://docs.oracle.com/javaee/7/api/javax/annotation/\nPostConstruct.html.\n7A snippet from the JEE official Java doc at http://docs.oracle.com/javaee/7/api/javax/annotation/\nPreDestroy.html.\n8http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/\nBeanFactory.html.\n33\nChapter 2 ■ Spring FundamentalS\nHow Bean Post Processors Work\nA BeanPostProcessor allows the developer to process a bean instance created by the IoC container after its\ninstantiation, and then again after the initialization lifecycle event has occurred on it. BeanPostProcessors\nare defined as classes implementing the BeanPostProcessor interface, and are recognized by an application\ncontext and instantiated before any other beans in the container, because after their instantiation, they are\nused to manipulate other beans instantiated by the IoC container. The @PostConstruct and @PreDestroy\nannotations are processed by a bean called CommonAnnotationBeanPostProcessor. This is not a default\ninfrastructure bean for the Spring IoC container, so to use it you have to specify it in the configuration of the\napplication. You would expect to need something like this in the mvc-config.xml file:\n<bean class=\"o.s.c.a.CommonAnnotationBeanPostProcessor\"/>\nAnd this could work, but there will be some issues because configuring the bean like that overrides the\nSpring defaults, which might lead to unexpected behavior. Fortunately, this bean configuration is one of\nthose included in the following line, a Spring shortcut based on the context namespace:\n<context:component-scan base-package=\"com.book.beans\"/>\nOr in this one:\n<context:annotation-config/>\nThe BeanPostProcessor beans wrap other beans into AOP proxies that add extra behavior (more details\non AOP in the “Spring AOP” section). The Spring Framework has different types of BeanPostProcessors\nthat can be used for caching, transactions, security, and so forth. The CommonAnnotationBeanPostProcessor\nscans for methods annotated with @PostConstruct and @PreDestroy, and calls those methods at the\nappropriate time.\nThe code samples use logback to display logs. By increasing the granularity of the log for\nthe Spring Framework to DEBUG, you can see what is happening “behind the scenes,” and what\nCommonAnnotationBeanPostProcessor is actually doing. In the following configuration snippet, you are\nshown how to modify the granularity of the log by editing the logger element for the Spring Framework in\nthe logback.xml file:\n<logger name=\"org.springframework\" level=\"DEBUG\" additivity=\"false\">\n<appender-ref ref=\"STDOUT\" />\n</logger>\nAfter modifying the log file when running the BeanLifecycleTest, you can see the behavior of the\nCommonAnnotationBeanPostProcessor9:\nINFO CompleteLivingBean - 1. Constructor.\nDEBUG CABPP - Found init method on class\nCompleteLivingBean: private void CompleteLivingBean.postConstruct()\nDEBUG CABPP Found destroy method on class\nCompleteLivingBean: protected void CompleteLivingBean.preDestroy()\n9CABPP is the acronym for CommonAnnotationBeanPostProcessor. It is used to fit a log quote nicely on a page.\n34\nChapter 2 ■ Spring FundamentalS\nDEBUG CABPP Registered init method on class CompleteLivingBean:\nInitDestroyAnnotationBeanPostProcessor$LifecycleElement@64e17f36\nDEBUG CABPP Registered destroy method on class CompleteLivingBean:\nDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7\nINFO c.b.b.CompleteLivingBean - 2. Setter.\nDEBUG CABPP - Invoking init method on bean ’livingBean’:\nprivate void CompleteLivingBean.postConstruct()\nINFO c.b.b.CompleteLivingBean - 3. @PostConstruct.\nINFO c.b.b.CompleteLivingBean - 4. afterPropertiesSet.\n...\nDEBUG CABPP - Invoking destroy method on bean ’livingBean’:\nprotected void CompleteLivingBean.preDestroy()\nINFO c.b.b.CompleteLivingBean - 1. @PreDestroy.\nThe previous section mentioned that there are annotation attributes equivalents for the init-method and\ndestroy-method. If you were to define CompleteLivingBean using a class annotated with @Configuration,\nit would look like this:\n@Bean(initMethod = \"initMethod\", destroyMethod = \"destroyMethod\")\npublic CompleteLivingBean getCompleteLivingBean() {\nreturn new CompleteLivingBean();\n}\nAnd would be equivalent to this XML definition:\n<bean id=\"livingBean\" class=\"com.book.beans.CompleteLivingBean\"\ninit-method=\"initMethod\" destroy-method=\"destroyMethod\"/>\nBean Scopes\nWhen the Spring IoC instantiates beans, it creates a single instance for each bean—unless a property is set\non the bean definition specifying otherwise. The property in question is called scope and the default scope\nfor a bean is singleton. The scopes are defined in Table 2-2.\nTable 2-2. Bean Scopes\nScope Description\nsingleton The Spring IoC creates a single instance of this bean and any request for beans with\nan id or ids matching this bean definition results in this instance being returned.\nprototype Every time a request is made for this specific bean, the Spring IoC creates\na new instance.\nrequest The Spring IoC creates a bean instance for each HTTP request. Only valid in the\ncontext of a web-aware Spring ApplicationContext.\nsession The Spring IoC creates a bean instance for each HTTP session. Only valid in the\ncontext of a web-aware Spring ApplicationContext.\nglobal-session The Spring IoC creates a bean instance for each global HTTP session. Only valid in\nthe context of a web-aware Spring ApplicationContext.\n35\nChapter 2 ■ Spring FundamentalS\nSo when a bean is created without a scope attribute, the scope of the bean is singleton:\n<bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\">\n<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\nOtherwise, the scope of the bean is the one specified by the value of the scope attribute:\n<bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\"\nscope=\"prototype\">\n<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\nThere is an annotation equivalent to this that can be used on @Component (and other stereotype\nannotations) annotated beans:\n@Component\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class PrototypeBean {\nprivate Logger logger = LoggerFactory.getLogger(PrototypeBean.class);\nprivate static int instanceCounter = 0;\npublic PrototypeBean() {\nlogger.info(\"-> Constructing instance no: \" + (++instanceCounter));\n}\n}\n■ ! @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) is equivalent to\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) and @Scope(\"prototype\") because constant\nSCOPE_PROTOTYPE is of type string and has the \"prototype\" value. using Spring constants eliminates the\nrisk of misspelling the scope value.\nThe @Scope annotation can also be used on a bean definition annotated with @Bean to specify the scope\nof the resulting bean.\n@Bean(name=\"personManager\")\n@Scope(\"prototype\")\n//or @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic PrototypeBean getPrototypeBean(){\nreturn new PrototypeBean();\n}\n36\nChapter 2 ■ Spring FundamentalS\nIf you were to execute the following test, the test would pass:\n@Test\npublic void testPrototype() {\n// Create the application from the configuration\nClassPathXmlApplicationContext context =\nnew ClassPathXmlApplicationContext(\"classpath:test-app-config.xml\");\nPrototypeBean pb1 = (PrototypeBean)context.getBean(\"prototypeBean\");\nassertNotNull(pb1);\n//the bean is requested by type\nPrototypeBean pb2 = context.getBean(PrototypeBean.class);\nassertNotNull(pb2);\nassertNotEquals(pb1,pb2);\n}\nAnd this is what would be seen in the log file:\nDEBUG - Creating instance of bean 'prototypeBean'\nINFO -> Constructing instance no: 1\nDEBUG - Finished creating instance of bean 'prototypeBean'\nDEBUG - Creating instance of bean 'prototypeBean'\nINFO -> Constructing instance no: 2\nDEBUG - Finished creating instance of bean 'prototypeBean'\nA special case of bean scope is the scope of an inner bean. An inner bean is defined within the scope\nof another bean. The reason for doing this is because the bean does not need to be shared with other\nbeans, but is needed only for the creation of the enclosing bean. The scope attribute has no meaning for an\ninner bean and is ignored; so are the attributes id and name, as the bean is anonymous. When using Java\nConfiguration, the inner bean is just a local variable in a method. The following code snipped declares the\nDataSource bean as an inner bean:\n<util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/>\n<bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\">\n<property name=\"dataSource\">\n<bean id=\"dataSource\" class=\n\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/>\n<property name=\"url\" value=\"#{dbProp.url}\"/>\n<property name=\"username\" value=\"#{dbProp.username}\"/>\n<property name=\"password\" value=\"#{dbProp.password}\"/>\n</bean>\n</property>\n</bean>\n37\nChapter 2 ■ Spring FundamentalS\nAccessing Beans\nBeans can be identified in three ways: by type, by name, and by id. The following subsections explain\nthese in detail; examples are provided for each case. How to access beans configured with annotates is\ncovered too.\nBean Identification by Type\nA bean can be identified by its type if there is only one definition of a bean with that type in the Spring\nconfiguration file.\nThe BeanPostPrecessor classes registered by <context:annotation-config/> that scan for\nannotations are singleton infrastructure beans instantiated by the Spring IoC container, when that\nconfiguration line is present in a Spring configuration file. At any time during the life of an application only\none instance of each of those beans will exist. Basically, this configuration file:\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:context=\"http://www.springframework.org/schema/context\"\nxsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n<context:annotation-config/>\n</beans>\nIs equivalent to this:\n<?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <!--the org.springframework. package was shortened to o.s. for this code to fit the page better --> <bean class=\"o.s.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/> <bean class=\"o.s.context.annotation.CommonAnnotationBeanPostProcessor\"/> <bean class=\"o.s.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/> <bean class=\"o.s.beans.factory.annotation.RequiredAnnotationBeanPostProcessor\"/> </beans> Considering the following bean definition: <bean class=\"com.book.sandbox.SimpleBean\" /> 38 Chapter 2 ■ Spring FundamentalS If there is no other bean definition with the same class attribute value, the bean can be accessed like this: SimpleBean sb = context.getBean(SimpleBean.class); Or can even be injected as a dependency via autowiring: @Autowired SimpleBean simpleBean; ■ ! in the book-code/02-chapter project, there is a class called BeanIdentificationTest that tests various scenarios of bean identification. Bean Identification by Name The <bean/> element has an attribute called name. The value assigned to this attribute in a bean definition can be used to access this bean. A duplicate bean name will invalidate a configuration file. The name is flexible and can be used to define more than one name when the values are separated by a comma (\",\") or a semicolon (\";\"). The bean is defined as follows: <bean name=\"sbb0\" class=\"com.book.sandbox.SimpleBean\"/> Can be accessed as follows: // the old way SimpleBean sb0 = (SimpleBean)context.getBean(\"sb0\"); // or the Spring 3.0 way SimpleBean sb0 = context.getBean(\"sb0\", SimpleBean.class); And can also be injected as a dependency via autowiring using the @Qualifier annotation: @Autowired @Qualifier(value = \"sb0\") SimpleBean simpleBean; The @Bean annotation has a name attribute too, so an equivalent annotation configuration can be created: @Bean(name=\"simpleBean\") public SimpleBean getSimpleBean(){ return new SimpleBean(); } 39 Chapter 2 ■ Spring FundamentalS Bean Identification by id The <bean/> element has an attribute called id. The value assigned to this attribute in a bean definition can be used to access the bean. This attribute uniquely identifies a bean, so a duplicate bean id will invalidate a configuration file. This attribute can appear alongside the name attribute, and both can be used to access the bean. The id and the name attributes serve the same purpose: they are both used to define bean identifications. The difference between them is that the value of the id attribute must conform to XML standard id, which means no weird characters like a comma (\",\") or semicolon (\";\") can be contained in it. Basically, the following bean definition is valid: <bean name=\"sb0\" id=\"id0\" class=\"com.book.sandbox.SimpleBean\"/> And the following test will pass, as both calls will return the same bean: @Test public void testBeans() { ... SimpleBean sb01 = context.getBean(\"sb0\", SimpleBean.class); SimpleBean sb02 = context.getBean(\"id0\", SimpleBean.class); assertTrue(sb01 == sb02); } Accessing Annotated Beans The beans defined using @Component and extensions of it can be autowired by name or by type without any extra configuration. ■ CC When using annotation configuration—beans annotated with @Component or extensions of it—the Spring ioC container also creates a logical name for these beans by lowercasing the first letter of the class name. @Component @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class PrototypeBean { ... } ... \\\\ requesting bean by name PrototypeBean pb1 = (PrototypeBean)context.getBean(\"prototypeBean\"); assertNotNull(pb1); \\\\Requesting bean by type PrototypeBean pb2 = context.getBean(PrototypeBean.class); assertNotNull(pb2); assertNotEquals(pb, pb2); 40 Chapter 2 ■ Spring FundamentalS Spring AOP AOP is an acronym for aspect-oriented programming and represents a programming paradigm that aims to simplify code by grouping repetitive operations in units called aspects. AOP helps managing common functionality that spans across the application, like logging, security, and transactionality. AOP complements OOP (object-oriented programming) by providing a more advanced way of decoupling the code and modularizing an application. The AOP framework complements the Spring IoC container. The container can be used without it in small applications that do not require the use of security or transactions, because these are the key crosscutting concerns for enterprise applications. In Spring, an aspect is class annotated with @Aspect. It contains methods called advices that are annotated with aspect-specific annotations that intercept the execution of other beans’ methods and performs specific operations before and/or after their execution, and can prevent the execution of an intercepted method if necessary. The AOP framework makes this possible by scanning all aspects when the application context is started, and creates AOP proxy objects that wrap around existing beans to implement aspect contracts. When the target beans are requested for usage or injection, the proxy object is injected or returned instead. From a developer’s point of view, it looks like the intended object is used, but the Spring IoC container works with the proxy object that is wrapped around it. Let’s see how AOP can make things easier when you want to save a Person instance to the database using the PersonManagerImpl mentioned at the beginning of the chapter. The following is what the code looks like in Spring without AOP. Figure 2-6 shows the UML diagram. <!-- configuration will contain this element --> <bean id=\"txManager\" class= \"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> <property name=\"dataSource\" ref=\"dataSource\"/> </bean> // PersonManagerImpl.java ... @Autowired @Qualifier(\"txManager\") PlatformTransactionManager transactionManager; @Autowired @Qualifier(\"personRepository\") PersonRepository repo; public int save(Person person) { TransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); int result = repo.save(person); transactionManager.commit(status); return result; } 41 Chapter 2 ■ Spring FundamentalS Figure 2-6. Diagram in non-AOP mode And here is how it looks using AOP (the UML diagram is presented in Figure 2-7): <!-- configuration will contain this element needed to switch on the transactional behaviour --> <tx:annotation-driven transaction-manager=\"txManager\"/> // PersonManagerImpl.java @Component(\"personManager\") @Transactional public class PersonManagerImpl implements PersonManager { @Autowired @Qualifier(\"personRepository\") PersonRepository repo; public int save(Person person) { return repo.save(person); } } 42 Chapter 2 ■ Spring FundamentalS Figure 2-7. Diagram in AOP mode The <tx:annotation-driven/> configuration element is defined in the Spring tx namespace, which has to be added to the configuration file: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"> ... </beans> And in order to run the methods of a bean in a transactional environment, you also have to specify the TransactionManager instance used to handle the transactions. In a test environment, the annotation @TransactionConfiguration is used: @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {\"classpath:app-aop-cfg.xml\", \"classpath:spring/test-db-config.xml\"}) @TransactionConfiguration(transactionManager = \"txManager\") public class PersonSaveTest { ... } 43 Chapter 2 ■ Spring FundamentalS To verify that the test method is running in a transaction environment, you can switch the Spring Framework log to DEBUG, as explained in the “Lifecycle and Instantiation” section, and run the test. In the console, the following logs will prove this: DEBUG o.s.j.d.DataSourceTransactionManager - Acquired Connection conn1: url=jdbc:h2:mem:dataSource user=SA for JDBC transaction DEBUG o.s.j.d.DataSourceTransactionManager - Switching JDBC Connection conn1: url=jdbc:h2:mem:dataSource user=SA to manual commit INFO c.b.a.PersonManagerImpl - -> Calling repo.save(person) DEBUG o.s.j.c.JdbcTemplate - Executing prepared SQL update DEBUG o.s.j.c.JdbcTemplate - Executing prepared SQL statement insert into person (firstname, lastname, date_of_birth) values (?,?,?) DEBUG o.s.j.c.JdbcTemplate - SQL update affected 1 rows INFO c.b.a.PersonManagerImpl - -> repo.save execution completed. DEBUG o.s.j.d.DataSourceTransactionManager - Initiating transaction commit DEBUG o.s.j.d.DataSourceTransactionManager - Committing JDBC transaction on Connection conn1: url=jdbc:h2:mem:dataSource user=SA DEBUG o.s.j.d.DataSourceTransactionManager - Releasing JDBC Connection conn1: url=jdbc:h2:mem:dataSource user=SA after transaction ■ CC if the bean of type TransactionManager is named transactionManager when in a transactional environment, the Spring ioC container will detect it automatically and there is no need to specify it as an argument for the @TransactionConfiguration annotation. even more, @TransactionConfiguration can be replaced with @Transactional, and the test methods will still be executed in a transactional environment. the transaction-manager attribute from the <tx:annotation-driven/> can be omitted too. also, @Qualifier(\"transactionManager\") is not needed when the transactionManager is autowired and the bean of type TransactionManager has the default name. in the code samples presented here, a bean of type TransactionManager with a different name was used to show the developer the configurations needed to work in cases other than the default one, because in bigger applications, multiple beans of type TransactionManager might be needed. Testing Spring Applications When it comes to writing code, there are two types of testing that matter: unit testing and integration testing.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Unit testing is used to test small units of code, thus its naming. Unit testing is easy to\ndo—not much setup is necessary, and since JUnit10 has introduced @Test annotation\nwriting, unit tests have become a breeze.\n10The most commonly used Java testing framework (see http://junit.org).\n44\nChapter 2 ■ Spring FundamentalS\n• Integration testing is used to test bigger chunks of code made up of objects\ninteracting together in a given context, and the focus is set on business logic and\nobject integration with each other. The context is usually made up of mocks or stubs\nthat replace the objects, which are not the focus of the tests. You can imagine that\ncreating a testing context is not a simple job.\nThe Spring Framework includes a testing module called spring-test that makes integration testing\nreally practical to implement. The tests that have been used throughout this chapter use the spring-test\nmodule.\n• The SpringJUnit4ClassRunner, as the names says, is a Spring class used to tell JUnit\nthat the tests in this class are executed in a Spring test context.\n• The @ContextConfiguration receives one or more configuration files as parameters\nthat are used to initialize the test context.\n• The @TransactionConfiguration is the annotation that injects the\ntransactionManager instance used to run tests in a transactional environment. As\nmentioned earlier, this can be skipped, and @Transactional can be used when the\nTransactionManager bean has the default name.\n■ CC When using @ContextConfiguration to annotate a test class, the configuration file path can be\nskipped, and then Spring ioC container will look for a file named [TestClassName]-context.xml in the same\nlocation where the test class is defined. When the project has a maven structure, the configuration is placed in\nthe resources directory, and the directories matching the package name for the test class are created so the\nfile will have the same relative path as the test class.\nSo if you have test class com.book.simple.SimpleTest annotated with @ContextConfiguration, then\nresources will have com/books/simple/SimpleTest-context.xml to provide the test context configuration,\nwhich is automatically discovered and used by the Spring ioC container.\nSummary\nAfter reading this chapter, you should have a basic knowledge of how Spring does its magic and understand\nthe following:\n• Two flavors of configuration can be mixed: XML-based (decoupled from classes\ncode) and Java annotation–based (bean definitions are mixed in the class code)\n• The lifecycle of a bean\n• How to access a bean\n• What AOP is and how and where Spring can apply it\n• How to test Spring applications\n45\nChapter 2 ■ Spring FundamentalS\nQuick Quiz\nQuestion 1: What is a bean?",
    "answer": "A. a plain old Java object B. an instance of a class C. an object that is instantiated, assembled, and managed by a Spring IoC container Question 2: What is the default scope of a bean? A. default B. singleton C. protected D. prototype Question 3: What types of dependency injection are supported by Spring IoC container? A. setter injection B. constructor injection C. interface-based injection D. field-based injection Question 4: What is true about @PostConstruct and @PreDestroy ? A. they are JSR-250 annotations B. they are supported by AutowiredAnnotationBeanPostProcessor C. they are registered by the <context:component-scan/> element Detailed answers are in the Appendix. Practical Exercise The practice module for this chapter is in the book-code project; it is named 02-chapter-practice. The solution is in the 02-chapter-solution module. You are given the code for a few related beans. Your task is to complete the existing configuration files, to create test contexts, and to make sure that the tests pass. The book-code project is a gradle multimodule project. It can be built from the command line by running gradle build under the book-code directory. This will build all modules of the project. The build will fail when run for the first time because of the unresolved tasks in the -practice projects. If you do it this way, you will have something similar to the following output in your console: $ gradle build .. :02-chapter-practice:compileJava UP-TO-DATE :02-chapter-practice:processResources UP-TO-DATE :02-chapter-practice:classes UP-TO-DATE :02-chapter-practice:jar UP-TO-DATE :02-chapter-practice:assemble UP-TO-DATE :02-chapter-practice:compileTestJava UP-TO-DATE :02-chapter-practice:processTestResources UP-TO-DATE 46 Chapter 2 ■ Spring FundamentalS :02-chapter-practice:testClasses UP-TO-DATE :02-chapter-practice:test com.book.plain.PlainPersonSaveTest > savePerson FAILED java.lang.AssertionError at PlainPersonSaveTest.java:31 .. BUILD FAILED Total time: 4.096 secs If you decided to use the Intellij IDEA editor on the Gradle tab, you already have available all the predefined Gradle tasks and you can just double-click the one you are interested in. In the following image, the selected task is the build task for the project book-code; but if you scroll down in that view, you will see the modules in the project and you can choose to build a specific module. So double-click under the :02-chapter-practice on the build task and execute it. The build will fail, but this is expected. This task will succeed because it does not execute the tests. In Figure 2-8 you can see how your IDE should look. Figure 2-8. Intellij IDEA Gradle run ■ ! to compile projects without failing (due to tests in practice projects that are not fixed yet), you can use the allCompile task, which was created this purpose. 47 Chapter 2 ■ Spring FundamentalS On the left in the Project view, you can see the book-code project and the component modules. Each module has the typical Maven structure mentioned earlier in the chapter (see Figure 2-3). Expand the 02-chapter-practice and look in the com.book.base package. In it you will notice the implementation of the Person class. The instances of this class are used in the test examples and are handled by instances of classes that implement PersonManager. The PersonManager interface defines the int save(Person person) method, which should return the number of records that were affected. In this case, it can be only 1 (one Person instance was saved) or 0 (no Person instance was saved). The PersonRepository interface will be implemented by the repository classes used in this example. Some repositories will actually save Person instances into a test database, but most of them will just print a log message to tell the developer that the method was executed correctly. The code for this chapter was created to show how a Spring application is configured, so more complex functionality is not covered. Classes and methods are commented properly, so using them is very straightforward. Every time a project or module is built with gradle, a directory named build is created containing the detailed results of the build for that project or module. This can be seen in Figure 2-9. Figure 2-9. Intellij IDEA Project view 48 Chapter 2 ■ Spring FundamentalS What is relevant when working with these sources is the reports\\tests\\index.html file. When opened in a browser, it displays all the failing tests in that module. This page can be refreshed during development to track, step by step, the number of tests that have to be fixed. When accessed after the first gradle build, it should display what is depicted in Figure 2-10. Figure 2-10. Gradle-generated index.html There are eight tests failing, and they do so because the implementation for them is incomplete. Completing them has been left as practice for you, the developer reading this book. Click the TODO label in the bottom-left corner. A view will open that should look like what is shown in Figure 2-11. Click and expand everything. Every TODO task has a number attached. Start resolving the tasks in ascending order. 49 Chapter 2 ■ Spring FundamentalS Figure 2-11. Intellij IDEA TODO tab The root package is called com.book. Under this package all packages will group classes with a common purpose. For example, the plain package contains classes that implement the functionality for saving a Person instance by using plain Java—no Spring beans or configuration files, as was shown in the beginning of the “The Spring Core Container” section. As Maven convention requires, the test classes are placed in the same package as the classes being tested, but under the test directory. The first exercise is to complete the plain Java implementation to save a Person instance and make the com.book.plain.PlainPersonSaveTest. After you have written the code, run the test. Just right-click anywhere in the file and choose Run and the class name in the menu, similar to what you see in Figure 2-12. Figure 2-12. Intellij IDEA— running a Gradle test 50 Chapter 2 ■ Spring FundamentalS If the test does not pass, go back and re-read the beginning of this chapter to refresh your memory on how dependency injection is handled in plain Java. After you are done and you have a successful build for 02-chapter-practice, you can compare your solution to the one in 02-chapter-solution. Also, you should take a look at the sources, test sources, and resources under packages aop, noaop, and sandbox. The book.code.spring.noaop package contains classes that implement a transactional bean used to save a Person instance, but opening and committing a transaction are done manually. The book.code.spring.aop package contains classes that implement a transactional bean used to save a Person instance using Spring AOP. Both implementations are tested in a test context that uses a H2 in-memory database to perform the actual save of a Person instance. The configuration of the test database is in the test-db-config.xml file, and you will notice that the Spring jdbc namespace is used. As JPA is not used, you need some *.sql initialization files, which can be found under the test/resources/datasource directory. <jdbc:embedded-database id=\"dataSource\" type=\"H2\"> <jdbc:script location=\"classpath:datasource/db-schema.sql\"/> <jdbc:script location=\"classpath:datasource/db-test-data.sql\"/> </jdbc:embedded-database> The com.book.spring.sandbox contains classes and tests designed to help you understand how bean identification works. When you have passed all the tests and you feel confident that you have a solid grasp of the Spring fundamentals, you can continue to the next chapter. 51 Chapter 3 Spring MVC This chapter was written with the intention of teaching a developer how to create a simple Spring web application and understand how the background plumbing can be modified according to the desired approach. Think of Spring infrastructure components as LEGO pieces. You can connect them in different ways to get the final result: a working web application. After going through this chapter, you should be able identify and use the main components of Spring MVC to create a web application in a few easy steps. Aside from describing and giving examples on how Spring Web MVC works, this chapter also teaches you how to integrate it with different view technologies, like JSP, Apache Tiles, and Thymeleaf.1 MVC Basics Spring Web MVC is a popular request-driven framework based on the model-view-controller software architectural pattern, which was designed to decouple components that by working together make a fully functional user interface. The typical model-view-controller behavior is displayed in Figure 3-1. Figure 3-1. Typical MVC behavior 1Thymeleaf is the new sheriff in Web town. It is an XML/XHTML /HTML5 template engine that works both in web and non-web environments. It is really easy to integrate it with Spring. If you want to read more about it before using it in the practice code for this chapter, go to the official site at http://www.thymeleaf.org/. 53 Chapter 3 ■ Spring MVC The Spring Web MVC provides preconfigured beans for the implementation of this behavior. These beans are contained in two main libraries:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "spring-web.jar\n• spring-webmvc.jar\nThese libraries are the core of all Spring-related modules. At the center of the Spring Web MVC\nframework sits the DispatcherServlet class, which is the entry point for any Spring web application. Before\nany HTTP request reaches the specific controller, it has to go through DispatcherServlet for that controller\nto be identified.2 In a nutshell, the DispatcherServlet coordinates all request-handling operations using\nother infrastructure components defined in Spring and user-defined components. And it acts as a front\ncontroller, an entry point for the web application. The Spring components mentioned earlier can be\ncategorized as follows:\n• Spring MVC infrastructure components\n• handler mappings\n• handler adapters\n• view resolvers\n• personalization beans\n• exception resolvers\n• User-provided web components\n• handler interceptors\n• controllers\nThus, the Spring MVC functional flow can be sketched somewhat like in Figure 3-2.\n2If it looks as if Spring MVC resembles Struts, you are definitely not imagining things. The Spring Web MVC was inspired\nby Struts, which was one of the first MVC-based frameworks. The DispatcherServlet in Spring has the same responsi-\nbilities as the ActionServlet in Struts, as both are implementations of the Front Controller Pattern. You can read more\nabout this software design pattern at http://www.martinfowler.com/eaaCatalog/frontController.html.\n54\nChapter 3 ■ Spring MVC\nFigure 3-2. Spring MVC functional flow\nBriefly put, to configure a Spring web application, you need to do the following:\n• Define the DispatcherServlet as the main servlet handling all requests\nto the application in web.xml and link it to the Spring configuration, or\nconfigure this servlet programmatically by using a class implementing\nWebApplicationInitializer (only possible in a Servlet 3.0+ environment)\n• Define the application configuration (usually in a Spring configuration file named\nmvc-config.xml or a Java configuration class), which should do the following:\n• Define the MVC context used (handler adapter, handler mapping, and other\ninfrastructure beans)\n• Define a view resolver (or more)\nConfiguring MVC\nSpring Web MVC can be configured just like any other Spring application, via XML (using mostly the <mvc/>\nnamespace), Java configuration annotations, or by mixing these. A Spring web application can be configured\nin two ways:\n• All-in-one configuration: web.xml (part of JEE specification) or a\nWebApplicationInitializer implementation and Spring application configuration\nfiles. Back-end and front-end configurations are coupled and the DispatcherServlet\nis the only entry point to the application.\n• Separate configuration: Used for more complex applications when the\nDispatcherServlet is not the only entry point (usually applications that require the\nback end to be accessed via REST or SOAP requests/web services, and in this case,\nthe back end needs a separate listener).\n55\nChapter 3 ■ Spring MVC\nTypical Java web applications that can be built with Gradle have the internal structure consecrated by\nMaven. The folder containing web-specific files, configuration files, and static resources is named webapp.\nThe projects used in this chapter all have this structure (in Intellij IDEA), as shown in Figure 3-3.\nFigure 3-3. Typical Java web application structure with web.xml configuration file\nXML Configuration\nSpring XML configuration for core applications was covered in the previous chapter. But XML namespaces\ncan be used for declaring web-specific infrastructure beans too. There are multiple ways to configure a web\napplication; multiple files can be used for web-specific beans to be grouped together based on their purpose.\nIn this chapter, multiple ways to create a configuration are presented, and after getting familiar with all of them,\nyou will be able to “mix and match” to create configurations for the types of applications that you will develop.\nAll-in-One Configuration\nThis is the simplest way to configure a web application. The Spring configuration files are all referred to in\nthe web.xml file as a value for the contextConfigLocation parameter.\n<servlet>\n<servlet-name>admin</servlet-name>\n<servlet-class>\norg.springframework.web.servlet.DispatcherServlet\n</servlet-class>\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>\n/WEB-INF/spring/mvc-config.xml\n/WEB-INF/spring/app-config.xml\n</param-value>\n</init-param>\n</servlet>\n56\nChapter 3 ■ Spring MVC\n<servlet-mapping>\n<servlet-name>admin</servlet-name>\n<url-pattern>/</url-pattern>\n</servlet-mapping>\nIn the preceding case, the mvc-config.xml contains the Spring configuration for the front-end\n(controllers and MVC infrastructure beans) of the application, and the app-config.xml contains the\nback-end configuration (service beans). In this case, all Spring configuration files are loaded by the\nDispatcherServlet and a web context is created.\nSeparate Configuration\nThe proper way to configure a more complex web application to make it more extensible and flexible is to\ndecouple the front-end configuration the back-end configuration. Such an implementation provides web\nservices access to the back end. This can be done by having a separate listener for the back-end configuration.\nThis complicates the content of web.xml a bit, and the configuration looks similar to the next one:\n<context-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>/WEB-INF/spring/app-config.xml</param-value>\n</context-param>\n<listener>\n<listener-class>\norg.springframework.web.context.ContextLoaderListener\n</listener-class>\n</listener>\n<servlet>\n<servlet-name>admin</servlet-name>\n<servlet-class>\norg.springframework.web.servlet.DispatcherServlet\n</servlet-class>\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>/WEB-INF/spring/mvc-config.xml</param-value>\n</init-param>\n</servlet>\n<servlet-mapping>...</servlet-mapping>\n■ CC When the back-end Spring configuration file is named applicationContext.xml, there is no need to\nspecify the <context-param> element in your configuration. the Spring ioC container accepts the previously\nmentioned file name as a default name for the backed configuration file and it will load it automatically.\n57\nChapter 3 ■ Spring MVC\nThe web.xml file is transformed to this:\n<listener>\n<listener-class>\norg.springframework.web.context.ContextLoaderListener\n</listener-class>\n</listener>\n<!-- The backend configuration file is named applicationContext.xml -->\n<!-- The <context-param> is no longer needed.-->\n<listener>\n<listener-class>\norg.springframework.web.context.ContextLoaderListener\n</listener-class>\n</listener>\n<servlet>\n<servlet-name>mvc-dispatcher</servlet-name>\n<servlet-class>\no.s.web.servlet.DispatcherServlet\n</servlet-class>\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>/WEB-INF/spring/mvc-config.xml</param-value>\n</init-param>\n</servlet>\n<servlet-mapping>...</servlet-mapping>\n■ ! throughout this book, package names may not be presented fully: or.springframework. usually\nbecomes o.s. the reason for this is to fit the configuration and code samples better in the page to make\nthem more readable.\n■ CC if the Spring MVC configuration file is named [servletName]-servlet.xml, there is no need to\nspecify the <init-param> element either. the Spring ioC container accepts the previously mentioned file\nname template (replace servletName with the name given to the servlet) as a default name for the front-end\nconfiguration file and it will load it automatically.\nThe separate configuration can be simplified like this:\n<context-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>/WEB-INF/app-config.xml</param-value>\n</context-param>\n58\nChapter 3 ■ Spring MVC\n<listener>\n<listener-class>\norg.springframework.web.context.ContextLoaderListener\n</listener-class>\n</listener>\n<servlet>\n<servlet-name>mvc-dispatcher</servlet-name>\n<!-- The frontend configuration file is named mvc-dispatcher-servlet.xml -->\n<!-- The <init-param> is no longer needed.-->\n<servlet-class>\no.s.web.servlet.DispatcherServlet\n</servlet-class>\n<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n<servlet-name>mvc-dispatcher</servlet-name>\n<url-pattern>/</url-pattern>\n</servlet-mapping>\nCustomizing the configuration is easy. All rules from Spring core configuration apply. Wildcards are\nsupported. Different resource prefixes can be used. The DispatcherServlet can even be configured to\na different url-pattern. In this case, the requests to the application must contain the value of the\nurl-pattern value, otherwise they won’t be handled by the DispatcherServlet. This approach is suited\nwhen the application uses multiple DispatcherServlet instances.\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>\n/WEB-INF/spring/*-beans.xml\nclasspath:com/book/app-config.xml\n</param-value>\n</init-param>\n...\n<servlet-mapping>\n<servlet-name>admin</servlet-name>\n<url-pattern>/admin/*</url-pattern>\n</servlet-mapping>\nIn the previous example, the DispatcherServlet handles the request with the URL matching\n[server:port]\\[application-name]\\admin\\*.\n■ ! throughout this book and in all code examples, the Spring MVC configuration file is named mvc-config.xml\nto emphasize that only Spring MVC components are defined in it; otherwise, this configuration file can be named\nin any other way. the contents of this file are used for view, locale, and time zone resolution and for customizing\nhandler mappings and other Spring MVC infrastructure beans.\n59\nChapter 3 ■ Spring MVC\nThe controllers can be defined in the mvc-config.xml configuration file using the bean tag element,\njust like any other bean, but starting with Spring 3.0, the preferred way to define controllers is using the\n@Controller annotation, which is why the Spring MVC is often referred to as @MVC.\nThe main component of an MVC XML configuration is the <mvc:annotation-driven/> element\nthat registers all necessary default infrastructure beans for a web application to work: handler mapping,\nvalidation conversion beans, and many others.\nAnother component that is important is the <mvc:default-servlet-handler/>. Usually in Spring\nweb applications the default servlet mapping “/” is mapped to the DispatcherServlet. This means that\nstatic resources have to be served by it too, which might introduce a certain lag in providing a response as\nthe DispatcherServlet has to find the resources that the request URL is mapped to. The <mvc:default-\nservlet-handler/> configures a DefaultServletHttpRequestHandler with a URL mapping of “/*” and the\nlowest priority relative to other URL mappings. Its sole responsibility is to serve static resources.\nYou can see some user-defined beans needed for configuring a Spring MVC application in the following\nexample. Configurations might differ, depending on the types of resources used.\n<!-- Defines basic MVC defaults (handler mapping, date formatting, etc) -->\n<mvc:annotation-driven/>\n<!-- Configures a handler for serving static resources by forwarding to the\nServlet container's default Servlet.-->\n<mvc:default-servlet-handler/>\n<!-- ResourceBundle bean used for internationalization -->\n<bean name=\"messageSource\"\nclass=\"o.s.context.support.ReloadableResourceBundleMessageSource\"\np:basename=\"classpath:messages/global\"/>\n<!-- View resolver bean used to render a *.jsp page -->\n<bean id=\"jspViewResolver\"\nclass=\"o.s.web.servlet.view.InternalResourceViewResolver\">\n<property name=\"prefix\" value=\"/WEB-INF/\"/>\n<property name=\"suffix\" value=\".jsp\"/>\n</bean>\n■ ! Before continuing to the next section, take a look at the module project 03-chapter-01-practice under\nthe book-code project. this is a simple project focusing on the XML-based configuration; it can be used to test\nyour understanding of this section. it uses the minimum number of Spring infrastructure beans required to start\na web application and display a simple JSp page.\nto run a project that is a web application from the command line, execute the gradle appRun task.\nto run a project in intellij iDea, use the appStart task to start the application and appStop to stop the\napplication.\nMake sure to execute the tasks from under the specific module in the gradle task tree. Figure 3-4 can help you\nidentify the task you need to run the application within intellij iDea.\n60\nChapter 3 ■ Spring MVC\nFigure 3-4. Gretty plugin special tasks to start and stop web applications\n2015-03-01 15:48:36.834 WARN - 03-chapter-01-practice runs at:\n2015-03-01 15:48:36.834 WARN - http://localhost:8080/03-chapter-01-practice\nOpen that location in your browser. if you see the page shown in Figure 3-5, the project is working properly.\nrun gradle appStop to stop the server.\nFigure 3-5. Practice Spring MVC application welcome page\nConfiguration Using Annotations\nAn equivalent configuration using Java configuration can be created, but there are a few additional details\nneeded for the configuration class to work properly. The configuration class has to also be annotated\nwith the @EnableWebMvc annotation and has to either implement WebMvcConfigurer or extend an\nimplementation of this interface, for example: WebMvcConfigurerAdapter, which gives the developer the\noption to override only the methods he or she is interested in.\n61\nChapter 3 ■ Spring MVC\nAnnotating a configuration class with @EnableWebMvc has the result of importing the Spring MVC\nconfiguration implemented in the WebMvcConfigurationSupport class; it is equivalent to <mvc:annotation-\ndriven/>. This class registers a lot of Spring infrastructure components that are necessary for a web\napplication (covered later in this chapter).3\nTo tell the DispatcherServlet that the configuration will be provided by a configuration class instead of\na file, the following changes have to be made in web.xml:\n• Define an initialization parameter named contextClass with the full name of the\nSpring class used to create an annotation-based context as the value.\n• The initialization parameter named contextConfigLocation should have the full\nname of the configuration class written by the developer as the value.\n<servlet>\n<servlet-name>admin</servlet-name>\n<servlet-class>\norg.springframework.web.servlet.DispatcherServlet\n</servlet-class>\n<init-param>\n<param-name>contextClass</param-name>\n<param-value>\no.s.web.context.support.AnnotationConfigWebApplicationContext\n</param-value>\n</init-param>\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>\ncom.book.config.WebConfig\n</param-value>\n</init-param>\n</servlet>\nThe configuration class for what was configured with XML in the previous chapter looks like this:\n@Configuration\n@EnableWebMvc // equivalent with <mvc:annotation-driven/>\n@ComponentScan(basePackages = {\"com.book.controllers\"})\n// equivalent with <context:component-scan base-package=\"com.book.controllers\"/>\n//used to scan only web components\npublic class WebConfig extends WebMvcConfigurerAdapter {\n...\n@Bean(name = \"messageSource\")\nMessageSource getMessageSource() {\nReloadableResourceBundleMessageSource\nmessageSource = new ReloadableResourceBundleMessageSource();\n...\nreturn messageSource;\n}\n3If you want, you can look in the API documentation for detail information about this class, which is available at\nhttp://docs.spring.io/spring/docs/current/javadoc- api/.\n62\nChapter 3 ■ Spring MVC\n// <=> <mvc:default-servlet-handler/>\n@Override\npublic void configureDefaultServletHandling(\nDefaultServletHandlerConfigurer configurer) {\nconfigurer.enable();\n}\n@Bean\nInternalResourceViewResolver getViewResolver(){\nInternalResourceViewResolver resolver = new InternalResourceViewResolver();\nresolver.setPrefix(\"/WEB-INF/\");\nresolver.setSuffix(\".jsp\" );\nreturn resolver;\n}\n}\nThe @ComponentScan annotation is the equivalent of <context:component-scan />. It is used to find all\nthe classes annotated with @Controller in the package com.book.controllers.\n■ ! Before continuing to the next section, take a look at the module project 03-chapter-02-practice under\nbook-code. this is a simple project focusing on the Java configuration–based configuration and can be used to\ntest your understanding of this section. it uses the minimum number of Spring infrastructure beans required to\nstart a web application and display a simple JSp page.\nthe gradle running instructions are the same as the instructions for the previous section.\nMixed Configuration\n■ ! there are Spring-specific annotations like @Controller, @Service, @Component, and @Repository,\nwhich can be used to configure a Spring application without the need to use a Java configuration class;\ninstead, an XML file is used, containing context or MVC namespace element definitions. this is called a mixed\nconfiguration, because it uses annotations to define the beans, and XML to define the context.\nIn practice, most common and frequently used Spring configurations imply a combination of XML\nand annotations. The primary reason for this is legacy code, as XML configuration was the first and only\nway to configure a Spring application prior to Spring 2.5. Migration to a more recent version of Spring is\nusually a slow process, and projects remain stuck between worlds for some periods of time. And there are\nalso developers that still prefer XML because it seems easier to separate configurations for the back end,\nfront end, security, web services, and so on, in separate files (although this can just as easily be done with\nJava configuration classes). It is also intuitive and very readable when it comes to dependency injection.\nIt is more practical to have the definition of the relationship between the beans decoupled from the bean\nimplementation. Because it is more practical to implement transaction management using annotations, it is\nvery visible which method is executed in a transaction.\n63\nChapter 3 ■ Spring MVC\nAnnotations should be applied when they provide functionality and/or visibly mark the annotated\nclasses or methods for a specific purpose. Annotations should not tie the code down to some specific\nprocess, so the code should function normally without them. The most obvious case here is the @Controller\nannotated classes for the web side of an application. In the back end, @Repository and @Service\nannotations are used for the same purpose. When looking at the code of a controller class, you see the\nannotation and you can easily infer what the purpose of that class is. All annotation mentioned earlier are\nSpring stereotype annotations, which are used to denote the roles of types in the overall architecture.\nA typical Spring web application configuration uses an mvc-config.xml file to declare the infrastructure\nbeans and @Controller annotated classes.\nConfiguration Without Using web.xml\nStarting with Servlet 3.0+, the web.xml file is no longer needed to configure a web application. It\ncan be replaced with a class implementing the WebApplicationInitializer (or a class extending\nany of the Spring classes that extend this interface). This class is detected automatically by\nSpringServletContainerInitializer (an internal Spring supported class, which is not meant to be used\ndirectly or extended). The SpringServletContainerInitializer class is bootstrapped automatically by any\nServlet 3.0+ container.\nThe SpringServletContainerInitializer4 extends javax.servlet.ServletContainerInitializer\nand provides a Spring-specific implementation for the onStartup method. This class is loaded and\ninstantiated, and the onStartup is invoked by any Servlet 3.0–compliant container during container startup,\nassuming that the Spring-web module JAR is present on the classpath.\nConsidering you have a web.xml file that looks like this:\n<servlet>\n<servlet-name>admin</servlet-name>\n<servlet-class>o.s.w.s.DispatcherServlet</servlet-class>\n<init-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>\n/WEB-INF/spring/mvc-config.xml\n</param-value>\n</init-param>\n<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n<servlet-name>admin</servlet-name>\n<url-pattern>/</url-pattern>\n</servlet-mapping>\n4The code for this class is at https://github.com/spring-projects/spring-framework/blob/master/spring-\nweb/src/main/java/org/springframework/web/ SpringServletContainerInitializer.java.\n64\nChapter 3 ■ Spring MVC\nThe most obvious way to implement WebApplicationInitializer is this:\npublic class WebInitializer implements WebApplicationInitializer {\n@Override\npublic void onStartup(ServletContext servletContext) throws ServletException {\nServletRegistration.Dynamic registration =\nservletContext.addServlet(\"dispatcher\", new DispatcherServlet());\nregistration.setLoadOnStartup(1);\nregistration.addMapping(\"/\");\nregistration.setInitParameter(\"contextConfigLocation\",\n\"/WEB-INF/spring/mvc-config.xml\");\n}\n}\nThe class does not need to be annotated or linked to any other configuration file existing in the\napplication. You can easily notice which lines from XML turned into which lines in the code, right?",
    "answer": "But there is another way, which involves constructing the application context first and then injecting it into the DispatcherServlet: XmlWebApplicationContext appContext = new XmlWebApplicationContext(); appContext.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(appContext)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); And there is an even simpler way—by extending AbstractDispatcherServletInitializer, an abstract implementation of the WebApplicationInitializer: public class WebInitializer extends AbstractDispatcherServletInitializer { @Override protected WebApplicationContext createRootApplicationContext() { //there is no root application context for the web application context to inherit return null; } @Override protected WebApplicationContext createServletApplicationContext() { XmlWebApplicationContext cxt = new XmlWebApplicationContext(); cxt.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); return cxt; } @Override protected String getServletMappings() { return new String { \"/\" }; } } 65 Chapter 3 ■ Spring MVC Java-based annotation configurations are supported too—in multiple ways. Consider that you have a WebConfig class and a web.xml that looks like this: <servlet> <servlet-name>admin</servlet-name> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextClass</param-name> <param-value> o.s.web.context.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> This is the most obvious way to implement WebApplicationInitializer’s onStartup() method: ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); registration.setInitParameter(\"contextConfigLocation\", \"com.book.config.WebConfig\"); registration.setInitParameter(\"contextClass\", \"o.s.w.c.s.AnnotationConfigWebApplicationContext\"); But wait, there’s more! You can create the application context and inject it into the DispatcherServlet as you did before: AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(WebConfig.class); ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(context)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); 66 Chapter 3 ■ Spring MVC And the easiest way to do it is with AbstractAnnotationConfigDispatcherServletInitializer, which extends AbstractDispatcherServletInitializer, an abstract implementation of the WebApplicationInitializer. Spring provides them to help you eliminate some of the code writing. By extending the AbstractAnnotationConfigDispatcherServletInitializer template and using customization methods offered by the AbstractDispatcherServletInitializer, the developer is only required to provide concrete implementations for three methods: getRootConfigClasses, getServletConfigClasses, and getServletMappings. public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?> getRootConfigClasses() { //there is no root application context for the web application context to inherit return null; } @Override protected Class<?> getServletConfigClasses() { return new Class { WebConfig.class }; } @Override protected String getServletMappings() { return new String { \"/\" }; } } ■ ! Before continuing with this chapter, take a look at the 03-chapter-03-practice and 03-chapter-04- practice and try to make the projects run. the first requires you to configure a Spring web application using a Spring XML–based configuration and without a web.xml file. the second requires you to configure a Spring web application using a Java-based configuration and without a web.xml file. Be creative, read the Spring api if necessary, and then you can even compare your solution to the ones provided in the solution projects. the gradle running instructions are the same as in the previous section. MVC Components The configuration of a Spring web application integrates quite a few infrastructure beans. The DispatcherServlet looks for implementations of type: HandlerMapping, HandlerAdapter, ViewResolver, and HandlerExceptionResolver. Out-of-the-box implementations for the previously mentioned interfaces are provided by Spring. The default configuration can be found in the DispatcherServlet.properties, which is in the spring-webmvc.jar in package org.springframework.web.servlet.5 5The contents can be accessed directly on GitHub at https://github.com/spring-projects/ spring-framework/ blob/master/spring-webmvc/src/main/resources/org/springframework/web/ servlet/DispatcherServlet. properties. 67 Chapter 3 ■ Spring MVC ■ ! You can find the jar in your local maven repository. it is recommended to open the file and study it, because in the exam you might be asked about the default components configured in Spring for some MVC bean types. Some of them are deprecated in the current api—DefaultAnnotationHandlerMapping, for example—and the file will suffer some changes in future versions. The infrastructure beans mentioned earlier can be configured manually, but this is rarely done and is recommended to be avoided, as the explicit configuration cancels the default configuration for that bean type. In Spring 4.0, <mvc:annotation-driven/> and the equivalent @EnableWebMvc do just that—override the default configuration to provide the new features, so you don’t have to struggle with the configuration yourself. A Spring web application can use more than one infrastructure bean of a specific type. In this case, the beans can be chained and have an associated priority value specified using the order property. For example, you can have multiple HandlerMapping implementations: <bean class=\"o.s.web.servlet.handler.SimpleUrlHandlerMapping\"> <property name=\"order\" value=\"0\"/> </bean> <bean class= \"o.s.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"> <property name=\"order\" value=\"1\"/> </bean> When <mvc:annotation-driven/> or @EnableWebMVC is used in the application configuration, the RequestMappingHandlerMapping implementation is registered internally with Spring MVC. This class was added in Spring 3.1; it allows RequestMappings for the same URL to be in different controller classes. It is meant to replace the DefaultAnnotationHandlerMapping implementation. It was introduced to make the annotation controller support class more customizable and open for extension. When using the RequestMappingHandlerMapping, the actual handler is an instance of HandlerMethod, which identifies the specific controller method that will be invoked. Starting with Spring version 4.0, the DefaultAnnotationHandlerMapping was marked as deprecated. The following sections cover each of the infrastructure bean types in detail. Infrastructure Beans Spring MVC offers developers a lot of support when it comes to building the plumbing of a web application, so developers can focus on implementing the actual service a web application is expected to provide. The beans provided by Spring MVC are often called infrastructure beans, which have default configurations that work out of the box. Each of these infrastructure beans are presented in detail in the following sections. HandlerMapping This HandlerMapping Spring interface is implemented by classes that map parts of URL for the incoming requests to the appropriate handlers and a list of pre- and post-processor interceptors (AOP is used for this). Prior to Spring 3.1, it was necessary to specify one or more HandlerMapping beans in the application context, but after the introduction of annotated controllers, there is no need to do so. All HandlerMapping implementations are used by the DispatcherServlet to identify the handler (controller class) of a request. 68 Chapter 3 ■ Spring MVC In the DispatcherServlet.properties, you find the following default HandlerMapping implementations configured: org.springframework.web.servlet.HandlerMapping= org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping The BeanNameUrlHandlerMapping class maps URLs to beans with names that start with “/”. So a request incoming with URL http://localhost:8080/persons maps to bean: @Controller(\"/persons\") public class PersonsController { ... } ■ ! the DefaultAnnotationHandlerMapping is deprecated in Spring 4.0 as it was replaced by RequestMappingHandlerMapping. The RequestMappingHandlerMapping class maps URLs to classes annotated with @RequestMapping. So a request coming from URL http://localhost:8080/persons/list is handled by the following controller: @RequestMapping(\"/persons\") @Controller public class PersonsController { @RequestMapping(value=\"/list\") public void list(Model model){ ... } } In the preceding example, the @RequestMapping at method level is used to narrow the mapping expressed at class level, if one is present. The annotation is not really necessary at method level when it is present at class level, because narrowing can be done using other criteria too; for example, the request method type. @RequestMapping(\"/persons\") @Controller public class PersonsController { //End user requests to see data for a certain person. @RequestMapping(method = RequestMethod.GET) public void getPerson(Model model){ ... } //End user sends data to save for a certain person. @RequestMapping(method = RequestMethod.POST) public void savePerson(Person person, Model model){ ... } } 69 Chapter 3 ■ Spring MVC It is mandatory for any HTTP request path to be uniquely mapped onto a specific handler. It is recommended to keep all related handler methods in the same bean, and not span them across multiple handler beans in order to improve code readability. Another implementation worth mentioning is ControllerClassNameHandlerMapping, which was introduced in the spirit of convention over configuration. This implementation offers the possibility to generate URL path mappings from the class names and method names of registered or annotated controller beans. The convention is to take the short name of the class, remove the Controller suffix, lower case the first letter of the remaining text, prefix it with “/”, and then add the method name used to handle the request. Using this implementation, the PersonsController mentioned earlier is mapped to \"/persons*\" and the @RequestMapping(\"/persons\") annotation is no longer needed. In the book-code project, there is a sample module named 03-chapter-05-solution, which contains a simple controller with the following implementation. @Controller public class WelcomeController { @RequestMapping //maps to /welcome/sayhi public String sayhi(Model model){ model.addAttribute(\"salute\", \"Hi!\"); return \"welcome\"; } @RequestMapping //maps to /welcome/sayhello public String sayhello(Model model){ model.addAttribute(\"salute\", \"Hello!\"); return \"welcome\"; } } In order for a request to be solved correctly using the ControllerClassNameHandlerMapping, a HandlerAdapter implementation needs to be configured. AnnotationMethodHandlerAdapter will do, even if it is deprecated in Spring 4.0. ... <context:component-scan base-package=\"com.book\"/> <bean class=\"o.s.web.servlet.mvc.support.ControllerClassNameHandlerMapping\" p:caseSensitive=\"true\"/> <bean id=\"annotationMethodHandlerAdapter\" class=\"o.s.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\" /> ... 70 Chapter 3 ■ Spring MVC ■ ! an example of how to configure the ControllerClassNameHandlerMapping bean and how it works is implemented in the 03-chapter-05-solution module in the book-code project. this project does not have a practice project associated with it because there is no need for one. the gretty plugin is quite flexible and can be configured to start a web application on a different context or port. When working locally, the UrL of the application looks like this: http://localhost:8080/03-chapter-05- solution. the context is the string after the port, and gretty automatically takes the name of the project and uses it as context for the web application, if not configured to do otherwise. also, the default port is 8080, which is the default port used by most of application servers for web applications.6 As the name of the modules in book-code are quite long, Gretty was configured to use a different context, which can also emphasize the purpose of the application. gretty { port = 8080 contextPath = '/mvc-handling' } HandlerAdapter The HandlerAdapter interface is internal and is not intended for application developers. It must be implemented by each handler to be able to handle a request. The DispatcherServlet uses this interface to invoke handler methods because the interface is taking care of solving various annotations inside a controller class and identifies which method should be called. In the DispatcherServlet.properties you find the following default HandlerAdapter implementations: org.springframework.web.servlet.HandlerAdapter= org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter These are the out-of-the-box defaults if <mvc:annotation-driven/> is not specified. When <mvc:annotation-driven/> or @EnableWebMVC is used in the application configuration, RequestMappingHandlerAdapter is used. Introduced in Spring 3.1, the scope of this class is to work with RequestMappingHandlerMapping to make this class the only place where a decision is made about which method should handle a request. This actually means that every handler method is a unique endpoint that can be identified from class and method-level RequestMapping information. Prior to Spring 3.1, identifying and calling a handler method involved two steps: identifying a controller (handler) using a HandlerMapping implementation and identifying the method (handler method) using a HandlerAdapter implementation. Starting with Spring 3.1, everything is done in one step, with the two classes working together. So Figure 3-2 is not an accurate representation for Spring >=3.1; when using <mvc:annotation-driven/> or @EnableWebMVC, Figure 3-6 is more accurate. 6The full list of configuration options for Gretty can be found at http://akhikhl.github.io/gretty-doc/Gretty- configuration.html. 71 Chapter 3 ■ Spring MVC Figure 3-6. @MVC Spring >= 3.1 The old implementations were kept in the Spring MVC library, but it is recommended to use the ones introduced in Spring 3.1 and enabled by the MVC namespace or @EnableWebMVC because these ensure a simpler configuration and faster identification of a handler method, and take advantage of other new features introduced in Spring 3.1. Here is a list of some of the changes introduced by this approach:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "It is no longer possible to use SimpleUrlHandlerMapping or\nBeanNameUrlHandlerMapping to identify a controller and then identify the handler\nmethod by narrowing the method choice with @RequestMapping.\n• It is no longer possible to have a single method without explicit mapping to solve all\nrequests mapped to a controller. The new support classes will throw a Not Found\n404 error.\n• HandlerInterceptor and HandlerExceptionResolver (covered later in the chapter)\ncan now expect the object-based handler to be a HandlerMethod. They can examine\nits parameters and annotations.\n• Custom argument and return types are supported for handler methods.\n• @PathVariable annotated parameters (covered later in the chapter) are\nautomatically added to the model, so it’s not necessary to manually add them if you\nare providing them as part of forwarding or redirecting.\n72\nChapter 3 ■ Spring MVC\n• Supports parameterized URI template on redirect strings.\n• RequestMappings now support consumes/produces, so it’s not necessary to specify h\neaders=\"ContentType=application/json\". This is a little closer to the JAX-RS style\nof specifying @Consumes/@Produces annotations. This helps in producing the correct\nerror code if unsupported media types are referenced on REST requests.\nThe preceding list is not complete. If you want a full read of all the advantages of using the new handler\nsupport classes, you can find it in the official documentation.7 Some are also mentioned in the following\nsections; those are the ones you should focus on for the exam.\nWhen the web application starts, if the logger of the application is configured properly, you should\nbe able to see all the beans used in the application, including the infrastructure beans. The following is\na snippet from a debug log printed when 02-pr-mvc-basic-solution starts. Run the project yourself to\nanalyze the console output in more detail.\nINFO Initializing Spring FrameworkServlet 'mvc-dispatcher'\n...\nDEBUG o.s.b.f.s.DefaultListableBeanFactory - Pre-instantiating singletons ...,\naccountRepo,hospitalRepo,personManager,identityCardRepo,transactionManager,\nentityManagerFactory, ..., o.s.w.s.m.m.a.RequestMappingHandlerMapping#0,\n... ,o.s.w.s.m.m.a.RequestMappingHandlerAdapter#0,\no.s.w.s.m.m.a.ExceptionHandlerExceptionResolver#0,...,\norg.springframework.web.servlet.view.InternalResourceViewResolver,\n,messageSource,localeResolver,themeResolver,\n...\nViewResolver\nThe HTTP response returned to the client after the execution of a handler method is constructed using\na model and a view. The model contains the data that is used to populate a view. Spring provides view\nresolvers to avoid ties to a specific view technology. Out of the box, Spring supports JSP, Velocity templates,\nand XSLT views. The interfaces needed to make this possible are ViewResolver and View. The first provides\na mapping between view names and actual views. The second takes care of preparing the request and\nforwards it to a view technology.8\n7http://docs.spring.io/spring/docs/current/spring- framework-reference/htmlsingle/#mvc-ann-\nrequestmapping-31-vs-30, http://docs.spring.io/spring/docs/current/spring- framework-reference/\nhtmlsingle/#mvc-config-enable.\n8http://docs.spring.io/spring/docs/4.1.x/spring- framework-reference/htmlsingle/#mvc-viewresolver.\n73\nChapter 3 ■ Spring MVC\nAll handler methods must resolve to a logical view name that corresponds to a file, either explicitly by\nreturning a String, View, or ModelAndView instance or implicitly based on internal conventions. The core\nview resolver provided by Spring is the InternalResourceViewResolver, which is the default view resolver,\nas you can see in the DispatcherServlet.properties file:\norg.springframework.web.servlet.ViewResolver=\norg.springframework.web.servlet.view.InternalResourceViewResolver\nView Resolver Chaining\nA web application can have more than one ViewResolver configured and the DispatcherServlet\ndiscovers them by type. In this case, the default view resolver configuration is overridden, meaning the\nInternalResourceViewResolver is not the default resolver anymore, so if this bean is needed, it has to be\nconfigured explicitly. In this case, the available view resolvers can and should be chained to have a fixed\nsequence of resolvers trying to obtain a view. The next example shows how two view resolvers can be\nchained together to resolve JSP and Excel views:\n<!-- in mvc-config.xml -->\n<bean name=\"persons/list.xls\" class=\"com.book.persons.PersonsExcelView\"/>\n<bean\nid=\"xlsViewResolver\"\nclass=\"...web.servlet.view.BeanNameViewResolver\"\np:order=\"0\"/>\n<bean\nclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\np:order=\"1\" />\n■ ! Defining bean properties using the p: ... syntax is possible by using the p namespace that offers a way\nto contract bean definitions in XML configuration files to reduce their size and make them more readable.9\nChaining view resolvers is also possible using a Java configuration class:\n\\\\ in @Configuration annotated class\n@Bean(name=\"persons/list.xls\")\npublic View excelView(){\nreturn new PersonsExcelView();\n}\n@Bean(name=\"xlsViewResolver\")\npublic ViewResolver xlsViewResolver(){\nBeanNameViewResolver resolver = new BeanNameViewResolver();\n9You can read more about it in the official documentation at http://docs.spring.io/spring/docs/current/\nspring-framework-reference/html/beans.html#beans- p-namespace.\n74\nChapter 3 ■ Spring MVC\nresolver.setOrder(0);\nreturn resolver;\n}\n@Bean\npublic ViewResolver jspViewResolver() {\nInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n...\nresolver.setOrder(1);\nreturn resolver;\n}\nWhen a view resolver does not result in a view (usually null is returned, but there are view resolvers that\nthrow exceptions), Spring examines the application context for other view resolver beans and inspects each\nof them until a view is obtained. If this is not possible, a ServletException is returned. When resolver beans\nare chained, the inspection is done based on the value of their order property; the lower the value of the\nproperty, the higher the priority when resolving view names.\n■ ! the InternalResourceViewResolver resolves the view no matter what view name is returned. it throws\nan exception if it cannot resolve a view name, so this bean always has to be placed last in the chain; otherwise,\nSpring skips looking for other view resolver beans in the context. XSLt and JSOn are also resolvers that must\nbe last in the chain. tiles, Velocity, and FreeMarker can appear anywhere in the chain.\nIn the case just presented, if the BeanNameViewResolver does not return a view (a request method has\nreturned a logical view name different than \"persons/list.xls\"), the next resolver is called to do that.\nThe InternalResourceViewResolver is the most important implementation provided by Spring. It is\na specialization of UrlBasedViewResolver (so they cannot be used together in a configuration, chained or\nnot) and inherits the behavior of interpreting view names as a URL, supports the \"redirect:\" prefix and the\n\"forward:\" prefix. And supports InternalResourceView(Servlets and JSPs) and JstlView.\n■ ! the \"redirect:\" and \"forward:\" prefixes are appended to the logical view name to tell the servlet\ncontainer what to do.\nWith \"forward:\", the servlet container just forwards the same request to the target UrL, and the browser is not\ninvolved and does not know the UrL has changed. a forward should be used for safe operations when reloading\nthe page won’t result in corrupt data (usually for requesting data to display in the page).\nWith \"redirect:\", the response status is set to 302 and the UrL to redirect to is set in a Location header,\nthen the response is sent to the browser. the browser then makes another request to the new UrL. redirect is\na two-step operation; it is recommended to be used when the first request is a data manipulation request, and\nthe browser must then be redirected to a confirmation page to prevent data duplication.\nThe “redirect:” prefix can be returned together with a view name to delegate the creation of the\nresponse to another handler. The most suitable for such behavior is when a POST request was received and\nthe possibility to resubmit the same form data has to be eliminated. The browser sends an initial POST,\nreceives a response to redirect to a different URL, and then performs a GET request for the URL received as a\n75\nChapter 3 ■ Spring MVC\nresponse. This sequence of actions matches a web development design pattern named Post-Redirect-Get\nthat prevents duplicate form submissions. In Figure 3-7, the Post- Redirect-Get process is displayed using\nthe PersonsController.\nFigure 3-7. Post-Redirect-Get in Spring using the \"redirect:\" prefix compared to \"forward:\"\n\"redirect:\" and \"forward:\" are recognized by the UrlBasedViewResolver and all its subclasses. They\ntreat them accordingly and consider the view name after the prefix as the redirect/forward URL.\n■ ! You will have the occasion to work with \"redirect:\" and \"forward:\" in the 05-pr-mvc-form-practice\nproject.\nAll view file templates are stored under /WEB-INF for security reasons. They cannot be accessed directly\nvia a manually introduced URL and they require a model in order to be rendered. The previously mentioned\nview implementations supported by InternalResourceViewResolver have the following characteristics:\n• InternalResourceView exposes the model attributes as request attributes and\nforwards the request to the specified resource URL using a RequestDispatcher.\n• JstlView is a specialization of InternalResourceView that exposes request\nattributes specifying the locale and the resource bundle for JSTL’s formatting and\nmessage tags, using Spring’s locale and MessageSource ( the JSTL library is required\nin the classpath for this View technology to be available).\n76\nChapter 3 ■ Spring MVC\nMore about this topic is covered later in this chapter.\nThis is an example of how a view is resolved using the chained resolvers configured earlier:\n/* 1 */\n@RequestMapping(\"/persons.htm\")\npublic String listHtml(HttpServletRequest rq, Model model) {\nmodel.addAttribute(personManager.getAllPersons());\nreturn \"accounts/list\";\n}\n/* 2. */\n@RequestMapping(\"/persons.xls\")\npublic String listExcel(HttpServletRequest rq, Model model) {\nmodel.addAttribute(personManager.getAllPersons());\nreturn \"persons/list.xls\";\n}\nThe first method has InternalResourceViewResolver resolve the view, and the second is taken care of\nby BeanNameViewResolver and a PersonsExcelView is rendered.\nAs you can see, the implementation for the two methods is almost identical. The URL and the logical\nview name returned are different, however. And there’s a programming principle called Don’t Repeat\nYourself! that those two methods do not respect. Let’s try and respect that principle by merging the two\nmethods into one:\n/* 1 */\n@RequestMapping(\"/persons\")\npublic String list(HttpServletRequest rq, Model model) {\nmodel.addAttribute(personManager.getAllPersons());\nif (rq.getRequestURL().toString().endsWith(\"xls\")) {\nreturn \"persons/list.xls\";\n} else {\nreturn \"persons/list\";\n}\n}\nBut this is not an acceptable solution either. What if the application is requested to support PDF views\ntoo?",
    "answer": "That means more if-else instructions have to be added. Right now you are probably telling yourself: “There’s gotta be a better way of doing this!” And there is. Worry not, this shall be covered in the next section. ■ ! take a look at the 03-chapter-06-solution project. it has been set up to work with the chained resolver configuration mentioned in this chapter. the data can be viewed in a web page, an excel document or a pDF. run it and take a look at the implementation before moving on to the next section. 77 Chapter 3 ■ Spring MVC Content Type Negotiation Another way of organizing the view resolver beans and making sure that the view name is always resolved correctly is to use content-type negotiation. The previous approach, resolver chaining, works only when each resource is associated with one view type. But clients might request different content- types for the same resource via extension, request header, request parameter, and so forth. In this case, chaining won’t work, as the type of view returned depends on some parameters that have to be taken into consideration and then a matching view resolver must be selected to do the job. The bean that does that is the ContentNegotiatingViewResolver, which was introduced in Spring 3.0. This bean does not resolve views but delegates the job to the view resolver implementations defined in the application configuration, selecting the view matching the content-type in the client request. There are two strategies for a client to request a view from the server:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Use a distinct URL for each resource by using a different extension in the URL\n(example: http://localhost:8080/persons/list.xls requests an Excel view\ncontaining a list of persons, while http://localhost:8080/persons/list.pdf\nrequests a PDF view containing a list of persons)\n• Use the same URL but set the Accept HTTP request header to the desired resource\ntype (example: a request coming from http://localhost:8080/persons/list\nhaving the Accept header set to application/pdf requests a PDF view containing a\nlist of persons)\n■ ! the problem with the Accept header is that it cannot be used when the client is a browser, as most\nbrowsers force its value to text/html. Because of this, web applications are always built to use the first\napproach and each view type is mapped to its own UrL (taking the extension into consideration; for example:\n/persons/list.html, /persons/list.xls). the Accept header approach is most useful for reSt web services and\nsimilar automation scenarios.\nThe ContentNegotiatingViewResolver implements the Ordered interface, so it can be used alongside\nother resolvers, it can be part of a view resolver chain, and it has to have the highest priority in the chain.\nThis is due to its behavior; if theContentNegotiatingViewResolver cannot select a View, it returns null,\nand Spring examines the application context for other view resolver beans and inspects each of them until\na view is obtained. Usually the ContentNegotiatingViewResolver is configured to pick up view resolvers\nautomatically from the application context, so it should always resolve to a View. The next resolvers in the\nchain can be considered a fallback solution, to make sure that a View is provided.\nThe ContentNegotiatingViewResolver can be configured in a similar way, as shown in the following\nexample:\n<bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\"\np:order=\"-1\">\n<property name=\"mediaTypes\">\n<map>\n<entry key=\"html\" value=\"text/html\"/>\n<entry key=\"xls\" value=\"application/vnd.ms-excel\"/>\n<entry key=\"pdf\" value=\"application/pdf\"/>\n<entry key=\"json\" value=\"application/json\"/>\n</map>\n</property>\n78\nChapter 3 ■ Spring MVC\n<property name=\"viewResolvers\">\n<list>\n<bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/>\n<bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\" />\n<bean class=\"com.book.resolver.JsonViewResolver\"/>\n</list>\n</property>\n<property name=\"defaultViews\">\n<list>\n<bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" />\n</list>\n</property>\n<property name=\"defaultContentType\" value=\"text/html\"/>\n<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n<property name=\"favorParameter\" value=\"false\"/>\n<property name=\"favorPathExtension\" value=\"true\"/>\n</bean>\n<!-- Fallback Resolver: If no extension matched, use JSP view -->\n<!-- Resolves view names to protected .jsp resources within the\n/WEB-INF directory -->\n<bean class=\"o.s.web.servlet.view.InternalResourceViewResolver\"\np:prefix=\"/WEB-INF/\"\np:suffix=\".jsp\"\np:order=\"0\"/>\nHere is the meaning of each property used in the previous configuration:\n• mediaTypes: Map containing extension to content-type correspondences. This\nproperty is not mandatory and it does not have to be set in the application when the\nJavaBeans Activation Framework is used, in which case the types are determined\nautomatically.10\n• viewResolvers: The list of view resolvers to delegate to. This property is not\nmandatory and when it is not set, all view resolver beans in the context are detected\nand used, but they have to be ordered.\n• defaultViews: The default view to use when a more specific view could not be\nobtained.\nThe property is not mandatory.\n• defaultContentType: The type to render in case a match was not found. The\nproperty is not mandatory.\n• ignoreAcceptHeader: Indicates that the HTTP Accept header should be ignored if\ntrue, and taken into consideration if false. The property is not mandatory, and\nif not set, it defaults to false.\n10By default, strategies for checking the extension of the request path and the Accept header are registered. The path\nextension check performs lookups through the ServletContext and the JavaBeans Activation Framework (if present)\nunless media types are configured. In order to use the JavaBeans Activation Framework, the activation.jar has to be\nin the classpath of the application.\n79\nChapter 3 ■ Spring MVC\n• favorParameter: Indicates if a request parameter named format should be used to\ndetermine the requested content-type. The property is not mandatory, and if not set,\nit defaults to false.\n• favorPathExtension: Indicates if the extension of the request URL should be used to\ndetermine the requested content-type. The property is not mandatory, and if not set,\nit defaults to true.\nStarting with Spring 3.2, ContentNegotiationManagerFactoryBean and ContentNegotiationManager\nwere introduced in order to encapsulate all content-type related configurations for the\nContentNegotiatingViewResolver.\nContentNegotiationManagerFactoryBean provides access to a ContentNegotiationManager\nconfigured with one or more ContentNegotiationStrategy. An equivalent configuration to the preceding,\nafter Spring 3.2, looks like this:\n<bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\">\n<property name=\"viewResolvers\">\n<list>\n<bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/>\n<bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\"/>\n<bean class=\"com.book.resolver.JsonViewResolver\"/>\n</list>\n</property>\n<property name=\"defaultViews\">\n<list>\n<bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" />\n</list>\n</property>\n<!-- All content-type related configuration is now done by this bean\nsince Spring 3.2 -->\n<property name=\"contentNegotiationManager\">\n<bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean>\n<property name=\"mediaTypes\">\n<map>\n<entry key=\"html\" value=\"text/html\"/>\n<entry key=\"json\" value=\"application/json\"/>\n<entry key=\"pdf\" value=\"application/pdf\"/>\n<entry key=\"xls\" value=\"application/vnd.ms-excel\"/>\n</map>\n</property>\n<property name=\"defaultContentType\" value=\"text/html\"/>\n<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n<property name=\"favorParameter\" value=\"false\"/>\n<property name=\"favorPathExtension\" value=\"true\"/>\n</bean>\n</property>\n80\nChapter 3 ■ Spring MVC\n■ ! the problem with using JavaBeans activation Framework is that if the extension is not recognized, it sets\nthe content-type to application/octet-stream by default. this means that the Views configured with the\ndefaultViews property are not taken into consideration and the ContentNegotiatingViewResolver will return\nnull. that’s why in Spring 3.2, the useJaf property was introduced; it can be set to false to disable the JavaBeans\nactivation Framework. this property has been added to ContentNegotiationManagerFactoryBean too.\nConsidering the previous configuration, the following code displays how a view is resolved using\ncontent negotiation type:\n// In PersonsController.java\n@RequestMapping(\"/persons\")\npublic String list(Model model) {\nmodel.addAttribute(personManager.getAllPersons());\nreturn \"persons/list\";\n}\n<!-- In mvc-config-->\n<bean class=\"com.book.persons.PersonsExcelView\"/>\nAs you can see, there is no need for the bean name to be persons/list.xls, because the\nContentNegotiatingViewResolver does the match without it.\n■ ! in the following XML configuration, the util namespace is introduced to simplify the configuration. the\nutil namespaces allows you to define and use collections in the same way that beans are defined and used in\na configuration file.\nThis configuration can be simplified by using the p and util namespaces, which allow the\nContentNegotiatingViewResolver XML bean definition to be simplified, as follows:\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:mvc=\"http://www.springframework.org/schema/mvc\"\nxmlns:p=\"http://www.springframework.org/schema/p\"\nxmlns:util=\"http://www.springframework.org/schema/util\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/mvc\nhttp://www.springframework.org/schema/mvc/spring-mvc.xsd\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\nhttp://www.springframework.org/schema/util\nhttp://www.springframework.org/schema/util/spring-util.xsd\">\n...\n81\nChapter 3 ■ Spring MVC\n<!-- sample usage of the util namespace to declare a map -->\n<util:map id=\"mediaTypesMap\">\n<entry key=\"html\" value=\"text/html\"/>\n<entry key=\"xls\" value=\"application/vnd.ms-excel\"/>\n<entry key=\"pdf\" value=\"application/pdf\"/>\n<entry key=\"json\" value=\"application/json\"/>\n</util:map>\n<!-- sample usage of the util namespace to declare a list -->\n<util:list id=\"defaultViewsList\">\n<!-- Excel view-->\n<bean class=\"com.pr.views.PersonsExcelView\"/>\n<!-- JSON View -->\n<bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\"/>\n</util:list>\n<util:list id=\"resolverList\">\n<bean class=\"com.pr.resolver.JsonViewResolver\"/>\n<bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/>\n<!-- Resolves logical view names to Tiles 3 definitions -->\n<bean id=\"tilesViewResolver\"\nclass=\"o.s.web.servlet.view.tiles3.TilesViewResolver\"\np:requestContextAttribute=\"requestContext\"/>\n</util:list>\n<bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\"\np:order=\"-1\"\np:defaultViews-ref=\"defaultViewsList\"\np:viewResolvers-ref=\"resolverList\">\n<property name=\"contentNegotiationManager\">\n<bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean\"\np:defaultContentType=\"text/html\"\np:ignoreAcceptHeader=\"true\"\np:favorParameter=\"false\"\np:favorPathExtension=\"true\"\np:mediaTypes-ref=\"mediaTypesMap\"/>\n</property>\n</bean>\n<beans>\nOf course, this means taking out the defaultViewsList and the mediaTypesMap outside the declaration\nof the ContentNegotiatingViewResolver, which is the only place that they are needed. In this configuration,\nthey can be used by other beans, although this is rarely needed. The choice belongs to the developer,\ndepending on what configuration approach he is most comfortable with.\n■ ! When the p namespace is used, the p:[property-name]-ref means this property is a reference to an\nexisting bean in the context, with the id specified as the value.\n82\nChapter 3 ■ Spring MVC\nThat’s mostly it when it comes to content-type negotiation. What is left to add is some sample code for\nthe Java configuration:\n@Configuration\n@EnableWebMvc\npublic class WebConfig extends WebMvcConfigurerAdapter {\n// Configures the contentNegotiationManager bean\n@Override\npublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\nconfigurer\n.ignoreAcceptHeader(true)\n.defaultContentType(MediaType.TEXT_HTML)\n.favorParameter(false)\n.favorPathExtension(true);\n}\n//Configure ContentNegotiatingViewResolver\n@Bean\npublic ViewResolver contentNegotiatingViewResolver\n(ContentNegotiationManager manager) {\nContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();\nresolver.setContentNegotiationManager(manager);\n// Define all possible view resolvers\nList<ViewResolver> resolvers = new ArrayList<>();\nresolvers.add(beanNameViewResolver());\nresolvers.add(tilesViewResolver());\nresolvers.add(jsonViewResolver());\nresolver.setViewResolvers(resolvers);\nList<View> defaultViewList = new ArrayList<>();\ndefaultViewList.add(jsonView);\nresolver.setDefaultViews(defaultViewList);\nresolver.setOrder(0);\nreturn resolver;\n}\n@Bean\npublic ViewResolver jsonViewResolver() {\nreturn new JsonViewResolver();\n}\n@Bean\npublic MappingJackson2JsonView jsonView(){\nreturn new MappingJackson2JsonView();\n}\n83\nChapter 3 ■ Spring MVC\n@Bean\nInternalResourceViewResolver getViewResolver(){\nInternalResourceViewResolver resolver = new InternalResourceViewResolver();\nresolver.setPrefix(\"/WEB-INF/\");\nresolver.setSuffix(\".jsp\" );\nresolver.setOrder(1);\nreturn resolver;\n}\n// other bean definitions ...\n}\nIn the Java-annotated configuration there is no need to create a ContentNegotiationManager using the\nContentNegotiationManagerFactoryBean. Spring does it automatically if you provide a configuration for it\nby overriding the implementation for the configureContentNegotiation method.\nJSON View Resolver\nIn this section, in the code samples, the MappingJackson2JsonView is an example of a default View.\nThis is a Spring MVC View implementation that renders JSON content by serializing the model for the\ncurrent request using the Jackson 2.x ObjectMapper. By default, everything serializable (classes that\nimplement the Serializable interface) in a model map is being serialized, except for framework-specific\nclasses and classes or fields annotated with @JsonIgnore. The configuration for the view is provided by\nJackson2ObjectMapperBuilder.\nThe only tiny issue is that there is no view resolver provided by Spring, which could resolve this type of\nview. So a developer has to create one; but worry not— it’s quite easy:\n@Component\npublic class JsonViewResolver implements ViewResolver {\n@Override\npublic View resolveViewName(String viewName, Locale locale) throws Exception {\nMappingJackson2JsonView view = new MappingJackson2JsonView();\n//make JSON output readable using proper indentation\nview.setPrettyPrint(true);\nreturn view;\n}\n}\nWhen using Java configuration classes, all that is needed is a @Bean annotated method:\n@Bean\npublic ViewResolver jsonViewResolver() {\nMappingJackson2JsonView view = new MappingJackson2JsonView();\nview.setPrettyPrint(true);\nreturn view;\n}\nThe Jackson library provides a set of annotations designed to be used when implementing classes\nsubjected to JSON serialization to customize what is serialized and in which format. This way of working is\nsimilar to JPA and JAXB.\n84\nChapter 3 ■ Spring MVC\n■ ! the project 03-chapter-07-solution has a view resolver configuration that uses a\nContentNegotiatingViewResolver. the data can be viewed in a web page, excel document, pDF document,\nor JSOn. run it and take a look at the implementation before moving on to the next section.\nPersonalization Beans\nMost web applications are created to provide a certain service to users from different places in the\nworld, so the application needs to adapt to the language used by those customers (a process called\ninternationalization). Some web applications offer their users the ability to customize the application’s\ninterface based on a number of available themes. Spring offers the ability to easily customize the locale and\nlook-and-feel of a web application via a couple of infrastructure beans.\nMessageSource\nTo support internationalization, a Spring application must have in its context a bean named messageSource.\nThe class of this bean must implement the MessageSource interface and provides access to localized\nmessages. This class provides concrete implementations for localization methods named getMessage(...).\nWhen an ApplicationContext is loaded, it automatically searches for this bean in the context and all calls to\ngetMessage(...) methods are delegated to this bean.\nSpring provides two out-of-the-box implementations for the MessageSource interface:\nResourceBundleMessageSource and StaticMessageSource. The second one allows messages to be\nregistered programmatically and it is intended to be used in testing. The first implementation relies on\nJDK’s ResourceBundle implementation. Reloading a resource bundle during execution is not possible,\nas ResourceBundle caches loaded bundles files forever, so the implementation usually used in a web\napplication is ReloadableResourceBundleMessageSource, which is a Spring-specific implementation that\naccesses bundles using specified base names, participating in the Spring ApplicationContext’s resource\nloading. This class supports reloading properties files containing the internationalization information; it is\nusually slightly faster than ResourceBundleMessageSource. Another advantage is that it can read properties\nfiles with a specific character encoding.\nIn the following, you can see a simple XML configuration of this bean:\n<bean id=\"messageSource\"\nclass=\"o.s.context.support.ReloadableResourceBundleMessageSource\">\n<property name=\"basenames\">\n<list>\n<value>/WEB-INF/messages/global<value/>\n</list>\n</property>\n<property name=\"cacheSeconds\">1</property>\n</bean>\nWhen only one resource bundle and the p-namespace are used, the previous definition becomes this:\n<bean id=\"messageSource\"\nclass=\"o.s.context.support.ReloadableResourceBundleMessageSource\"\np:basename=\"/WEB-INF/messages/global\"\np:cacheSeconds=\"1\"/>\n85\nChapter 3 ■ Spring MVC\nWhen Java-based configuration is used, the bean definition looks like this:\n@Bean\npublic MessageSource getMessageSource(){\nReloadableResourceBundleMessageSource messageSource =\nnew ReloadableResourceBundleMessageSource();\nmessageSource.setBasename(\"/WEB-INF/messages/global\");\nmessageSource.setCacheSeconds(1);\nreturn messageSource;\n}\nThe cacheSeconds property is used to set the number of seconds to cache the loaded property files.\nInternationalization messages are loaded from properties files under /WEB-INF/messages/; they are named\nglobal_[locale].properties.\nTo use the messageSource bean to retrieve internationalized resources inside handler methods, simply\ninject the bean in the controller and call the desired getMessage(...) method. The Spring type library is\nused for this purpose too. The fmt tag library, which is a component of JSTL, can be used too. The syntax is a\nlittle different, as you can see in the following example:\n<!-- JSTL fmt way -->\n<fmt:message key=\"menu.home\"/>\n<!-- Spring way -->\n<spring:message code=\"menu.home\"/>\nWhen using the spring:message tag, the MessageSource classes can be integrated with the\nSpring context. The spring:message- tag works with the locale support that comes with Spring. If the\n“code” attribute isn’t set or cannot be resolved, the “text” attribute is used as the default message. And\nspring:message supports dynamic names for internationalization codes, so a message code can be an\nexpression:\n<spring:message code=\"myPrefix.${account.state}\"/>\nReloadableResourceBundleMessageSource is able to load messages from properties files with a specific\nencoding. In order for those messages to be successfully incorporated in a view, Spring provides a class\ncalled CharacterEncodingFilter, which is used to apply character encoding to requests. It can work in two\nmodes to do the following:\n• Enforce the encoding\n• Apply the encoding if one is not already defined\nThis bean is added to the web.xml file like this:\n<filter>\n<filter-name>characterEncodingFilter</filter-name>\n<filter-class>o.s.web.filter.CharacterEncodingFilter</filter-class>\n<init-param>\n<param-name>encoding</param-name>\n<param-value>UTF-8</param-value>\n</init-param>\n86\nChapter 3 ■ Spring MVC\n<init-param>\n<param-name>forceEncoding</param-name>\n<param-value>true</param-value>\n</init-param>\n</filter>\n<filter-mapping>\n<filter-name>characterEncodingFilter</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\nEquivalent Java-based configuration looks like in the following code snippet:\n\\\\in class implementing WebApplicationInitializer\n@Override\nprotected Filter getServletFilters() {\nCharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();\ncharacterEncodingFilter.setEncoding(\"UTF-8\");\ncharacterEncodingFilter.setForceEncoding(true);\nreturn new Filter { characterEncodingFilter};\n}\nLocaleResolver\nIn order for the messageBean to solve the messages, a locale must be defined for a web application. The value\nfor the locale is taken from the browser. The bean resolving the locale must be named localeResolver and\nit must implement the LocaleResolver interface, because the DispatcherServlet looks for such a bean to\nuse. A LocaleResolver can also store a different locale defined by the user. In Spring, there are three types of\nlocale resolvers defined:\n• AcceptHeaderLocaleResolver: Reads the locale from the request\n• CookieLocaleResolver: Reads/writes the locale from/to a cookie named org.\nspringframework.web.servlet.i18n.CookieLocaleResolver.LOCALE (unless\nnamed otherwise in the bean definition using property cookieName)\n• SessionLocaleResolver: Reads/writes the locale from/to an HTTP session\n■ ! the default name of the cookie can be confusing because it looks like a full name for a static variable, but\nno such variable exists. the same applies to the theme cookie mentioned in the next section.\nWhen a specific LocaleResolver is not defined, AcceptHeaderLocaleResolver is used as\ndefault. When users select language, CookieLocaleResolver or SessionLocaleResolver can be used.\nCookieLocaleResolver is most often used in stateless applications without user sessions; this bean is\ndefined in the mvc-config.xml file. The following definition is quite common:\n<bean id=\"localeResolver\" class=\"o.s.w.s.i18n.CookieLocaleResolver\"\np:defaultLocale=\"en\"\np:cookieMaxAge=\"3600\"/>\n87\nChapter 3 ■ Spring MVC\nThe cookieMaxAge sets the maximum age in seconds for the cookie. If set to –1, the cookie is deleted\nonly when the client shuts down.\nIn order for Spring to be notified of the changes in the locale, a bean of type LocaleChangeInterceptor\nneeds to be configured. This ensures that the locale interceptor will be applied to all handler mappings.\n<mvc:interceptors>\n<bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" />\n</mvc:interceptors>\nAn equivalent Java configuration for this bean can be used by providing an implementation for the\naddInterceptors method when implementing WebMvcConfigurer or overriding the same method when\nextending WebMvcConfigurerAdapter:\n\\\\in the @Configuration and @EnableWebMvc annotated class\n@Override\npublic void addInterceptors(InterceptorRegistry registry) {\nregistry.addInterceptor(localeChangeInterceptor());\n\\\\other interceptors can be added here\n}\n@Bean\npublic LocaleChangeInterceptor localeChangeInterceptor(){\nreturn new LocaleChangeInterceptor();\n}\nThis interceptor detects requests to change the locale by looking for a request parameter named locale\nby default. The LocaleResolver bean is used to store the value of this parameter. A different name can be set\nby using a different value for the parameterName property. Request URLs to change the locale are expected to\ncontain the parameter name and a value in the URL: http://myapp.com/?",
    "answer": "[parameterName]=[locale_name] (under /WEB-INF/messages/ a [filename]_[locale_name].properties files is defined). ThemeResolver If the web application has a customizable look and feel, the different themes can be managed using a bean named themeResolver. The bean resolving the theme has to implement the ThemeResolver interface, because the DispatcherServlet looks for such a bean to identify the resources needed for creating a response. To use a ThemeResolver, you have to do the following: 1. Create a [theme].properties file on the classpath (under /WEB-INF/classes/). The “theme” term can be replaced with any word describing that theme. In it, add the properties specific to that theme. In the code samples attached to this chapter, you have a file named blue.properties that contains the following theme properties: style.css=/styles/decorator-blue.css banner.image=/images/banner-blue.png 88 Chapter 3 ■ Spring MVC 2. Use the Spring theme tag to resolve theme properties. <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> ... <spring:theme var=\"styleCss\" code=\"style.css\"/> <c:url var=\"styleCssUrl\" value=\"${styleCss}\"/> <link type=\"text/css\" type=\"stylesheet\" href=\"${styleCssUrl}\" /> To access the current theme in a view, you can use the RequestContext; but first you need to expose a requestContext attribute: <bean class=\"org.s.web.servlet.view.InternalResourceViewResolver\"> <property name=\"requestContextAttribute\" value=\"requestContext\"/> </bean> <c:if test=\"${requestContext.theme.name eq 'blue'}\"> ... In Spring there are three types of theme resolvers defined:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "FixedThemeResolver: The default implementation uses a configured default theme\n• CookieThemeResolver: Reads/writes the theme attribute from/to a cookie named\norg.springframework.web.servlet.theme.cookieThemeResolver.THEME\n(unless named otherwise in the bean definition using property cookieName)\n• SessionThemeResolver: Reads/writes the theme attribute from/to a HTTP session\nFigure 3-8. List of cookies for the Personal Records Manager application\n89\nChapter 3 ■ Spring MVC\nYou can view the two cookies using the Firebug extension for Firefox by opening the console and\nlooking in the Cookies tab. You should see a cookie listing similar to the one shown in Figure 3-8.\nFor Spring to be notified of the changes in the theme, a bean of type ThemeChangeInterceptor needs to\nbe configured. This ensures that the theme interceptor is applied to all handler mappings:\n<mvc:interceptors>\n<bean class=\"org.springframework.web.servlet.theme.ThemeChangeInterceptor\" />\n</mvc:interceptors>\nAn equivalent Java configuration for this bean can be used by providing an implementation for the\naddInterceptors method when implementing WebMvcConfigurer or overriding the same method when\nextending WebMvcConfigurerAdapter:\n\\\\in the @Configuration and @EnableWebMvc annotated class\n@Override\npublic void addInterceptors(InterceptorRegistry registry) {\nregistry.addInterceptor(themeChangeInterceptor());\n\\\\other interceptors can be added here\n}\n@Bean\npublic ThemeChangeInterceptor themeChangeInterceptor(){\nreturn new ThemeChangeInterceptor();\n}\nThis interceptor detects requests to change the theme by looking for a request parameter named\ntheme by default. The ThemeResolver bean is used to store the value of this parameter. A different\nname for it can be set by using a different value for the parameterName property. Request URLs to change\nthe theme are expected to contain the parameter name and a value defined in the application:\nhttp://[parameterName]?",
    "answer": "theme=[theme_name] (under /WEB-INF/classes/ a [theme_name].properties files is defined). HandlerExceptionResolver Exceptions can be thrown during handler mapping or execution. Spring MVC catches and handles the exceptions using implementations of HandlerExceptionResolver. The developer writing the application can customize the beans provided by Spring or provide his own implementation. The typical way to treat an MVC exception is to prepare a model and select an error view. Multiple exception resolvers can be used to treat different types of exceptions in different ways. They can also be chained using the order property like any other infrastructure bean. Spring MVC supports the following default resolvers: org.springframework.web.servlet.HandlerExceptionResolver= o.s.w.s.m.a.AnnotationMethodHandlerExceptionResolver,\\ o.s.w.s.m.a.ResponseStatusExceptionResolver,\\ o.s.w.s.m.s.DefaultHandlerExceptionResolver 90 Chapter 3 ■ Spring MVC An exception resolver provides information related to the context in which the exception was thrown, which handler method was executing, and which arguments it was called with. Spring MVC also provides some implementation of its own, which you can configure and use instead of writing a full implementation. The preferred ways to handle exceptions are by using the SimpleMappingExceptionResolver bean and annotating methods with @ExceptionHandler. SimpleMappingExceptionResolver can be used to map exception classes to different views. The SimpleMappingExceptionResolver provides the following options:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Maps exception classes to view names\n• Specifies a default error page for any exception that is not handled\n• Logs a message if configured to do so by setting a logger name for the\nwarnLogCategory property\n• Sets the name of the exception attribute to add to the model so it can be used inside\na view\nThe following is an example on how to configure a SimpleMappingExceptionResolver bean to map\nexception types to error views, depending on the class name:\n<bean class=\"o.s.web.servlet.handler.SimpleMappingExceptionResolver\">\n<property name=\"exceptionMappings\">\n<map>\n<!-- No need for package name, any package name will match. If you have\ntwo exceptions with the same name in different packages, you need to use\nthe full class name to implement the proper behaviour -->\n<entry key=\"DataAccessException\" value=\"databaseError\"/>\n<entry key=\"InvalidPncException\" value=\"pncError\"/>\n<!-- The databaseError and pncError are logical view names -->\n</map>\n</property>\n<property name=\"defaultStatusCode\" value=\"500\"/>\n<property name=\"defaultErrorView\" value=\"error\"/>\n</bean>\nAn equivalent Java configuration can be obtained by defining the bean programmatically:\n\\\\in the @Configuration and @EnableWebMvc annotated class\n@Bean(name=\"simpleMappingExceptionResolver\")\npublic SimpleMappingExceptionResolver createSimpleMappingExceptionResolver() {\nSimpleMappingExceptionResolver resolver =\nnew SimpleMappingExceptionResolver();\nProperties mappings = new Properties();\nmappings.setProperty(\"DatabaseException\", \"databaseError\");\nmappings.setProperty(\"InvalidPncException\", \"pncError\");\nresolver.setExceptionMappings(mappings); // None by default\nresolver.setDefaultStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());\nresolver.setDefaultErrorView(\"error\");\nreturn resolver;\n}\n91\nChapter 3 ■ Spring MVC\n■ ! Views returned from @ExceptionHandler methods do not have access to the exception,\nbut views defined to SimpleMappingExceptionResolver do. this means that when using\nSimpleMappingExceptionResolver, the @ExceptionHandler methods must construct and return a\nModelAndView instance. (See example in the 02-pr-mvc-basic-solution module.) in order to return a logical\nview name from a method annotated with @ExceptionHandler, ExceptionHandlerExceptionResolver must\nbe extended.\nTo provide a custom implementation, the SimpleMappingExceptionResolver can be extended; its\nmethods can be overridden to provide the desired functionality.\nMethods annotated with @ExceptionHandler can be used to handle exceptions inside a single\ncontroller or they may apply to many when defined inside a class annotated with @ControllerAdvice.\nAnnotated exception handler methods are automatically called when controller methods throw an\nexception, and the method does not treat it itself. Method signatures are as flexible for an exception handler\nmethod as the controller handler methods (this is discussed in the “Controllers” section). Next you see an\nexception handler method used to handle database exceptions for the PersonsController class:\n@Controller\npublic class PersonsController {\n...\n@ExceptionHandler\npublic String handleException(DataAccessException ex) {\nreturn \"databaseError\";\n}\n}\nThe @ExceptionHandler can be set to treat a specific type of exception, using the annotation parameter,\nthus rendering the exception argument of the method unnecessary.\n@Controller\npublic class PersonsController {\n...\n@ExceptionHandler(DataAccessException.class)\npublic String handleException() {\nreturn \"databaseError\";\n}\n}\nBut using a parameter gives access to the exception, which can be treated or logged. Of course, the two\napproaches can be mixed.\nThe @ExceptionHandler can be set to treat an array of exceptions. If an exception is thrown that\nmatches one of the types in the list, then the method annotated with the matching @ExceptionHandler is\ninvoked. The same can be done by setting the array as an argument for the annotated method. By using\ndifferent @ExceptionHandler annotated methods for each type of exception, the code can become crowded.\nSo exceptions can be grouped by different criteria; for example, an @ExceptionHandler method can handle a\ngroup of database access exceptions, another can treat security exceptions, and so on. The chosen approach\ndepends on the exception handling specifications of a project and developer preference.\n92\nChapter 3 ■ Spring MVC\nSpring MVC internal exceptions raised while processing a request are translated by a class named\nDefaultHandlerExceptionResolver to specific error codes: a client error (4xx) or a server error (5xx), which\nis set on the response. This class is registered by default with the MVC namespace and @EnableWebMVC.\nBut when writing your own exceptions, you can set the status code on the exception class, like this:\n@ResponseStatus(value= HttpStatus.NOT_FOUND, reason=\"Requested item not found\")\npublic class NotFoundException extends Exception {\n...\n}\nA class annotated with @ControllerAdvice allows you to use the same exception handling techniques\nacross the whole application, not just a single controller. Three types of methods are supported inside a class\nannotated with @ControllerAdvice:\n• Methods annotated with @ExceptionHandler that are used to handle exceptions\n• Methods annotated with @ModelAttribute that are used to add data to the model\n• Methods annotated with @InitBinder that are used for configuring form-handling\nA controller advice class used only for exception handling could look like in the following example,\nwhich depicts a global default exception handler:\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n@ExceptionHandler(value = Exception.class)\npublic ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e)\nthrows Exception {\nif (AnnotationUtils.findAnnotation(e.getClass(),\nResponseStatus.class) != null){\n// we test to see if the exception is annotated with @ResponseStatus\n// if it is, we will re-throw it and let Spring handle it.\nthrow e;\n}\nModelAndView mav = new ModelAndView();\n//set exception details to be displayed in the page\nmav.addObject(\"exception\", e);\n//set request URL to be displayed in the page, so the request causing\n//the problem can be identified\nmav.addObject(\"url\", req.getRequestURL());\nmav.setViewName(\"error\");\nreturn mav;\n}\n}\n93\nChapter 3 ■ Spring MVC\n■ ! notice in the previous example that the exception handler method returns a ModelAndView instance that\nis created inside the method body. the reason for this is that the methods in classes annotated with\n@ControllerAdvice are methods that apply to a group of controllers in the application. this can be customized\nvia annotations(), basePackageClasses(), and basePackages() methods. But the methods are not part\nof the controller, so a model cannot be automatically injected by Spring. also, a global exception handler like\nthis one uses the same view to display all exception-specific messages in the application, so the view must be\nlinked to the model, which in this case can only be done by creating a ModelAndView instance that is handled\nappropriately by the DispatcherServlet.\nIf you want to analyze the full capabilities of treating exceptions with Spring MVC, you can take a look at\ntutorials posted on their official site.11 For passing the certification exam, all that was presented here should\nsuffice.\nUser-Provided Components\nAlthough Spring MVC offers a lot of ready-to-use components for creating web applications (all that is\nrequired are small customizations), there are components that need to be implemented by the developer.\nSuch components are controllers and interceptors. Controllers include and are the focus object of everything\nthat has been presented so far. Controllers are the handlers identified by handler mappings; their methods\nhandle application requests and return views. They can use message source to populate models with\ninternationalized data and can contain methods for exception handling. If until now it was hard to connect\nall the infrastructure beans and picture what exactly they did, this mystery will be solved in the “Controllers”\nsection, which puts every LEGO piece in its proper place. The handler interceptors are not really a big thing\ncompared to it, but they are useful too.\nControllers\nControllers are POJOs—simple beans annotated with the @Controller annotation—that are used to handle\nrequests. Each controller class contains methods that are mapped to a request URL via the @RequestMapping\nannotation. These methods are used to handle different requests. Each method executes three steps:\n1. Invoke services.\n2. Populate a model.\n3. Select a view.\n11A detailed explanation of exception handling using Spring MVC is at https://spring.io/blog/2013/11/01/\nexception-handling-in-spring-mvc.\n94\nChapter 3 ■ Spring MVC\nHere is a simple controller example. Notice the syntax for @RequestMapping annotation.\n@Controller\n@RequestMapping(\"/persons\")\npublic class PersonsController {\nprivate PersonManager personManager;\n@Autowired\npublic PersonsController(PersonManager personManager) {\nthis.personManager = personManager;\n}\n// Handles requests to list all persons.\n@RequestMapping(value=\"/\", method = RequestMethod.GET)\npublic String list(Model model) {\nmodel.addAttribute(\"persons\", personManager.findAll());\nreturn \"persons/list\";\n}\n//Handles requests to shows detail about one person.\n@RequestMapping(value=\"/{id}\", method = RequestMethod.GET)\npublic String show(@PathVariable Long id, Model model) {\nmodel.addAttribute(\"person\", personManager.findOne(id));\nreturn \"persons/show\";\n}\n}\nWhen @RequestMapping is used to annotate a controller class, the path that the controller is mapped to\nis a part of the request’s URL. The previous methods handle requests looking like this:\n# handled by the list menthod\nhttp://localhost:8080/persons/\n# handled by the show menthod\nhttp://localhost:8080/persons/144\nAll handling methods are relative to the path set by the @RequestMapping at class level. This means that\nthe class mapping is solved first, and then the request mapping.\n■ ! a controller can have methods that are not annotated with @RequestMapping. these methods are not\nused to solve requests. they are practically ignored, processing a user request.\n95\nChapter 3 ■ Spring MVC\nThe methods of a controller can be mapped using @RequestMapping with the following URI templates:\n• By URL only:\n@RequestMapping(\"persons/list\")\npublic String list(Model model) {\n...\n}\n• By URL and request method:\n@RequestMapping(\"persons/list\", method = RequestMethod.GET)\npublic String list(Model model) {\n...\n}\n• By URL with request parameters:\n@RequestMapping(value=\"/persons/show\", params={\"id\"})\npublic String show(@RequestParam(\"id\") Long id, Model model) {\n...\n}\n• By URL with a parameter and a specific value for it:\n@RequestMapping(value=\"/persons/show\", params={\"id=1123\"})\npublic String show(@RequestParam(\"id\") Long id, Model model) {\n...\n}\n• By URL with a path variable:\n@RequestMapping(value=\"/persons/{id}\")\npublic String show(@PathVariable(\"id\") Long id, Model model) {\n...\n}\n• By URL with a path variable and a regular expression that the value must match:\n@RequestMapping(value = \"/{id:[\\\\d]*}\")\n//the regular expression [\\\\d]* insures the id to be numeric,\n//made of one or more digits.\npublic String show(@PathVariable(\"id\") Long id, Model model) {\n...\n}\n96\nChapter 3 ■ Spring MVC\nThe preceding are simple examples of URIs onto which controllers methods are mapped. The options\ndo not stop here and any of these can be mixed, depending on the developer’s needs. For example, you can\ndo something like this in web applications:\n@RequestMapping(value=\"/persons/{id}/?",
    "answer": "dateOfBirth=1983-08-18\") public String show(@RequestParam(\"dateOfBirth\") Date date, @PathVariable Long id, Model model) { ... } The controller methods can have very flexible signatures. The following can be used as arguments in any combination or order:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Model\n• HttpServletRequest\n• HttpServletResponse\n• HttpSession\n• Locale\n• Principal\nIn the body of a controller method, path variables and request parameters must be accessed to process\nthe request. If the URI template is a RESTful URI,12 then the variable is part of the URI, called a path variable,\nand can be accessed using @PathVariable:\n@RequestMapping(value=\"/persons/{id}\")\npublic String show(@PathVariable(\"id\") Long identifier, Model model) {\n...\n}\n■ CC When the method argument has the same name with the path variable, the value for the @\nPathVariable annotation is no longer required.\nSo the preceding method becomes:\n@RequestMapping(value=\"/persons/{id}\")\npublic String show(@PathVariable Long id, Model model) {\n...\n}\n12A RESTful URI identifies a domain resource (like a book, or a person, in this case) rather than an application resource\nlike a web page or a form. URI is the acronym for Uniform Resource Identifier. URL is the acronym for Uniform\nResource Locator. REST services work only with URIs and @PathVariable.\n97\nChapter 3 ■ Spring MVC\nAnd handles requests similar to: http://localhost:8080/persons/144.\nThere is a special case when the @PathVariable is not even needed and the default is the argument\nname; this happens when the application is compiled with debug symbols enabled. It is rarely used because\nthe result is an unoptimized/debuggable byte code. This is mentioned here because the official course\nmentions it too, and it might be useful to know that this possibility exists in case you ever need it.\nWhen the URI is non-RESTful, the variable is provided as a parameter in the request URL. The request\nparameter can be accessed using the @RequestParam annotation.\n@RequestMapping(value=\"/persons/show\", params={\"id\"})\npublic String show(@RequestParam(\"id\") Long identifier, Model model) {\n...\n}\nType conversion is applied, and if the parameter value is missing or has the wrong type, an exception is\nthrown.\n■ CC When the method argument has the same name with the request parameter, the value for\nthe @RequestParam annotation is no longer required. the params property is no longer needed for the\n@RequestMapping either.\nSo the preceding method becomes this:\n@RequestMapping(value=\"/persons/show\")\npublic String show(@RequestParam Long id, Model model) {\n...\n}\nThe request parameter can be set as optional if it is not a primitive type; in this case, it defaults to null\nand must be handled in the method body.\n@RequestMapping(value=\"/persons/show\", params={\"id\"})\npublic String show(@RequestParam(value=\"id\", required=false) Long identifier,\nModel model) {\nif(identifier == null) {\n//return a specific view\n}\n...\n}\nThe request parameter can also be set as optional when the request parameter is a primitive type and a\nfallback default value is provided.\n@RequestMapping(value=\"/persons/show\", params={\"id\"})\npublic String show(@RequestParam(value=\"id\", required=false,\ndefaultValue = \"2\") long identifier, Model model) {\nif(identifier == null) {\n//return a specific view\n}\n...\n}\n98\nChapter 3 ■ Spring MVC\nRequest parameters can have any type, including Date and Number, and these types can be formatted by\nusing the following annotations:\n//matches http://localhost:8080/persons/1983-08-18\n@RequestMapping(value=\"/persons/{birthDate}\")\npublic String list(@PathVariable\n@DateTimeFormat(pattern = \"yyyy-MM-dd\") Date birthDate,\nModel model) {\n...\n}\n//matches http://localhost:8080/accounts/?",
    "answer": "minAmount=$5000.50 @RequestMapping(value=\"/accounts\" params={\"minAmount\"}) public String list(@RequestParam @NumberFormat(style = NumberFormat.Style.CURRENCY) Double minAmount, Model model) { ... } To generate a Spring-parametrized URI in a JSP file, a combination of <spring:url> tag and <spring:param/> is used: <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> ... <spring:url var=\"showUrl\" value=\"{id}\"> <spring:param name=\"id\" value=\"${person.id}\"/> </spring:url> <a href=\"${showUrl}\">${person.id}</a> The first three lines of the preceding example generate a URI similar to http://localhost:8080/ person/123 by using the current context of the application and the person attribute in the model. The generated URI is stored as a value for the showUrl attribute in the model. In the next line, that attribute is used to populate the HTML link element. After the execution of the code in a mapping method, the controller selects a view for the resulting data to be rendered in. The controller’s responsibility includes populating a model map with the data to display in the view. There are multiple ways of specifying the resulting view too, but the default is for the mapping method to return a string, which is the logical view name. (By default, a path to a JSP file is expected, unless some view resolver is used, such as TilesResolver, for example). Also, the controller can directly write to the response stream and complete the request (when handling AJAX calls or REST services, cases that are presented in detail in the following chapters). The process to identify which view is being used is called view resolution, which is performed by one view resolver class or a chain of view resolver classes. 99 Chapter 3 ■ Spring MVC Accessing Model Data Accessing Model data instances is simple, especially when the model is used as an argument of the request method, and Spring takes care of injecting it: @RequestMapping(\"/persons\") public String list(Model model) { model.addAttribute(\"persons\", personManager.findAll()); return \"persons/list\"; } All model attributes are available in the JSP for rendering. Attributes can be added to the model without specifying a name. There are convention-over- configuration rules applied by Spring to infer the name of an attribute based on the type of the attribute value set. For example:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Person person = personManager.getById(id);\nmodel.addAttribute(person);\n//added as \"person\" as the reference type is Person\n• List<Person> persons = personManager.findAll();\nmodel.addAttribute(persons);\n// added as \"personList\" as reference type is List<Person>\n■ CC When objects are added to a model without specifying an attribute name, this is inferred by lowercasing\nthe first letter of the reference type. if the attribute is a collection of objects, the attribute name is composed\nfrom the reference type with first letter lowercased and suffixed with the specific collection suffix (a simple\nname of the Collection interface implemented): “Set” for Set<?",
    "answer": ">, “List” for List<?>, etc. When only one object needs to be added to the model, the object can simply be returned by the method and it is automatically added to the model. This obviously does not work with objects of type String, because Spring assumes the returned String value is a logical view name. When the following approach is used, the returned object is added to the model as an attribute and the name is inferred based on the conventions mentioned earlier. @RequestMapping(\"/persons/list\") public List<Person> list() { return personManager.findAll(); //model name attribute convention will be used } But the attribute name can be specified by annotating the method with @ModelAttribute and specifying a different attribute name. @RequestMapping(\"/persons/list\") @ModelAttribute(\"persons\") public List<Person> list() { return personManager.findAll(); } 100 Chapter 3 ■ Spring MVC ■ CC When the handler method returns an object, the DispatcherServlet has to infer the view to render the model. the logical view name is extracted from the mapping UrL by stripping the first \"/\" and the extension if present. in the preceding examples, the logical view name used is \"persons/list\". Selecting a View A controller method selects a view by returning its name, and DispatcherServlet takes care of the rest using the ViewResolvers in the context. But there are conventions over configurations in place that allow a controller method to return null and a view is still selected, like the convention mentioned right before this section. The logical view name can be extracted from the request URI by removing the leading slash and extension. This is done by the RequestToViewNameTranslator. @RequestMapping(\"/persons/list.html\") public String list(Model model) {...} // logical view name is: \"persons/list\" ■ CC the same view name “persons/list” is inferred if you have a @RequestMapping (\"/persons\") on the controller class and @RequestMapping (\"/list.html\") on the method. When <mvc:annotation-driven/> or @EnableWebMVC is used in the application configuration for simple views that do not require a model being populated with data can be defined without controllers. The following sample code shows how to configure such views using XML and Java configuration. <!-- in mvc-config.xml --> <mvc:view-controller path=\"/\" view-name=\"welcome\"/> //in class annotated with @Configuration and @EnableWebMvc // and implementing WebMvcConfigurer @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"welcome\"); } Redirecting Controller methods can also make redirect requests instead of selecting a view. This is done by returning a string representing a view name prefixed with \"redirect:\". Redirecting implies a new HTTP request being created and usually some request attributes need to be passed from one request to the other. Until Spring 3.1, this was done using @ModelAttribute on a controller method, or @SessionAtributes on the controller class. The @ModelAttribute makes sure that the annotated method is always invoked before a request handling method, thus adding the person instance to the model as an attribute with the name \"person\": @ModelAttribute public Person getPerson(@PathVariable Long id) { return personManager.getPerson(id); } 101 Chapter 3 ■ Spring MVC The object is not added to the HttpServletRequest to fulfill this purpose, but to the model; the reason for this is that Spring MVC wants to keep the view usage as generic as possible, which means not forcing the application to use only view technologies based on HttpServletRequest. The @SessionAttributes is used on a controller class to designate which model attributes should be stored in the session. @SessionAttributes(\"person\") @Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(\"/{id}\", method = RequestMethod.GET) public Person show(@PathVariable Long id, Model model) { model.add(\"person\", personManager.getPerson(id)); return \"persons/show\"; } } Starting with Spring 3.1, there is another way: using flash attributes, which are saved in an object model implementing the RedirectAttributes interface. Flash attributes provide a way for one request to store attributes intended for use in another. Flash attributes are supported by default; no extra configuration is needed. They are automatically added to the model after the redirect, but they must be added to the redirectAttributes object before the redirect call. @Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(method = RequestMethod.POST) public String edit(@Valid Person person, final RedirectAttributes redirectAttributes, BindingResult result, Model model) { if (result.hasErrors()) { return \"persons/edit\"; } personManager.update(person); redirectAttributes.addFlashAttribute(\"person\", person); return \"redirect:/persons/show\"; } } @RequestMapping(\"/show\", method = RequestMethod.GET) public String show(@ModelAttribute(\"person\") Person person) { // because the attribute is already in the model, //the only thing left to do is return the view name return \"persons/show\"; } } 102 Chapter 3 ■ Spring MVC The object added to the redirectAttributes model is added to the model at redirect time with the same attribute name. So if the parameter name is different in the method being called at redirect time, a value representing the attribute name for the @ModelAttribute has to be set. In the previous example, this was done anyway just to make it obvious, but because of the Spring convention over configuration is in place, the value for the verb|@ModelAttribute| can be skipped, as the name of the argument is considered. ■ ! a sample of what controller methods look like and a sample of “redirect:” usage are found in the 03-pr-mvc-layout-solution module. the equivalent practice module is covered at the end of this chapter. Testing Controllers When testing controllers, the focus is to check that handler methods return the expected logical view name and that the expected data has been placed in the model as an attribute. When doing unit testing, the manager does not need to be involved, as saving data to the database defeats the purpose of testing a small unit. So managers used in the controllers can be replaced with skeleton objects with simulated functionality. This can be done by creating skeleton objects, called stubs, or mocking libraries can be used, to pass to them the responsibility of implementing the objects according to the desired functionality. The library used to mock the managers used in the code samples for this book is called Mockito.13 The tests have to be run with MockitoJUnitRunner for the mock objects to be treated accordingly. Assuming you have a controller that looks like this... public class PersonsController { private PersonManager personManager; @Autowired public PersonsController(PersonManager personManager) { this.personManager = personManager; } @RequestMapping(value=\"/list\", method = RequestMethod.GET) public String list(Model model) { model.addAttribute(\"persons\", personManager.findAll()); return \"persons/list\"; } A test method for the list handler method will look like this: @RunWith(MockitoJUnitRunner.class) public class PersonsControllerTest { private PersonsController personsController; @Mock private PersonManager managerMock; 13More information about it is at http://mockito.org. 103 Chapter 3 ■ Spring MVC @Before public void setUp(){ personsController = new PersonsController(managerMock); } @Test public void list() { // setting up a mock manager that returns an empty list when // findAll() is called when(managerMock.findAll()).thenReturn(new ArrayList<>()); //a model object is \"manually\" constructed to pass as argument // to the controller method Model model = new BindingAwareModelMap(); String view = personsController.list(model); assertEquals(\"persons/list\", view); //this tests if the handler method has added //the \"persons\" attribute to the provided model. assertNotNull(model.asMap().get(\"persons\")); } } The @Mock annotation makes sure that the object is treated as a mock object by the library and a skeleton implementation is provided transparently. Statements beginning with calls to the when method define the behavior of the respective object when its mock methods are called. The syntax is quite intuitive and really easy to use. The statement underlined in the preceding code sample can be translated as: “When the findAll() method is called on the mock object, return an empty list of persons.” Integration testing of the controllers can be done by creating a test context for their execution, and it has the advantage of testing the integration of application layers with each other. The test class looks like this: @RunWith(SpringJUnit4ClassRunner.class) @WebAppConfiguration @ContextConfiguration({ \"file:src/main/webapp/WEB-INF/spring/mvc-config.xml\", \"classpath:spring/app-dao-config.xml\", \"classpath:spring/test-db-config.xml\" }) public class AllControllerTest { @Autowired private PersonsController personsController; @Before public void setUp(){ //we are making sure the controller was initialized correctly assertNotNull(personsController); } 104 Chapter 3 ■ Spring MVC @Test public void list() { Model model = new BindingAwareModelMap(); String view = personsController.list(model); assertEquals(\"persons/list\", view); assertNotNull(model.asMap().get(\"persons\")); // test to see id the manager returned the expected result assertTrue(((List<Person>) model.asMap().get(\"persons\")).size() == 16); } } The WebAppConfiguration annotation makes sure that the context in which the test methods in this class are run is WebApplicationContext. The root path of the web application is set using this annotation, and the default value for it is the one consecrated by Maven \"src/main/webapp\". There are other ways of initializing a test web context or even for mocking one using MockMvc, which is the main entry point for server-side Spring MVC test support. Other test libraries can be used to fully test a controller and all objects involved in handling a request. For example, Hamcrest, a testing library that offers a lot of useful methods named matchers test the type of expected params, attribute values, results, and so forth.14 @RunWith(SpringJUnit4ClassRunner.class) @WebAppConfiguration @ContextConfiguration({\"file:src/main/webapp/WEB-INF/spring/mvc-config.xml\", \"classpath:spring/app-dao-config.xml\", \"classpath:spring/test-db-config.xml\"}) public class HospitalsControllerTest { @Autowired private WebApplicationContext wac; private MockMvc mockMvc; @Before public void setUp() { assertNotNull(wac); this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); } @Test // test all aspects handling a request to \"/hospitals/ public void list() throws Exception { mockMvc.perform(get(\"/hospitals/\")) // test if response status is 200 .andExpect(status().isOk()) // test if the attribute \"hospital\" was added to the model .andExpect(model().attributeExists(\"hospitals\")) 14Read more about it on the official site at http://hamcrest.org/. 105 Chapter 3 ■ Spring MVC //when using Tiles, we can test the forward of the request to //the template for the page .andExpect(forwardedUrl(\"/WEB-INF/templates/layout.jsp\")); } @Test //test a method returning \"redirect:/persons/list\" // (all persons born at the hospital with code =134181) public void listp() throws Exception { mockMvc.perform(get(\"/hospitals/134181\")) // test if response status is 302 .andExpect(status().isFound()) //test if the \"persons\" attribute was added to the redirectAttributes model .andExpect(flash().attributeExists(\"persons\")) // test if the redirect request is sent to the expected URL .andExpect(redirectedUrl(\"/persons/list\")); } } These are the Spring MVC flavors presented in the book; choose whichever you feel most comfortable with. Handler Interceptors Handler interceptors are very useful for adding common functionality for all controllers inside an application. For example, a handler interceptor in an application could be used to audit requests, or to monitor the execution time of handler methods, or to generate performance reports. The most obvious examples for the use of an interceptor are internationalization, validation of data in the request, and request data convertors. Security checks could also be executed by a handler interceptor to give or restrict access to a handler method. When using REST, a special interceptor of type JsonViewResponseBodyAdvice can be used to customize the response before the JSON serialization with MappingJackson2HttpMessageConverter. The handler interceptors are beans in the application context. A handler interceptor class must implement the HandlerInterceptor interface and provide concrete implementation for any of the methods that the user is interested in:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "preHandle: Called after the HandlerAdapter has identified the handler method and\nbefore its invocation. This method controls the execution of other interceptors in the\nchain and the handler method by returning a Boolean value.\n• postHandle: Called after the HandlerAdapter invokes the handler method and\nbefore the DispatcherServlet renders the view (can add extra objects to the model).\n• afterCompletion: Called after the request has processed and the view has rendered.\nThis method is called regardless of the outcome of the handler method call; it can be used for resources\ncleanup (behavior similar to a finalize method).\nThe interceptors that modify the response before serialization must implement\nResponseBodyInterceptor and provide an implementation for the beforeBodyWrite method.\n(This is covered in more detail in Chapter 5.\n106\nChapter 3 ■ Spring MVC\nWhen personalizing the application with locale and theme, the LocaleChangeInterceptor and\nThemeChangeInterceptor are configured like this:\n<!-- XML -->\n<mvc:interceptors>\n<bean class=\"o.s.web.servlet.i18n.LocaleChangeInterceptor\"/>\n<bean class=\"o.s.web.servlet.theme.ThemeChangeInterceptor\"/>\n</mvc:interceptors>\n//Java Configuration\n//in the @Configuration and @EnableWebMvc annotated class\n@Override\npublic void addInterceptors(InterceptorRegistry registry) {\nregistry.addInterceptor(localeChangeInterceptor());\nregistry.addInterceptor(themeChangeInterceptor());\n}\n@Bean\npublic LocaleChangeInterceptor localeChangeInterceptor(){\nreturn new LocaleChangeInterceptor();\n}\n@Bean\npublic ThemeChangeInterceptor themeChangeInterceptor(){\nreturn new ThemeChangeInterceptor();\n}\nBoth interceptors use their preHandle method to set locale and theme values on the appropriate\nresolvers.15\nUsers can also create their own interceptors; in 02-pr-mvc-basic-solution the AuditInterceptor is\ngiven as an example.\n@Component\npublic class AuditInterceptor extends HandlerInterceptorAdapter {\n@Override\npublic boolean preHandle(HttpServletRequest request,\nHttpServletResponse response, Object handler)\nthrows Exception {\n// custom implementation here\nreturn true;\n}\n15You can take a look at these interceptors’ code on GitHub at https://github. com/spring-projects/spring-\nframework/blob/master/spring- webmvc/src/main/java/org/ springframework/web/servlet/theme/\nThemeChangeInterceptor.java and https://github.com/spring-projects/spring-framework/blob/master/\nspring-webmvc/src/main/java/org/springframework/web/servlet/i18n/LocaleChangeInterceptor.java.\n107\nChapter 3 ■ Spring MVC\n@Override\npublic void postHandle(HttpServletRequest request,\nHttpServletResponse response, Object handler, ModelAndView modelAndView)\nthrows Exception {\n// custom implementation here\n}\n@Override\npublic void afterCompletion(HttpServletRequest request,\nHttpServletResponse response, Object handler, Exception ex)\nthrows Exception {\n// custom implementation here\n}\n}\nTo enable this interceptor, you have to configure it in the context. The following snippets show how this\ncan be done in XML and using Java configuration:\n<!-- XML -->\n<mvc:interceptors>\n<bean class=\"com.pr.interceptor.AuditInterceptor\"/>\n</mvc:interceptors>\n//Java Configuration\n//in the @Configuration and @EnableWebMvc annotated class\n@Override\npublic void addInterceptors(InterceptorRegistry registry) {\nregistry.addInterceptor(auditInterceptor());\n}\n@Bean\npublic AuditInterceptor auditInterceptor(){\nreturn new AuditInterceptor();\n}\nThe schema in Figure 3-9 displays what happens “behind the scenes” when a handler interceptor is\nused in a Spring MVC application.\n108\nChapter 3 ■ Spring MVC\nFigure 3-9. Handler Interceptor methods and places where invoked\nView Technologies\nAgain, Spring MVC was designed to be as view agnostic as possible. Most web applications generate HTML\ncontent. The “ViewResolver” section mentions how a Spring web application can generate other types\nof content, such as PDF, Excel, or JSON. The complete list of view technologies that Spring supports is far\nlonger than this. To put it in perspective, anything that provides a ViewResolver and a View implementation\nis compatible with Spring.\nBased on the type of content being generated, the views can be categorized as follows:\n• Display views: The response is an HTML page generated using a template: JSP, Tiles,\nThymeleaf, FreeMarker, or Velocity.\n• File-generating views: The response is an output file when rendered and it is\nautomatically downloaded by the browser: Apache POI, JExcelApi (Excel), IText\n(PDF), JasperReports, or XSLT transformation.\n• Data-delivery views: The response is actually just data and it is meant to be used\nwith AJAX and web services: JSON, Java-XML Marshalling, Atom, and RSS.\nThis book covers Tiles and Thymeleaf. Tiles is in the official certification course. Thymeleaf is a bonus\nsection that was added because it is the newest template engine in the web development world (its “birth”\nyear was 2014) and it is quite a promising technology. Its goal is to provide templates that are easy to use and\nextend. It works in web and non-web environments.\n109\nChapter 3 ■ Spring MVC\n■ ! the book-code module 03-chapter-07-solution covers all three categories of the views mentioned.\ntake a look at it before advancing to the next section.\nTiles Layouts\nA web application of composed of more html pages which have a common structure, typically a header/\nfooter, a menu for navigation, and a section with the actual content of the page. The header, footer, and\nnavigation menu are usually the same on every page and they can separate from the contents of a page in\ntheir own files to be reused every time a new page is created. If you were working with JSP, the files header.\njsp, footer.jsp, and menu.jsp would be included in every page by using <jsp:include page=...\"/>.\nThis means three repetitive include statements in every page.\nA more practical approach is to create a page template that contains common page elements and\nplaceholders for dynamic content, similar to what is depicted in Figure 3-10. The placeholders are replaced\nat rendering time with whatever is needed (usually subviews).16\nFigure 3-10. Reusable page template\n16This approach is described by the Composite View pattern that introduces the notions of composite and atomic views.\nA composite view is a tree structure of atomic views. An atomic view can be included dynamically and it changes based\non the context.\n110\nChapter 3 ■ Spring MVC\nDoing this with only plain JSP is not an option. There are currently multiple ways available to do it. But\nthe one that was interesting for the Spring creators is Apache Tiles.\nApache Tiles is an open source template engine framework that was a part of the currently deceased\nApache Struts 1. It is based on the Composite View pattern and was built to simplify the development of user\ninterfaces. To use tiles in a Spring web application, you have to do the following:\n1. Define template layout for the pages.\n2. Configure tiles definitions in tiles.xml file(s).\n3. Configure the tiles resolver bean.\nApache Tiles 3.0.5, which is the version used for the code samples, is the most recent stable release at\nthe time this book was written.\nDefine Page Templates\nA simple template layout, matching the page representation in Figure 3-10, is as simple as this:\n...\n<%@ taglib prefix=\"tiles\" uri=\"http://tiles.apache.org/tags-tiles\" %>\n...\n<!-- /WEB-INF/templates/layout.jsp -->\n<head>\n<tiles:insertAttribute name=\"pageTitle\"/>\n</head>\n<body>\n<div class=\"header\">...</div>\n<div class=\"menu\">...</div>\n<div class=\"content\">\n<tiles:insertAttribute name=\"content\"/>\n</div>\n<div class=\"footer\">...</div>\n</body>\nConfigure Tiles Definitions\nThe tiles.xml files are Tiles configuration files, which define the structure of a page using XML. One or\nmore tiles definitions can be in the same file; it is recommended to store the configuration file and the pages\nconfigured in the same directory, as shown in Figure 3-11.\n111\nChapter 3 ■ Spring MVC\nFigure 3-11. Tiles configuration files and templates positioning in the application structure\nTiles definitions are reusable fragments consisting of a template and attributes. Inheritance is possible\nusing the extends attribute. A tile definition element looks like this:\n<!DOCTYPE tiles-definitions PUBLIC\n\"-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN\"\n\"http://tiles.apache.org/dtds/tiles-config_3_0.dtd\">\n<tiles-definitions>\n<definition name=\"layout\" template=\"/WEB-INF/templates/layout.jsp\"/>\n</tiles-definitions>\nThis example is called a base tile because every other definition extends it. Without this tile definition,\nevery other tile definition in your project has to be configured with the template attribute, underlined in the\npreceding example.\nThe extended version of the layout.jsp is quite big, and some parts are replaced by “...” . To view its real\nand full content, please see the 03-pr-mvc-layout-practice project.\n...\n<%@ taglib prefix=\"tiles\" uri=\"http://tiles.apache.org/tags-tiles\" %>\n...\n<!-- /WEB-INF/templates/layout.jsp -->\n<head>\n...\n112\nChapter 3 ■ Spring MVC\n<title>\n<spring:message>\n<tiles:insertAttribute name=\"pageTitle\"/>\n</spring:message>\n</title>\n</head>\n...\n<div class=\"page\">\n<!-- The header is actually a png image banner,\nthat will be loaded depending on the chosen theme-->\n<div class=\"banner\"></div>\n<!-- section to select Locale and Theme -->\n<div class=\"themeLocal\"> ...</div>\n<!-- section with the navigation menu, dynamic data\nThe menu item is modified to display the current page\nbased on the value for the menuTab attribute -->\n<div class=\"menu\">\n<ul>\n<li><c:if test=\"${menuTab eq 'home'}\">\n<strong>\n<a href=\"<c:url value=\"/\"/>\"><spring:message code=\"menu.home\"/></a>\n</strong>\n</c:if>\n<c:if test=\"${menuTab != 'home'}\">\n<a href=\"<c:url value=\"/\"/>\"><spring:message code=\"menu.home\"/></a>\n</c:if>\n</li>\n...\n</ul>\n</div>\n<!-- Dynamic data - body of the page -->\n<div class=\"content\">\n<tiles:insertAttribute name=\"content\"/>\n</div>\n<div class=\"footer\">\n<p><spring:message code=\"footer.text\"/></p>\n</div>\nThis is what a simple tile definition that extends the base tile looks like:\n<definition name=\"home\" extends=\"layout\">\n<put-attribute name=\"pageTitle\" value=\"home.title\"/>\n<put-attribute name=\"content\" value=\"/WEB-INF/home.jsp\"/>\n<put-attribute name=\"menuTab\" value=\"home\" />\n</definition>\n113\nChapter 3 ■ Spring MVC\nThe tiles attributes are the placeholders for dynamic data; the gaps in the template need to be filled.\nThe following can be an attribute:\n• A string that will be rendered or used as it is.\n• A template with or without attributes that need to be filled to render the page.\n• A tile definition with all (some) attributes filled.\n■ ?",
    "answer": "in the code sample, can you identify which of these types of tiles attributes were used? Accessing tiles attributes in JSP is done using the tag provided by tiles:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "<tiles:insertAttribute/>: The standard approach to insert the value of an\nattribute into a page17\n• <tiles:importAttribute/>: This is used to add attributes to model (it works only\nwith Spring)18\nIn the following example, the menuTab attribute is used for navigation in the application. Each tile\ndefinition sets a different value for that attribute. The value is tested and the menu navigation option\nmatching the current page is displayed in bold text.\n...\n<tiles:importAttribute name=\"menuTab\" />\n<c:if test=\"${menuTab eq 'home'}\">\n<!-- show the home menu option with bold text -->\n</c:if>\nConfigure the Tiles Resolver Bean\nSpring MVC provides out-of-the-box support for Apache Tiles. There is a TilesView to interpret logical\nview names as tiles definitions. There is a TilesViewResolver bean to resolve views and a class named\nTilesConfigurer to bootstrap Tiles with a set of configuration files.\n<!-- Resolves view names to Tiles 3 definitions -->\n<bean id=\"tilesViewResolver\"\nclass=\"org.springframework.web.servlet.view.tiles3.TilesViewResolver\"/>\n<!-- Configures Tiles 3 -->\n<bean id=\"tilesConfigurer\"\nclass=\"org.springframework.web.servlet.view.tiles3.TilesConfigurer\">\n<property name=\"definitions\">\n17Detailed API information on tiles:insertAttribute is at https://tiles.apache.org/framework/\ntiles-jsp/tlddoc/tiles/insertAttribute.html.\n18Detailed API information on tiles:importAttribute is at https://tiles.apache.org/framework/\ntiles-jsp/tlddoc/tiles/insertAttribute.html.\n114\nChapter 3 ■ Spring MVC\n<list>\n<value>/WEB-INF/tiles.xml</value>\n<!-- add more tiles definition files if present -->\n</list>\n</property>\n</bean>\nThe equivalent Java configuration looks like this:\n// In the @Configuration and @EnableMvc annotated class\n@Bean\nTilesViewResolver tilesViewResolver(){\nreturn new TilesViewResolver();\n}\n@Bean\nTilesConfigurer tilesConfigurer(){\nTilesConfigurer tilesConfigurer = new TilesConfigurer();\ntilesConfigurer.setDefinitions(\"/WEB-INF/tiles.xml\");\n// add more tiles definition files if present\nreturn tilesConfigurer;\n}\nThis code sample replaces the InternalResourceViewResolver with TilesViewResolver. The\nInternalResourceViewResolver can be configured for plain *.jsp files too, but do not forget to set the\norder property and/or configure a content negotiating resolver.\n■ ! the module 03-pr-mvc-layout-practice of the personal records Manager project covers tiles\ndefinitions and their usage with Spring MVC. Further details are presented in the practice section of this chapter,\nbut you can take a look at the 03-pr-mvc-layout-solution if you cannot wait to see the tiles in action.\nThymeleaf\nWhen asked why he decided to create another template engine, because there were already quite a few\navailable, co-creator Daniel Fernandez said this on the Thymeleaf official forum:19\nIn my humble opinion, Spring MVC 3 is a fantastic web framework tied to a horrible,\nextremely old and spaghetti-code-loving template engine: JSP. That’s why I wanted the\ncombination of Spring MVC with Thymeleaf to really shine. In some ways I suppose\nI wanted to give Spring MVC the template engine it deserved. Not from the performance\npoint of view (matching the speed of JSPs, which run in specialized containers, would be\nvery difficult), but more from the points of view of code elegance, readability, and design/\ncoding separation of concerns. Also, I wanted to provide first-class support for the emerging\nHTML5 standard.\n19A full discussion is at http://forum.thymeleaf.org/why-Thymeleaf-td3412902.html.\n115\nChapter 3 ■ Spring MVC\nThe underlined text in Fernandez’s reply should interest any developer. Thymeleaf is not a\ncertification exam subject, so it can be skipped. But Thymeleaf is nevertheless a practical alternative to JSP,\nand the SpringSource team fancies it quite a bit, so knowing how to configure it and use it could be useful in\nthe future.\nBoth Spring and Tiles come with an attribute set that you can use to write your page templates.\nThymeleaf is more flexible because it allows you to define a set of template attributes or even tags with the\nnames that you want and with the logic that you want. So it is not just a template engine, it is a framework.\nSomething called standard dialects are offered: Standard and SpringStandard, which contain all you might\nneed to create a page template. You can recognize them in a page because they are prefixed with \"th:\". The\ntwo dialects are almost identical, but the one created for Spring has additional capabilities for integrating\ninto Spring MVC applications (it supports SpEl , the Spring expression language).\nMost Thymeleaf attributes allow their values to be set as or containing expressions called Standard\nExpressions, which can be of the following types:\n• Variable expressions\n<td th:text=\"${person.firstName}\"></td>\n<!-- or -->\n<tr th:each=\"person : ${personList}\">\n• Selection or asterisk expressions: These are executed on a previously selected\nobject instead of the entire context variables map.\n<div th:object=\"${person}\">\n<p th:value=\"*{firstName} *{lastName}\"></p>\n</div>\n• Text externalized expressions (internationalization expressions) used to retrieve\nlocale specific messages from external sources (*.properties files). They even\naccept parameters.\n<tr>\n<td th:text=\"#{person.label.firstname} & #{person.label.lastname}</td>\n<!-- or -->\n<td th:text=\"#{person.created(${id})}\"</td>\n</tr>\n• URL expressions used to generate session- and context-specific URIs (equivalent to\n<spring:url/> and <c:url/>).\n<img alt=\"Simple tymeleaf application\" title=\"logo\"\nth:src=\"@{/images/banner.png}\"/>\n<form th:action=\"@{/createPerson}\">\n<a href=\"show.html\" th:href=\"@{/persons(id=${person.id})}\">\nThymeleaf allows HTML attributes so that templates can link to each other nicely when opened directly\nin a browser, outside the context of the application, in the same way that Thymeleaf attributes link to each\nother when executed in the context of a web application. In the previous example, if you want to view\nyour template before deploying the application, you can open the file in a browser and the th:href will be\nreplaced by the values of the static href.\n116\nChapter 3 ■ Spring MVC\nConsidering the following Thymeleaf template:\n...\n<h4>\nWelcome to the sample page with Spring MVC and Thymeleaf!\n<br/>\nHere is a list of random persons:\n</h4>\n<div class=\"content\" th:if=\"${not #lists.isEmpty(personList)}\">\n<table>\n<thead>\n<tr>\n<td>Cnt.</td>\n<td>First Name</td>\n<td>Last Name</td>\n</tr>\n</thead>\n<tbody>\n<tr th:each=\"person,iterationStatus : ${personList}\">\n<td><a th:text=\"${iterationStatus.count}\" href=\"show.html\"\nth:href=\"@{/persons(id=${person.id})}\">1</a></td>\n<td th:text=\"${person.firstName}\">John</td>\n<td th:text=\"${person.lastName}\">Smith</td>\n</tr>\n</tbody>\n</table>\n</div>\n...\nIn Figure 3-12 you can see what the page looks like when opened in the browser outside the application\ncontext.\nFigure 3-12. Thymeleaf template page opened in the browser outside the application context\n117\nChapter 3 ■ Spring MVC\nIn the application context, all the Thymeleaf expressions are resolved and the resulting page looks like\nthe one shown in Figure 3-13.\nFigure 3-13. Thymeleaf template page opened in the browser in the application context\nThe URL expression th:href=\"@{/persons(id=${person.id})} turns into a URL with a request\nparameter; for example, .../persons?",
    "answer": "id=4. To generate a URI, .../persons/4 the expression has to be modified to this: th:href=\"@{/persons/ ${person.id}__}\". The notions presented here are the minimum necessary to create a Thymeleaf simple template. The 03-chapter-08-solution module in the book-code project is a perfect example of how simple it is to create a Thymeleaf template to display a list of persons. All that is left now is to explain how Thymeleaf can be integrated with Spring. Thymeleaf integrates with both Spring 3.x and Spring 4.x and uses two separate libraries, which are packaged in separate *.jar files: thymeleaf-spring3-{version}.jar and thymeleaf-spring4-{version}. jar. As this book is being written, the most current version of Thymeleaf is 2.1.4.RELEASE. The library corresponding to the Spring version used needs to be added to the classpath together with the thymeleaf. jar. Thymeleaf offers a set of Spring integrations equivalent to the ones in JSP:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Spring SpEl can be used in Thymeleaf templates\n• It creates forms in templates that are completely integrated with form-backing beans\nand result hidings\n• It displays internationalization messages from message files managed by Spring via\nMessageSource\nTo integrate Thymeleaf with Spring, you need to define the following:\n• The view resolver bean of type ThymeleafViewResolver\n• The Thymeleaf engine bean of type SpringTemplateEngine used to handle the\nThymeleaf expressions\n• The template resolver bean of type ServletContextTemplateResolver used to\nconfigure the location and type of templates that the other beans are expected to\nwork with\n118\nChapter 3 ■ Spring MVC\n<bean id=\"templateResolver\"\nclass=\"org.thymeleaf.templateresolver.ServletContextTemplateResolver\">\n<property name=\"prefix\" value=\"/WEB-INF/persons/\" />\n<property name=\"suffix\" value=\".html\" />\n<property name=\"templateMode\" value=\"HTML5\" />\n<!-- Template cache is true by default. Set to false if you want -->\n<!-- templates to be automatically updated when modified. -->\n<property name=\"cacheable\" value=\"true\" />\n</bean>\n<bean class=\"org.thymeleaf.spring4.view.ThymeleafViewResolver\">\n<property name=\"templateEngine\" ref=\"templateEngine\" />\n<property name=\"order\" value=\"1\"/>\n</bean>\n<bean id=\"templateEngine\" class=\"org.thymeleaf.spring4.SpringTemplateEngine\">\n<property name=\"templateResolver\" ref=\"templateResolver\" />\n</bean>\nAnd this is all. If you would like to use Thymeleaf in your future projects, you can find all the\ninformation you need on their official site at http://www.thymeleaf.org. Also, before continuing to the next\nsection, you might want to run and take a look at the 03-chapter-08-solution module.\nForms\nStarting with version 2.0, Spring provides a set of specialized tags for handling form elements when using\nJSP and the Spring Web MVC. Each tag provides support for a set of attributes matching the ones in the\ncorresponding HTML element, which makes Spring quite easy for the user. The Spring tag library is\nintegrated into Spring MVC, which allows the tags to have access to the command object and model.\nThe Spring tag library is inside the spring-webmvc.jar. To use the tags in a JSP page, the following\ndirective must be added on top of the JSP page:\n<%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\nThe \"sf\" prefix is short for spring form. Any prefix can be used, but in this book, \"sf\" was chosen\nbecause it is short and its meaning is quite obvious. The \"spring\" prefix will be used for Spring-specific tags\nthat are not related to forms (internationalization and URL generation).\nIn the examples attached to this chapter, you create forms to edit and to search for a person. A form for\nediting a person is depicted in Figure 3-14.\n119\nChapter 3 ■ Spring MVC\nFigure 3-14. Form used to edit a Person\nThe Spring form tag library provides equivalent elements for the HTML elements needed to design a\nform, annotations for data binding and data validation, and tools for error processing. The code that creates\nform follows Figure 3-14.\n...\n<%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\n<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %>\n...\n<div class=\"person\">\n<spring:url value=\"/persons/{id}\" var=\"editUrl\">\n<spring:param name=\"id\" value=\"${person.id}\"/>\n</spring:url>\n<sf:form modelAttribute=\"person\" action=\"${editUrl}\" method=\"POST\">\n<table>\n<tr>\n<th>\n<label for=\"firstName\">\n<span class=\"man\">*</span>\n<spring:message code=\"label.Person.firstname\"/> :\n</label>\n</th>\n<td><sf:input path=\"firstName\"/>\n<sf:errors cssClass=\"error\" path=\"firstName\"/></td>\n</tr>\n...\n<tr>\n<th>\n<label for=\"dateOfBirth\">\n<span class=\"man\">*</span>\n<spring:message code=\"label.Person.dob\"/> :\n</label>\n</th>\n120\nChapter 3 ■ Spring MVC\n<td><sf:input path=\"dateOfBirth\"/>\n<sf:errors cssClass=\"error\" path=\"dateOfBirth\"/></td>\n</tr>\n<tr>\n<th>\n<label for=\"gender\">\n<spring:message code=\"label.Person.gender\"/> :\n</label>\n</th>\n<td>\n<sf:radiobutton path=\"gender\" value=\"MALE\"/>\n<spring:message code=\"label.Person.male\"/>\n<sf:radiobutton path=\"gender\" value=\"FEMALE\"/>\n<spring:message code=\"label.Person.female\"/>\n</td>\n</tr>\n<tr>\n<th>\n<label for=\"hospital\">\n<span class=\"man\">*</span>\n<spring:message code=\"label.Hospital\"/> :\n</label>\n</th>\n<td>\n<sf:select path=\"hospital\">\n<c:choose>\n<c:when test=\"${person == null}\">\n<sf:option value=\"\">\n<spring:message code=\"label.choose\"/></sf:option>\n</c:when>\n<c:otherwise>\n<sf:option value=\"${person.hospital.id}\">\n${person.hospital.name}\n</sf:option>\n</c:otherwise>\n</c:choose>\n<sf:options items=\"${hospitalList}\"\nitemValue=\"id\" itemLabel=\"name\"/>\n</sf:select>\n</td>\n</tr>\n<tr>\n<td>\n<button id=\"saveButton\" type=\"submit\">\n<spring:message code=\"command.save\"/>\n</button>\n</td>\n121\nChapter 3 ■ Spring MVC\n<td>\n<a href=\"${editUrl}\">\n<spring:message code=\"command.cancel\"/>\n</a>\n</td>\n</tr>\n</table>\n</sf:form>\n</div>\nIn the previous code there are a few elements that are underlined. They are Spring form tags equivalent\nto HTML form tags. The only difference is that they are fully integrated with Spring MVC and their content\nis populated from the modelAttribute and other Spring form–specific objects, which are covered a little\nbit later.\nThe behavior of a Spring form can be described using this succession of steps:\n1. An initial GET request causes the form object to be created and presented\nto the user.\n2. The user inserts data in the form and sends a POST request to submit the form.\nIn this step, the data inserted is evaluated, validated, and stored in the form\nobject.\n3. POST-Redirect-GET if the operation is successful (if the objective of the POST\nrequest has succeeded, a GET request is created to present a confirmation\nmessage to the user).\nWithout the POST-Redirect-GET behavior, an application will behave incorrectly, because subsequent\nPOST requests could lead to duplicate data and/or data corruption. The forms used for search operations\ndo not need a POST request, because submitting a search query has no side effects and it redirects to the\nresults page.\nWhen working with forms, all the fields in a form should map to the fields of an object called a data\ntransfer object (DTO). In the example, this is done for the Search Person form, which is covered later. When\nediting a person, it is more suitable to use a Person object as a data transfer object. The Person object\nis an instance of an @Entity class, and maps to a row in the person table in the database. These types of\nobjects are called domain objects. This requires that the object used for this purpose should have a default\nconstructor, getters, and setters for all the fields used in the form. Although using a domain object as a form\nobject welcomes the undesired possibility that some web logic–specific operations might creep in, it is\npractical to use when the objects handled are simple20 and entity fields are annotated with specific validation\nannotations (example: @NotEmpty, NotNull, etc.), because implementing a validator class at the web layer\nmay no longer be necessary.\nForm-specific data transfer objects are also required when the information from a form is aggregated\nfrom multiple domain objects. This allows the form object to encapsulate only what is needed to be\ndisplayed on the screen: web layer logic, validation logic, logic for information transfer between the form\nobject, and domain object.\nFigure 3-15 shows the correspondence between the form tags and the fields in the CriteriaDto object.\n20Adam Bien, one of the most respected Java developers in the world, has named DTOs objects “anemic in general and\ndo not contain any business logic” on his blog at http://www.adam-bien.com/roller/ abien/entry/\nvalue_object_vs_data_transfer.\n122\nChapter 3 ■ Spring MVC\nFigure 3-15. Form to search a Person\nThe following can be said when using Spring forms:\n• The CriteriaDto object is linked to the form via modelAttribute=\"criteriaDto\"\nand it corresponds to the @ModelAttribute annotated object in the controller class.\n• The Spring form has a method attribute the same as an HTML form, and the value of\nthis attribute is the type of request being sent to the server.\n<sf:form action=\"${personsUrl}\" modelAttribute=\"criteriaDto\" method=\"get\">\n....\n</sf:form>\n• The Spring form has an action attribute the same as an HTML form, and the value of\nthis attribute is the URL of the request.\n<spring:url value=\"/persons/go\" var=\"personsUrl\"/>\n<sf:form action=\"${personsUrl}\" modelAttribute=\"criteriaDto\" method=\"get\">\n....\n</sf:form>\n• <sf:input path=\"fieldName\"/> is rendered into an HTML input field that is\npopulated with the value of the field named fieldName in the criteriaDto object.\nEach of the fields defined in a Spring form specifies a path attribute that corresponds\nto a getter/setter method of the model attribute (in this case the CriteriaDto\nobject). When the page is loaded, Spring calls the getter of each field to populate\nthe form view. When the form is submitted, the setters are called to save the values\nsubmitted by the user using the form to the model attribute fields.\n• <sf:select/> elements are rendered into HTML select elements and can be\nconstructed using domain object lists:\n<sf:select path=\"hospital\" itemValue=\"id\" itemLabel=\"name\"\nitems=\"${hospitalList}\"/>\n123\nChapter 3 ■ Spring MVC\nThe hospitalList has to be added to the model by the controller as an attribute:\nmodel.addAttribute(\"hospitalList\", hospitalRepo.findAll());\n• <sf:select/> elements can have customized behavior by using the <sf:option/>\nand <sf:options/> tag.\nFor example, if the same form is used for editing and creating a person instance, when a new person is\ncreated, you might want to display a default option in the hospital drop-down list, making it obvious for the\nuser that a value has to be selected. That default option is not part of the hospital list model attribute. When\na person is edited, you want to select the hospital where that person was born.\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n....\n<sf:select path=\"hospital\">\n<c:choose>\n<!-- no person attribute, form is used to create a person -->\n<c:when test=\"${person == null}\">\n<sf:option value=\"\">\n<!-- default option not in the hospital list model attribute -->\n<spring:message code='label.choose'/>\n</sf:option>\n</c:when>\n<!-- form is used to edit a person, person model attribute is set -->\n<c:otherwise>\n<sf:option value=\"${person.hospital.id}\">\n${person.hospital.name}\n</sf:option>\n</c:otherwise>\n</c:choose>\n<!-- Dynamic list of options -->\n<sf:options items=\"${hospitalList}\" itemValue=\"id\" itemLabel=\"name\"/>\n</sf:select>\nThe preceding example is rendered as an HTML select element containing all hospitals in the\nhospitalList model attribute and an extra static Choose hospital option when the form is used to create a\nperson. The names of the hospitals are used as labels for the available options in the select element. The JSP\nc taglib is used for conditional operations.\n• The Spring JSP tag library integrates nicely with other JSP libraries, like\nTiles and JSTL.\n• The <sf:errors/> is a Spring special tag for displaying errors. The error messages\ncan be internationalized; this is covered in the “Data Validation” section.\nWhen it comes to using Spring forms, three key subjects must be well understood to use them like\nan expert: formatting, data binding, and validation; each of these is given the proper coverage in its own\nsection.\n124\nChapter 3 ■ Spring MVC\nData Formatting\nIn the Person edit form, you need to display and eventually edit a java.util.Date instance and a Hospital\ninstance. These are complex types and the Spring tag library does not know how to handle them on its\nown. The developer must provide implementations for the org.springframework.format.Formatter<T>\ninterface for the specific type of object handled in the form. Formatter classes parse text data, turn them into\nobjects, and transform beans into text data ready for rendering. In the 05-pr-mvc-form-solution module,\nwhich is the project specific to this section, two formatters are used in the Edit person form; where they are\nused is shown in Figure 3-16.\nFigure 3-16. Formatters used in the form to edit a person\nFormatters can be used in four places in the application:\n• On the field using annotations (all JSPs pages displaying this annotation use this\nformatter)\n@DateTimeFormat(pattern = \"yyyy-MM-dd\")\nprivate Date dateOfBirth;\n• In the JSP tags (used when multiple JSP pages need to display data differently)\n<fmt:formatDate value=\"${person.dateOfBirth}\" pattern=\"yyyy-MM-dd\" />\n• Registered in the application using the FormattingConversionServiceFactoryBean bean\n<mvc:annotation-driven conversion-service=\"typeConversionService\" \"/>\n<!-- Define a custom ConversionService -->\n<bean id=\"typeConversionService\"\nclass=\"o.s.format.support.FormattingConversionServiceFactoryBean\">\n<property name=\"formatters\">\n<set>\n<bean class=\"com.pr.util.DateFormatter\"/>\n<bean class=\"com.pr.util.HospitalFormatter\"/>\n</set>\n</property>\n</bean>\n125\nChapter 3 ■ Spring MVC\nThe DateFormatter implementation used in the personal-records project looks like this:\npublic class DateFormatter implements Formatter<Date>{\npublic static final SimpleDateFormat formatter =\nnew SimpleDateFormat(\"yyyy-MM-dd\");\n@Override\npublic Date parse(String s, Locale locale) throws ParseException {\nreturn formatter.parse(s);\n}\n@Override\npublic String print(Date date, Locale locale) {\nreturn formatter.format(date);\n}\n}\n• On the controller or service method arguments by using implementation of the org.\nspringframework.validation.Validator interface and the @Validated annotation.\nIn the following example, the URI path variable used to request data about a person\nis of type String and it has to be checked for whether it represents a valid id.\n@Component\npublic class IdValidator implements Validator {\n@Override\npublic boolean supports(Class<?",
    "answer": "> clazz) { return String.class.equals(clazz); } @Override public void validate(Object target, Errors errors) { String id = (String) target; if(!id.matches(\"/{id:\\\\d*}\")) { errors.reject(\"id.malformed\"); } } } The controller method to retrieve a person’s data and using that validator looks like this: @RequestMapping(value = \"/{id}\", method = RequestMethod.GET) public String show(@Validated(IdValidator.class)@PathVariable String id, Model model) throws NotFoundException { Long theId = Long.parseLong(id); Person person = personManager.findById(theId); if(person == null) { throw new NotFoundException(Person.class, theId); } model.addAttribute(\"person\", person); return \"persons/show\"; } 126 Chapter 3 ■ Spring MVC In the examples in this book, only Date and Hospital formatters are covered because they are the only ones needed in the associated projects, but any complex field type can have a formatter. For example:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "formatting numbers:\n@NumberFormat(style=Style.NUMBER, pattern=\"#,###.###\")\nprivate final BigDecimal amount;\n• formatting currencies:\n@NumberFormat(style=Style.CURRENCY)\nprivate final BigDecimal amount;\nWhen field values are formatted inside a JSP page, formatting annotations are no longer needed. When\nformatters are registered using the FormattingConversionServiceFactoryBean bean, the specific types are\nautomatically converted without another annotation or tag.\nThe <mvc:annotation-driven/> and @EnableWebMVC registers default formatters for Numbers and\nDates by offering support for specific annotations: @NumberFormat and @DateTimeFormat. If Joda Time is in\nthe classpath, support for it is also enabled.\nJava configuration to register custom formatters can be done in two ways: by defining a @Bean of type\nConversionService, or by implementing the addFormatters method defined in WebMvcConfigurer\n(or by overriding it when implementations of this interface are used).\nThe second way is easier:\n\\\\in the @Configuration & @EnableWebMvc annotated class\n@Override\npublic void addFormatters(FormatterRegistry formatterRegistry)\n{\nformatterRegistry.addFormatter(getDateFormatter());\nformatterRegistry.addFormatter(getHospitalFormatter());\n}\n@Bean\npublic DateFormatter getDateFormatter(){\nreturn new DateFormatter();\n}\n@Bean\npublic HospitalFormatter getHospitalFormatter(){\nreturn new HospitalFormatter();\n}\nThe first way is more complicated. The following is an example of an annotated ConversionService\nbean definition:\n\\\\ in the @Configuration annotated class\npublic ConversionService conversionService() {\nFormattingConversionServiceFactoryBean bean =\nnew FormattingConversionServiceFactoryBean();\nbean.setFormatters(getFormatters());\nbean.afterPropertiesSet();\nConversionService object = bean.getObject();\nreturn object;\n}\n127\nChapter 3 ■ Spring MVC\nprivate Set<Formatter> getFormatters() {\nSet<Formatter> formatters = new HashSet<>();\nformatters.add(dateFormatter);\nformatters.add(dateFormatter);\nreturn formatters;\n}\n// definition for formatter beans as in the previous example\nNow you have the conversionService bean. Let’s look at the equivalent for <mvc:annotation-driven\nconversion-service=\"conversionService\" />:\n@FeatureConfiguration\nclass MvcFeatures {\n@Feature\npublic MvcAnnotationDriven annotationDriven(\nConversionService conversionService) {\nreturn new MvcAnnotationDriven().conversionService(conversionService)\n}\n...\n}\nMvcAnnotationDriven provides the same options as the XML elements using a conveniently chained\nmethod API. But who needs a complicated way to do this when there is an easier way, right?",
    "answer": "HospitalFormatter is a custom formatter specifically created to be used in projects attached to this book. It basically transforms a Hospital instance into its name so that it can be rendered in a view. And it takes a hospital id and retrieves the Hospital instance from the database to be returned to the controller, where it is used further. As the HospitalFormatter is a bean like any other, the HospitalManager bean can be injected into it to make this happen. So the custom implementation looks like this: public class HospitalFormatter implements Formatter<Hospital> { @Autowired HospitalManager hospitalManager; @Override public Hospital parse(String text, Locale locale) throws ParseException { Long id = Long.parseLong(text); return hospitalManager.findOne(id); } @Override public String print(Hospital hospital, Locale locale) { return hospital.getName(); } } 128 Chapter 3 ■ Spring MVC Data Binding Form objects, data transfer objects, and domain objects have been mentioned so far. But how are they linked together? How does the information from a form object get transferred to a data transfer object or to a domain object? How does Spring MVC know how to do this? The answer to these three questions is a process named data binding. Spring MVC binds the request to the form object. When a form is submitted, string data is transformed into objects that are injected into the form object using getters and setters. A POST request or form submission means setters for the form model attribute are called. A GET or page/form load means getters are called upon the form model attribute to populate the view. Each object is identified using the path attribute value in the corresponding Spring element tag. The form object it tightly bound to the JSP page, and if the form object cannot be created, the JSP page won’t be rendered correctly. The form object is linked to the JSP page using the modelAttribute attribute in the <sf:form/> tag: <sf:form modelAttribute=\"person\" action=\"${editUrl}\" method=\"POST\"> ... </sf:form> In the controller, the form object can be accessed in multiple ways. It can be received as an argument to the method mapped to the ${editUrl}. @Controller public class PersonsController { @RequestMapping(method=RequestMethod.POST) public String update(Person person) { ... } In this case, data is copied automatically into the object, and the object is re-created on every request. You can annotate the form object with the @ModelAttribute annotation. @Controller public class PersonsController { @RequestMapping(method=RequestMethod.POST) public String edit(@ModelAttribute(\"person\") Person person) { ... } ■ CC When the name of the modelAttribute is the same as the name of the argument in a handler method, the value for @ModelAttribute can be skipped. So in the previous case, public String update (@ModelAttribute(\"person\") Person person) is equivalent to public String update(@ModelAttribute Person person). This annotation was mentioned in the “Redirecting” section; it can be used the same way for forms too, because in this case, you have a controller that handles the edit and show requests for a person instance. @ModelAttribute annotated methods are executed before the chosen @RequestMapping annotated handler method. They effectively pre-populate the implicit model with specific attributes, in this case, the person instance to be displayed or edited. 129 Chapter 3 ■ Spring MVC So you can simplify the controller like this: @Controller @RequestMapping(\"/persons/{id}\") public class PersonsController { @ModelAttribute public Person findPerson(@PathVariable Long id) { return personManager.findOne(id); } @RequestMapping(method = RequestMethod.GET) public String show() { return \"persons/show\"; } @RequestMapping(value=\"/edit\", method = RequestMethod.GET) public String edit(Model model) { //we add the hospitalList to show in the Hospital drop-down list model.addAttribute(hospitalRepo.findAll()); return \"persons/edit\"; } @RequestMapping(method = RequestMethod.POST) public String save(Person person, BindingResult result, Model model) { if (result.hasErrors()) { // we need to add this here as the dropdown list // has to be populated correctly // and \"hospitalList\" is not a model attribute model.addAttribute(hospitalRepo.findAll()); return \"persons/edit\"; } personManager.save(person); return \"redirect:/persons/\".concat(person.getId()); } } In this implementation, you do not have to concern yourself with the existence of the form object because the methods of this controller are only accessible when the URL is constructed with a valid person id. By default, all fields in a form are binded to the form object, but Spring MVC offers the possibility to modify the default behavior by customizing a WebDataBinder object. Some fields can be blacklisted or whitelisted for the binding process: @InitBinder public void initBinder(WebDataBinder binder) { //allowed fields binder.setAllowedFields(\"firstName\", \"lastName\"); //disallowed fields binder.setDisallowedFields(\"pk\", \"*Pk\"); } 130 Chapter 3 ■ Spring MVC The recommended behavior is to whitelist only the necessary fields, even if there might be a lot of them to minimize the security holes. The validation errors are binded to the form object too using a BindingResult object. @RequestMapping(method = RequestMethod.POST) public String save(@Valid Person person, BindingResult result, Model model) { if (result.hasErrors()) { return \"persons/edit\"; } ... } If you look at the beginning of this section, where the Edit person form code is, you see that some elements look like this: <sf:errors cssClass=\"error\" path=\"dateOfBirth\"/></td> They are right next to their analogue elements: <sf:input path=\"dateOfBirth\"/> And they have the exact path attribute value. These elements are used to display validation errors when the POST handler method returns back to the edit view because the BindingResult object was populated by an existing validator bean. When returning to the form, the submitted data is still there, but there is extra information about the state and condition of the submitted data, something more or less like what you see in Figure 3-17. Figure 3-17. Spring default validation errors displayed after a form failed submission 131 Chapter 3 ■ Spring MVC Spring MVC has its own validator messages, but supports externally provided validator messages too. Data binding error messages can be customized and internationalized. The following are some examples; depending on the validation library used, the message keys could be different: NotEmpty.person.firstName=Please insert First Name Value Size.person.firstName=Length must be between {2} and {1} typeMismatch.dateOfBirth=Invalid format, should be \\'yyyy-mm-dd\\' typeMismatch.amount=Incorrect amount And after the customization, when a submit fails, the invalidated form looks like what’s shown in Figure 3-18. Figure 3-18. Customized validation errors displayed after a form failed submission Data Validation Spring MVC supports JSR 303/349 Bean Validation for validating form objects. If the library javax. validation:validation-api:[version] is in the classpath and the application is configured using <mvc:annotation-driven/> or @EnableWebMvc, it is automatically detected and enabled. Spring 4+ also supports Hibernate Validator 4.3+, but for the org.hibernate:hibernate- validator:[version] library to be used, a custom validator that implements org.springframework. validation.Validator must be set in the configuration; for example: <!-- Enables hibernate validator --> <bean id=\"validator\" class=\"o.s.validation.beanvalidation.LocalValidatorFactoryBean\"/> <!-- Defines basic MVC defaults (handler adapter, mapping, date formatting, etc) --> <mvc:annotation-driven validator=\"validator\"/> The Hibernate Validator is an extension of the default set of validation annotations provided by the validation-api library, that’s why when using Hibernate Validator, validation-api is enabled by default, as validation-api is a dependency of the Hibernate Validator. 132 Chapter 3 ■ Spring MVC ■ ! to depict this, a special gradle task was created for you in the 00-pr-dao module: allCompileDeps. When executed, gradle prints the dependency tree for the 00-pr-dao module in the intellij iDea console. if you analyze the output, you will find the following snippet. +--- org.hibernate:hibernate-validator:5.1.3.Final | +--- javax.validation:validation-api:1.1.0.Final | +--- org.jboss.logging:jboss-logging:3.1.3.GA | \\--- com.fasterxml:classmate:1.0.0 The following are examples of validation annotations:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "@NotNull: Field cannot be null\n• @Size (min, max): File must have a length in the range (min, max)\n• @Pattern: String not null and matching\n• @NotEmpty: String must not be empty (Hibernate)\n• @Min(val), @Max(val): String must be of length at least minimum,\nor maximum in size\nThey are used on the fields of interest in the domain object or data transfer object:\npublic class Person extends AbstractEntity {\n@Size(min=2, max=50)\npublic String firstName;\n@Size(min=2, max=50)\npublic String lastName;\n@NotNull\n// comment the following if a custom formatter is registered\n@DateTimeFormat(pattern = \"yyyy-MM-dd\")\nprivate Date dateOfBirth;\n...\n}\nThe validation is invoked by annotating the form object with @Valid and the errors are registered in the\nBindingResult object too, alongside the binding errors.\nIn the JSP form, the way the errors are displayed can also be customized. In the previous section, each\nerror was mapped to its field, but you can also print all the errors in the same place by using the following\nsyntax:\n<sf:form modelAttribute=\"person\">\n<form:errors path=\"*\"/>\n...\n</sf:form>\nThis approach is not recommended for big forms. It is also quite annoying for the user to have to search\nfor the form field he has to correct. By linking the error to the form field, it becomes quite obvious where the\ncorrection must be applied.\n133\nChapter 3 ■ Spring MVC\nThe Hibernate Validator contains its own set of internationalization files with default internationalized\nmessages. The Resource bundle is named ValidationMessages; it is located in the hibernate-valdiator.jar\nunder the org.hibernate.validator package. You can expand the hibernate-validator.jar and look at it\ncontents in Intellij IDEA, as shown in Figure 3-19.\nFigure 3-19. Contents of the hibernate-validator.jar\nThe message keys in the ValidationMessages.properties files are the message keys set by default in the\ndefinition of each annotation. For example, the following is a snippet of code for the @NotEmpty annotation:\n@Constraint(validatedBy = { })\n@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })\n@Retention(RUNTIME)\n@ReportAsSingleViolation\n@NotNull\n@Size(min = 1)\npublic @interface NotEmpty {\nString message() default \"{org.hibernate.validator.constraints.NotEmpty.message}\";\n...\n}\nFor every field that fails, the @NotEmpty validation has the default error message printed next to it\n(if configured so), read from the Hibernate Validator resource bundle files. These messages can be\noverridden by creating your own ValidationMessages resource bundle in the classpath of the project. Also,\nthe message keys can be customized by making the new message key a parameter for the message property\nwhen using the annotation; this allows specific messages to be displayed when the same annotation is used\non different fields:\n// in the Person entity class\n@NotEmpty(message=\"lastname.notempty\")\npublic String lastName;\n#in the ValidationMessages.properties\nlastname.notempty=Lastname cannot be empty!\n134\nChapter 3 ■ Spring MVC\nWhen using Spring forms, the error messages can be part of the application resource bundle under\nWEB-INF\\messages; the message keys usually respect the following template:\nconstraintName.modelAttributeName.propertyName\nEach part of the Spring message key is linked to elements in the application, as depicted in Figure 3-20.\nFigure 3-20. Spring message keys and linked elements\nThe message samples at the end of the previous section include customized validation messages, used\nin the 05-pr-mvc-form-practice and solution modules.\nSpring also supports the JEE @Constraint21 annotation, which can be used to define customized\nvalidation annotations.\n// Pnc.java\n@Constraint(validatedBy = [PncValidator.class])\n@Target( { ElementType.METHOD, ElementType.FIELD })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pnc {\n//using specific message key\nString message() default \"{pncFormatExpected}\";\nClass<?",
    "answer": ">[] groups() default {}; } 21See http://docs.oracle.com/javaee/7/api/javax/validation/Constraint.html. 135 Chapter 3 ■ Spring MVC //In PncValidator.java public class PncValidator implements ConstraintValidator<Pnc, String> { @Override public void initialize(Pnc constraintAnnotation) { // nothing to initialize } @Override public boolean isValid(String value, ConstraintValidatorContext context) { return (value == null) || value.matches(\"[1-2][0-9]*\"); } } // In Resouce bundle global.properties files pncFormatExpected= A valid Personal Numerical Code is required! // Usage in IdentityCard.java public class IdentityCard extends AbstractEntity { ... @Pnc private String pnc; ... } Or the org.springframework.validation.Validator interface can be implemented to provide a custom validator implementation, which can be specific to a controller and can be set using @InitBinder: class PncValidator extends Validator { public void validate(Object target, Errors errors) { if ((Person)target) .identityCard.pnc.matches(\"[1-2][0-9]*\") ) errors.rejectValue(\"pnc\", \"pncFormatExpected\"); } public boolean supports(Class<?> clazz) { return clazz instanceof Person.class; } } @InitBinder public void initBinder(WebDataBinder binder) { binder.setValidator(new PncValidator()); } 136 Chapter 3 ■ Spring MVC Or a validation method can be implemented directly into the data transfer object and called from the controller: public class CriteriaDto { public void validate(Errors errors) { if (fieldValue == null || fieldValue.isEmpty()) errors.rejectValue(\"fieldValue\", \"valueExpected\"); } } ... @RequestMapping(method=RequestMethod.Get) public String search(CriteriaDto criteriaDto, BindingResult result) { criteriaDto.validate(result); // process failure or success normally ... } Managing the Form Object Using a form implies multiple requests, which means that the form object has to be the same across two or more requests (when validations fail, for example). There are more ways to manage the form object:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "How do you chain ViewResolvers to support multiple view types in a single\napplication?",
    "answer": "types for the same resource?",
    "source": "extracted",
    "confidence": 0.28
  },
  {
    "question": "How do you create a Spring form?",
    "answer": "validate data handled by the form?",
    "source": "extracted",
    "confidence": 0.34
  },
  {
    "question": "How does data binding work?",
    "answer": "138 Chapter 3 ■ Spring MVC Quick Quiz Question 1: Considering the following configuration in web.xml, what is the name of the parameter that holds the location of the Spring MVC configuration file? <servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class>o.s.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>?????</param-name> <param-value> /WEB-INF/spring/mvc-config.xml </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> A. contextListener B. configurationLocation C. contextConfigLocation Question 2: Considering the following configuration in web.xml, what is the name of the parameter that points to the Spring infrastructure bean that enables Java configuration? <servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class>o.s.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>???</param-name> <param-value> o.s.web.context.support.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> 139 Chapter 3 ■ Spring MVC A. contextClass B. configClassLocation C. contextConfigLocation D. contextClassName Question 3: In web.xml, the servlet name has been configured to mvc-dispatcher. What is the default name of the MVC configuration file that Spring looks for? A. mvc-config.xml B. mvc-dispatcher.xml C. mvc-dispatcher-servlet.xml Question 4: As a developer, what do you need to do to configure Spring Web MVC application without using an web.xml file ? A. Extend the AbstractDispatcherServletInitializer class and override at least createServletApplicationContext and getServletMappings. B. Extend the AbstractAnnotationConfigDispatcherServletInitializer class and override at least getServletConfigClasses and getServletMappings. C. Implement WebApplicationInitializer. D. Extend WebApplicationInitializer and annotate the class with @ EnableWebMvc. Question 5: Which of the following are Spring MVC infrastructure components? A. Validator implementations B. HandlerAdapter implementations C. HandlerMapping implementations D. ControllerAdvice implementations Question 6: The purpose of HandlerMapping implementations is to map incoming requests to the appropriate handlers and a list of pre- and post-processor interceptors. Is this statement true? A. Yes B. No Question 7: RequestMappingHandlerMapping is registered by default when the following configuration style is used for a Spring web application: A. XML configuration using the MVC namespace specific element <mvc:annotation-driven/> B. Java configuration using a configuration class annotated with @EnableWebMVC 140 Chapter 3 ■ Spring MVC Question 8: What are the key interfaces used by Spring to render responses without tying itself to a specific view technology? A. View B. ViewResolver C. ViewConfigurer Question 9: Which of the following is an out-of-the-box view technology supported by Spring? A. JSP B. Thymeleaf C. Velocity templates D. XSLT E. Tiles Question 10: What is the default ViewResolver implementation configured by Spring? A. InternalResourceViewResolver B. JspResourceViewResolver C. UrlBasedViewResolver D. BeanNameViewResolver Question 11: What is the difference between chaining ViewResolver beans and content-type negotiation? A. There is no difference. B. View Resolver chaining allows supporting multiple view types in a single application. C. Content-type negotiation allows support for multiple view types for the same resource. Question 12: What is true about the HTTP Accept header? A. It can be used in a Spring Web MVC application to decide the view type for a resource only when the client is a browser. B. It is used for REST web services. C. It is useless when the client is a browser. D. It can be taken into consideration by setting a value for the ignoreAcceptHeader property in the ContentNegotiatingViewResolver bean. Question 13: From the following list, select the Spring infrastructure bean types responsible with application personalization: A. MessageSource implementations B. LocaleChangeInterceptor C. LocaleResolver implementations D. ThemeResolver implementations 141 Chapter 3 ■ Spring MVC Question 14: What is true about the @ExceptionHandler and @ControllerAdvice annotations? A. They are used for handling exceptions thrown by controller methods. B. When a method inside a controller is annotated with @ExceptionHandler, this method handles the exceptions thrown only in that controller. C. @ControllerAdvice is used at class level; in addition to @ExceptionHandler annotated methods, this class can define other types of methods. Question 15: Given the following controller, to what request will the call method be mapped to? @Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(\"/list\") public String call(Model model,HttpServletRequest rq) { ... } } A. http://localhost:8080/persons B. http://localhost:8080/persons/list C. http://localhost:8080/persons/call Question 16: Given the following controller, is the declaration of the show method correct? @Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(\"/{id}\") public String show(@PathVariable String number, Model model) { ... } } A. Yes B. No Question 17: What of the following is something that a Spring MVC handler method could not return? A. a string B. a Model C. a ModelAndView D. a JstlView instance E. a null value 142 Chapter 3 ■ Spring MVC Question 18: Which of the following statements regarding annotation-based configuration are true? A. Annotating a class with Controller is not enough for that class to handle requests; the class also has to extend Spring’s AbstractController class. B. @RequestMapping is both used at class and method level. C. To enable auto-detection of controller classes, you have to enable component scanning in your configuration. D. @ModelAttribute can only be used to annotate controller method arguments. Question 19: What is true about @ModelAttribute ? A. This annotation is used to bind a method parameter or method return value to a named model attribute, exposed to a web view. B. If a method is annotated with it, that method will be executed before handling any request. C. This annotation is used to bind a form object to a controller. Question 20: What is @InitBinder used for? A. To initialize a controller. B. To mark a method that initializes the WebDataBinder, which is used to populate command and form object arguments of annotated handler methods. C. To mark a method for execution before handling any request. Question 21: Which is true when a new view technology is added to a Spring web application? A. The view technology in question must provide a class implementing Spring’s View interface. B. The view technology in question must provide a class implementing Spring’s ViewResolver interface. C. The view technology must require specific configuration beans to be defined. Question 22: When working with Spring forms, which is the recommended workflow? A. A GET request is made to display the form, a POST request is made to submit the data, and a GET request is made to display a confirmation page and prevent multiple resubmissions. B. A GET request is made to display the form, and a POST request is made to submit the data. Question 23: Given the following Spring form definition, what is wrong with it? <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> ... <sf:form action=\"${personsUrl}\" method=\"GET\"> ... </sf:form> 143 Chapter 3 ■ Spring MVC A. The method of a form cannot be GET. B. The modelAttribute is missing. C. The <%@ taglib prefix=\"spring\" uri=\"http://www.springframework. org/tags\" %> is missing Question 24: Does Spring MVC support validation of form data? A. Yes B. No Question 25: Which of the following are validation annotations used on form object fields? A. @NotNull B. @Size C. @Valid D. @NotEmpty E. @Constraint F. @Required G. @Pattern Practical Exercise This chapter is quite big, so it has four module projects associated with it and each of the modules covers a specific section. Figure 3-21 depicts the eight module projects attached to this chapter: four practice projects and four proposed solutions for them. You are welcome to analyze the proposed solutions and compare them to your solutions to test your understanding of Spring MVC. Figure 3-21. Practice projects for Chapter 3 144 Chapter 3 ■ Spring MVC All web modules depend on the 01-pr-service module. This project contains the @Service classes and the repositories used to manage data. The 01-pr-service depends on the 00-pr-dao module that contains entity classes and common classes (formatters, enums, and utility classes) used by all other modules. The service module was created to respect the standardized three-tiered software architecture pattern, depicted in Figure 3-22. Each tier has a specific responsibility:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The data tier is the data access layer that usually encapsulates persistence\nmechanisms and exposes the data. It should provide an application programming\ninterface (API) to the logic tier that exposes methods of managing the stored data\nwithout exposing or creating dependencies on the data storage mechanisms.22\n• The logic tier (also known as the service layer) controls an application’s functionality\nby performing detailed processing. This tier is needed when the application needs to\nbe accessed by different type of clients (browsers, web services, etc.).\n• The presentation layer is the topmost level of the application that users can directly\naccess, such as a web page or a desktop GUI.\nFigure 3-22. Typical standardized three-tiered architecture\n22In the PErsonal REcords Manager project, because Spring DATA JPA is used, the implementation of the repositories\nAPI is reduced to interfaces extending the JpaRepository interface. They are placed in the logic tier/service layer.\n145\nChapter 3 ■ Spring MVC\nBecause the Personal Records Manager is quite a small project, the service classes do not do much\nbesides calling analogous methods form repository beans.\nThe HospitalFormatter is part of the 01-pr-service module because it needs a manager instance to\nretrieve the hospital instance from the repository.\nThe DBInitializer class is also located in the service class; it is used to populate the database with\nsome sample entries when a web application starts. This class is a simple bean with access to all the service\ncomponents used in the application, and with a @PostConstruct annotated method that uses those service\nclasses to insert data. This is the most practical way to initialize a small test-scoped database that does not\nrequire external configuration files or additional libraries in the classpath. The bean is annotated with\n@Component and it is automatically discovered, created, and initialized at application boot time.\nThe @Service annotated classes are organized in the hierarchy depicted in Figure 3-23.\nFigure 3-23. Service classes hierarchy\nThey are all named [EntityType]ManagerImpl, where EntityType is the type of object managed by the\nclass. The Impl suffix is used to emphasize that the class is a concrete implementation for the [EntityType]\nManager interface.\nThe BaseManager interface contains all the basic method skeletons common to all service classes.\n@Transactional\npublic interface BaseManager<E extends AbstractEntity> {\n@Transactional(readOnly = true)\nList<E> findAll();\n@Transactional(readOnly = true)\nE findById(Long id);\nE save(E e);\nvoid delete(E e);\nvoid deleteById(Long id);\n}\nThe manager interfaces extending it add method skeletons specific to each managed entity-type.\nThe repository components are created using Spring Data JPA and are in fact interfaces extending the\nJpaRepository interface. This interface extends CrudRepository, which provides sophisticated CRUD\nfunctionality for the entity class being managed. All other method definitions that are needed, but not\n146\nChapter 3 ■ Spring MVC\nprovided, are defined in the interface extending JpaRepository. They are annotated with the @Query\nannotation, and the query to be executed is set through it; for example:\n@Query(\"select p from Person p where p.lastName = :lastName\")\nList<Person> getByLastname(@Param(\"lastName\") String lastName);\nFor Spring to provide proxy repositories with the configured implementation for the interfaces that\nextend JpaRepository, the following line has been added to the app-dao-config.xml configuration file:\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n...\nxmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n...\nhttp://www.springframework.org/schema/data/jpa\nhttp://www.springframework.org/schema/data/jpa/spring-jpa.xsd\n...\">\n<jpa:repositories base-package=\"com.pr.repos\"/>\n</beans>\nThe equivalent Java configuration makes use of the @EnableJpaRepositories annotation:\n@Configuration\n@EnableJpaRepositories(\"com.pr.repos\")\nclass ApplicationConfiguration {\n@Bean\npublic EntityManagerFactory entityManagerFactory() { ... }\n@Bean\npublic DataSource dataSource() {...}\n...\n{\nThe basic configuration *.gradle file for each web module project looks like this:\n(1) apply plugin: 'war'\napply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin'\ndependencies {\n(2) compile project(':01-pr-service')\ncompile misc.slf4jApi, misc.slf4jJcl, misc.logback,\nhibernate.ehcache, hibernate.em, hibernate.core, hibernate.validator,\nspring.jdbc, spring.orm, spring.contextSupport, spring.data,\nspring.webmvc,\nmisc.dbcp, misc.h2, misc.joda, misc.jstl, misc.tilesJsp,\nmisc.tilesReqApi, misc.javaxEl\ntestCompile tests.junit, tests.mockito, spring.test,\ntests.hamcrestCore, tests.hamcrestLib\n}\n147\nChapter 3 ■ Spring MVC\ngretty {\nport = 8080\n(3) contextPath = '/mvc-layout'\n}\n1. This line is where the Gretty plugin is defined to run this module.\n2. This is the line where the dependency from the 01-pr-service project is defined.\nThis line ensures that before compiling the web application, the 01-pr-service\nis compiled first.\n3. This is the line where the Gretty plugin is configured to start the application with\na different context than the name of the project. In the case presented\nhere after starting the application, the web interface can be accessed at\nhttp://localhost:8080/mvc-layout This was necessary for practical reasons,\nbecause by default the module name is used, and the names of the modules in\nthis chapter are quite long.\nAll the projects can be built without the tests by running the allCompile task, as mentioned earlier in\nthe book. In case you forgot, the task can be found directly under the project root, in this case the personal-\nrecords project, in the Intellij IDEA Gradle task tab, as you can see in Figure 3-24.\nFigure 3-24. The Gradle allCompileTask\nThe other two tasks you need to use are the appStart and appStop under the module-project name in\nthe Intellij IDEA Gradle task tab; they start and stop the web application, as depicted in Figure 3-25.\n148\nChapter 3 ■ Spring MVC\nFigure 3-25. The Gerry start and stop web application tasks\nAll the modules in personal-records can be built and run separately when using Gradle outside of\nIntellij IDEA, by using the command line in a terminal and running specific Gradle tasks:\n$ cd personal-records\n$ gradle :02-pr-mvc-basic-practice:build\n$ gradle :02-pr-mvc-basic-practice:run\nIn the previous examples, the :02-pr-mvc-basic-practice is the name of the submodule, and :build\nand run are Gradle tasks to be run for the modules.\n■ ! When running examples in the command line, the run task is used instead of appStart to run the web\nmodules in gretty, so the execution can be ended by pressing any key in the terminal.\nEach of the projects suffixed with -practice is incomplete, missing either a bean definition or a\nconfiguration. In its place there is a TODO comment explaining what you have to do to make the project\nbuild. Each project covers a specific topic from the chapter, as follows:\n• 02-pr-mvc-basic-practice is a simple Spring web application project that displays\na list of persons from the applications. It should contain proper definitions for all the\npersonalization beans you read about in the chapter; it is what the TODOs are all\nabout: configuring the personalization beans properly. It has only one controller, the\nPersonsController, which is used to populate the list.jsp and show.jsp views.\nThis controller also has an @ExceptionHandler method that handles cases when a\nlink is manually created with a non-existing person id. (Test the exception handling\nmethod by manually accessing http://localhost:8080/mvc-basic/persons/99.)\n• 03-pr-mvc-layout-practice is a simple Spring web application project that uses the\nTiles engine to create views. Some configuration is missing and some methods have\nto be added for the project to work correctly. The Tiles template for the application\nis found under webapp/WEB-INF/templates; it is called layout.jsp. You can see the\nfull path within the project in Figure 3-26.\n149\nChapter 3 ■ Spring MVC\nFigure 3-26. Path of the Tiles layout template\nThere are two controllers defined PersonsController and HospitalsController. Each of\nthe controllers has the responsibility of populating the corresponding list.jsp views and the\nHospitalsController has a method that uses redirect: and redirectAttributes. This project also contains\nunit and integration tests designed to test you controllers.\n• 04-pr-mvc-view-practice is a simple Spring web application project that uses\ncontent view negotiation to present the data to the user in a specific view format\nfor the persons/list URL. All it is missing is a proper configuration for the\nContentNegotiatingViewResolver bean.\n• 05-pr-mvc-form-practice is a simple Spring web application project that presents\nthe user with a form to edit users and one to search for users. The TODO tasks\nrequire the user to place the correct annotation on methods to enable validation and\nfinish implementing the person search form. The part of the application managing\nHospital entries has been removed for the purpose of simplicity, but if you want to\npractice your Spring form skills, you are welcome to try to create an edit form for a\nHospital entry after you have solved the existing TODOs.\nAll the applications are internationalized and themed. There are two languages available—English and\nGerman, and two colored themes—blue and green.\nWhen all the tests pass, all the applications start successfully and provide the expected functionality, and\nyou feel confident that you have a solid grasp of the Spring Web MVC, you can continue to the next chapter.\n150\nChapter 4\nSpring Portlets\nAlthough not required for the certification exam, spring portlets are covered in this book because a lot of\nmedium-sized companies tend to favor portal applications, which come with a set of modules already\nimplemented. Companies may also hire developers to provide the customized functionality via pluggable\ncomponents. Usually, these portal applications are licensed and supported, which is an advantage when\nthings do not go exactly as planned, because you have direct contact with a team of experts that can help you\nwith problems specific to the software.\nPortlets are pluggable web components used when creating a portal, which is a complex web-based\napplication that provides personalization, authentication, and customizable content aggregation from\nmultiple sources. A portlet is a Java-based web component; its lifecycle is managed by a portlet container,\nwhich processes requests and generates dynamic content.1 Each portlet produces a fragment of markup\nthat is combined with the markup of other portlets in the context of a composite portal page. On enterprise\napplication servers, a new war archive is deployed on a server, either manually by copying it into a\ndeployment directory, or by uploading it using a manager application. A standard Java portlet should be\ndeployable on any portlet container2 that complies with the standard.\nThe advantage of using portlets is that the developer has to only handle the implementation of the logic\ninside a portlet; the portal server takes care of the rest, such as building and securing the page. Although this\nseems restrictive, the value of a portal application is the control that is given to administrators and users.\nA portlet (or a collection of portlets) behaves as a web-based application per-se, and it can be\naggregated to build more complex web applications—portals. Portal applications are as widely used as\nservlet applications and the design of such applications comes in two flavors:\n• Portlets provide small units of functionality and are aggregated by the portal server\ninto a larger application (see Figure 4-1).\n1This definition is given in the official Java portlet specification at https://jcp.org/en/jsr/detail?",
    "answer": "id=286. 2A portlet container is an application that runs portlets and provides the appropriate context. Examples of well-known and widely used portal applications that can be customized using portlets include IBM WebSphere Portal; Liferay Portal, an enterprise web platform for building business solutions; GateIn Portal (formerly JBoss Portal), an open source web site framework; and the Blackboard learning management system. 151 Chapter 4 ■ Spring portletS Figure 4-1. Diagram of portlets as units of a single-page portal application",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Whole applications can be written to reside in only one or a few portal pages\n(see Figure 4-2).\nFigure 4-2. Diagram of a multipage portal application\n152\nChapter 4 ■ Spring portletS\nChoosing which approach to use depends on the requirements of the application and the number of\ndifferent functionalities that the application must provide. For example, a university’s portal application\nis made of multiple pages, and each of those is made of multiple portlets with functionality related to a\ncommon domain. But a smaller application—a blog, for example—does not need multiple pages; the whole\napplication can fit into one portal page.\nLiferay Community Edition version 6.2-ce-ga43 is used to run the examples in this chapter (Figure 4-3\nshows the official Liferay site to help you easily see what you need to download). Choices are made by taking\ncompatibility with Spring into consideration, as well as how practical development and deployment will be.\nEvery portal application requires specific configurations, but Liferay allows high decoupling between portal\nand application configuration, which is quite an important feature, as you will soon discover.\nFigure 4-3. Liferay Portal version to download: Community Edition Bundle with Tomcat\nSpring provides an MVC framework for the JSR-168 and JSR-268 portlet development. This framework\ntries, as much as possible, to mirror the Web MVC framework, and also uses the same underlying view\nabstractions and integrations technology to make portlet development more practical.\n3Download the Liferay Community Edition from http://www.liferay.com/downloads/liferay-portal/\navailable-releases.\n153\nChapter 4 ■ Spring portletS\nPortlet Basics\nPortlet workflow is different from servlet workflow because it involves two distinct phases: an action phase\nand a render phase. The action phase is executed only once; this is the phase where backend logic is\nexecuted. During the render phase, the response that gets sent back to the user is produced. So there is a\nseparation between activities that affect the state of the system and the activities that generate data to be\ndisplayed.\nFigure 4-4 depicts the difference between MVC servlet handling and MVC portlet handling when\nusing Spring.\nFigure 4-4. Spring MVC portlet handling\nIn the early versions of Spring MVC framework, implementing a controller class in a servlet-based\napplication meant extending the o.s.web.servlet.mvc.AbstractController class (or implementing the\norg.springframework.web.servlet.mvc.Controller interface) and overriding the handleRequest()\nmethod, which is called by DispatcherServlet. Starting with Spring 3.0, this was no longer necessary,\nbecause annotations (@Controller and @RequestMapping) are used to provide a more flexible and practical\nway of working with controllers.\nThere is an equivalent Spring class for portlets that should be extended to create a portlet: the\norg.springframework.web.portlet.mvc.AbstractController class (and an equivalent interface\norg.springframework.web.portlet.mvc.Controller).\nThe handleActionRequest() and the handleRenderRequest() methods should be overridden; the\norg.springframework.web.portlet.DispatcherPortlet handles their invocation.\nSince Spring 3.0, annotations have made things easier for development of portlets too. @Controller is\nused to annotate a portlet controller, @RenderMapping is used to annotate a render method, and\n@ActionMapping is used to annotate an action method.\n154\nChapter 4 ■ Spring portletS\nThe advantage of annotations is that multiple render and action methods can be defined, and they can\nbe called depending on the request parameters.\nThe DispatcherPortlet uses a few special infrastructure beans to process requests and render\nappropriate views; they are implementations of interfaces analogous to MVC servlet interfaces. So when it\ncomes to portlets, handler mappings are used to map requests and portlet modes with controllers, multipart\nresolvers, and handler exception resolvers. Data binding, command object usage, model handling, and\nview resolution are the same as in the servlet framework, and they are performed by the same classes. An\nintermediary servlet bridge class, called ViewRendererServlet, is used for rendering views; it transforms a\nportlet rendering request to a servlet request and the view can be rendered using the servlet infrastructure\nspecific beans (view resolvers, messageSource, etc.). The only things not available are the usage of the\nredirect: prefix and RedirectView, because these kinds of operations are linked to the URL of the request,\nwhich in this case is generated by the portal and the results would be unexpected.\nMost portal applications expect the result of rendering a portlet to be an HTML fragment, so any view\ntechnologies like JSP/JSTL, Velocity, FreeMarker, and XSLT are allowed. This also means that Spring taglib\nand Spring form taglib are supported.\nEach portlet has a javax.portlet.PortletMode defined, which indicates the function the portlet is\nperforming in the render method. A portlet can change its portlet mode programmatically when processing\nan action request. The portlet specification defines three portlet modes: VIEW, EDIT, and HELP. Depending\non the security restrictions, a user can have access only to specific portlet modes; unauthenticated users can\nonly use VIEW and HELP, whereas authenticated users can also use EDIT.\nPortlets are required to support VIEW mode; and this is the only mode needed—even in complex\napplications. EDIT and HELP are not mandatory. Portal applications can define their own custom portlet\nmodes. For example, the Liferay Portal has additional portlet modes:\n• ABOUT\n• CONFIG\n• PRINT\n• PREVIEW\n• EDIT_DEFAULTS\n• EDIT_GUEST\nLiferay also allows its users to create their own portlet modes.\nSpring also acts as a portlet container, providing portlets with a runtime environment and managing\ntheir lifecycle. Spring receives requests from the portal and decides which portlet to execute. The portal is\nresponsible with aggregating the resulted content.\nThe following is the typical flow of events for using a portal application:\n1. The user gets authenticated by the portal.\n2. The user makes an HTTP request to the portal.\n3. The request is received by the portal.\n4. The portal determines if the request contains an action targeted to any of the\nportlets associated with the portal page.\n5. Using the portlet container, the portal invokes portlets to obtain content to be\ndisplayed in the resulting portal page.\n6. The portal aggregates the output of the portlets in the main page, and then sends\nthe results back to the client.\n155\nChapter 4 ■ Spring portletS\nAs seen in this example, even if the request is directed to a single portlet in the page, the whole page is\nbeing reconstructed and rendered. This can be avoided by using AJAX components in the portlet pages, and\ninstead of action requests, resource requests can be used (methods will be annotated with\n@ResourceMapping), but this implies adding a lot of resource handling logic for conversion and validation,\nwhich otherwise can be done by Spring automatically.\nA portal page can be made of one or more portlets, as seen in Figure 4-5.\nFigure 4-5. Liferay Portal page with various portlet components\nConfiguration\nSpring Portlet is a request-driven web MVC framework designed around the DispatcherPortlet,\nwhich is the entry point for a portlet application. It plays the same role as a front controller as\nDispatcherServlet does for servlet applications. Because each portlet behaves as a stand-alone\napplication, a DispatcherPortlet is defined for each portlet. Each DispatcherPortlet has its own\nWebApplicationContext, which inherits everything defined in the root WebApplicationContext. Everything\ninherited can thus be overridden in the portlet-specific scope. A context inheritance diagram example is\ndepicted in Figure 4-6.\n156\nChapter 4 ■ Spring portletS\nFigure 4-6. Context inheritance diagram in this chapter’s application sample\nConfiguring a portlet application can be done by using only XML files, but when working with Spring\nMVC portlet, it is practical to use annotations to reduce the size of XML configuration files and make them\nmore readable.\nIn the source code attached to this chapter, two portlets are defined: PortletSearch and PortletAdd.\nSnippets of code from the content of one or the other are used in this book to provide examples for the terms\nand definitions being mentioned.\nThe XML Part of the Configuration\nThe DispatcherPortlet(s) is/are declared in a configuration file name portlet.xml, which resides under\nthe WEB-INF directory. This file must exist with the mentioned name and in the mentioned location in any web\narchive containing portlet definitions. It is the configuration file for the portlet applications. You can consider\nit the equivalent of web.xml for portlets.\nA portlet application has the same structure as a normal web application, but the necessary\nconfiguration files depend on the portal application. How to use Liferay in this case will be discussed shortly;\nyou can see the application structure provided in Figure 4-7.\n157\nChapter 4 ■ Spring portletS\nFigure 4-7. The structure and configuration files for a Liferay portlet application\nEach file under WEB-INF has a specific purpose that will be discussed in detail later in this chapter.\nA short description of these files and their purposes can be seen in Table 4-1.\nTable 4-1. Message Converters Table\nFile Name Purpose Observation\napp-config.xml Application configuration Spring, part of the root context\nliferay-display.xml List of portlets available Liferay\nliferay-portlet.xml Portlets configuration in the portal Liferay\nmvc-config.xml Web infrastructure configuration Spring, part of the root context\npersonAdd-portlet.xml PersonAdd portlet configuration file Spring, inherits root context\npersonSearch-portlet.xml PersonSearch portlet configuration file Spring, inherits root context\nThe following list describes what every configuration file contains.\n• app-config.xml and mvc-config.xml are the typical Spring configuration files that\ncontain the user-defined application beans and web infrastructure beans that are\ninherited by portlet contexts:\n<!-- app-config.xml -->\n<context:component-scan base-package=\"com.pr\">\n<context:include-filter type=\"annotation\"\nexpression=\"o.s.stereotype.Service\"/>\n<context:include-filter type=\"annotation\"\nexpression=\"o.s.stereotype.Repository\"/>\n</context:component-scan>\n158\nChapter 4 ■ Spring portletS\n<!-- Import configuration for the datasource and the dao project -->\n<import resource=\"classpath:spring/app-dao-config.xml\"/>\n<import resource=\"classpath:spring/db-config.xml\"/>\n<!-- mvc-config.xml -->\n<bean id=\"viewResolver\"\nclass=\"o.s.web.servlet.view.InternalResourceViewResolver\"\np:viewClass=\"org.springframework.web.servlet.view.JstlView\"\np:prefix=\"/WEB-INF/person/\" p:suffix=\".jsp\"/>\n<bean id=\"messageSource\"\nclass=\"o.s.context.support.ReloadableResourceBundleMessageSource\"\np:basename=\"classpath:localization/global\"\nlazy-init=\"true\"/>\n• liferay-display.xml is a Liferay Portal configuration file, which contains the list\nof portlets available to add in the pages of a site and a category that groups them\ntogether. This file is not mandatory, but it is recommended to create it to shorten\nthe deployment process. Having this file in the war (alongside liferay-display.xml)\nallows you to install a portlet war application using the App Manager in Liferay,\nwithout any additional operations (see Figure 4-8).\nFigure 4-8. The App Manager in Liferay\n159\nChapter 4 ■ Spring portletS\n• This is the syntax of the file:\n<display>\n<category name=\"Personal Records\">\n<portlet id=\"personAdd\" />\n<portlet id=\"personSearch\" />\n</category>\n</display>\n• And when creating a site or a site template, Liferay provides user portlets\n(see Figure 4-9).\nFigure 4-9. How Liferay provides user portlets for usage in portal pages\n160\nChapter 4 ■ Spring portletS\n• liferay-portlet.xml is a Liferay configuration file that contains typical settings for\nuser created portlets in the context of the web application: portlet names, if they can\nbe used more than once in a page,4 additional JavaScript files, CSS files,5 and so forth.\n<liferay-portlet-app>\n<portlet>\n<!-- The canonical name of the portlet, it has to be unique -->\n<portlet-name>personSearch</portlet-name>\n<!-- Indicates if multiple instances of this portlet\ncan appear on the same page -->\n<instanceable>false</instanceable>\n<!-- not used in the example, but can appear in a configuration -->\n<footer-portlet-javascript>/js/main.js</footer-portlet-javascript>\n<header-portlet-css>/styles/general.css</header-portlet-css>\n<requires-namespaced-parameters>false</requires-namespaced-parameters>\n...\n</portlet>\n</liferay-app>\nAs these settings are Liferay specific, they won’t be covered in detail here. If you are interested in\nworking with Liferay, you can find more details on the official site at www.liferay.com.\n! Starting with liferay 6.2, the requires-namespaced-parameters parameter must be specified for a portlet.\nit must be set to false for parameter values to be read correctly. When not specified, the default value is true\nand the portal associates a unique name to each htMl element in the page to prevent name collisions between\ndifferent portlets in the page.\n• personSearch-portlet.xml and personAdd-portlet.xml are portlet application\nconfiguration files. A configuration file for each portlet must be created. All beans\nused by the portlet controller bean (except the beans inherited from the root context)\nare declared in it. The name must match the <portletName>-portlet.xml template,\nwhere <portletName> is the name of the portlet as declared in portlet.xml. In our\nexample, only the definition of the portlet controller bean can be specified. This file\nis loaded by the DispatcherPortlet:\n<bean id=\"personSearch\" class=\"com.pr.search.PersonController\"\np:personManager-ref=\"personManager\"/>\n4Portlets behave as stand-alone applications, so it is possible to add the same portlet multiple times to a page, unless\nconfigured differently.\n5Liferay and other portlet containers provide a context for the portlets to run in. This context contains theme elements\ndefined in CSS files, and additional functionality in the interface via JavaScript. But the user can override or complement\nLiferay by providing custom CSS and JavaScript files.\n161\nChapter 4 ■ Spring portletS\nBut if you want to use annotations as much as possible, you could do so:\n<!-- in personSearch-portlet.xml -->\n<context:component-scan base-package=\"com.pr.search\"/>\n<mvc:annotation-driven/>\n<!-- in personAdd-portlet.xml -->\n<context:component-scan base-package=\"com.pr.add\"/>\n<mvc:annotation-driven/>\nThe scanned package contains the portlet controller class and all the\ncomponents involved in defining the functionality of a portlet. Although the <mvc:annotation-driven/>\ndeclaration seems redundant, it is actually needed because portlets are independent applications, even if\nthey inherit the same root context and they reside in the same portal application context.\nAs mentioned, each portlet behaves as a standalone application, and that’s why these configuration files\nare needed. The root Spring configuration is defined in the\napp-config.xml and mvc-config.xml. Without these configuration files, the deployment will fail, because\nthe Spring MVC portlet expects a configuration file for each portlet. Here is what happens at deploy time if the\npersonSearch-portlet.xml file is missing:\no.s.w.p.c.XmlPortletApplicationContext - Refreshing PortletApplicationContext\nfor namespace 'personSearch-portlet'...\no.s.b.f.x.XmlBeanDefinitionReader - Loading XML bean definitions from\nPortletContext resource /WEB-INF/personSearch-portlet.xml\nERROR o.s.w.p.DispatcherPortlet - Context initialization failed\no.spring.beans.factory.BeanDefinitionStoreException: IOException parsing XML\ndocument from PortletContext resource /WEB-INF/personSearch-portlet.xml;\nnested exception is java.io.FileNotFoundException:\nCould not open PortletContext resource /WEB-INF/personSearch-portlet.xml\n...\n• portlet.xml is the configuration file that defines settings for the portlet(s), such\nas the portlet request handler (the portlet class). When working with Spring only,\nDispatcherPortlet, supported modes, supported locales, supported MIME types,\nand the resource bundle are used. This file contains multiple portlet elements—one\nfor each portlet defined in the application.\n<portlet-app ...>\n<portlet>\n<portlet-name>personSearch</portlet-name>\n<portlet-class>o.s.web.portlet.DispatcherPortlet</portlet-class>\n<supports>\n<mime-type>text/html</mime-type>\n<portlet-mode>view</portlet-mode>\n</supports>\n<resource-bundle>localization.global</resource-bundle>\n<portlet-info>\n<title>Person Search</title>\n</portlet-info>\n</portlet>\n<portlet>\n162\nChapter 4 ■ Spring portletS\n<portlet-name>personAdd</portlet-name>\n...\n<!-- configuration is analogous to the one for personSearch -->\n</portlet>\n<!-- More settings for other portlets -->\n</portlet-app>\n• web.xml contains the deployment descriptor for the web resources, and this is\nwhere the ViewRendererServlet is declared and the connection to the Spring MVC\nconfiguration is made. There is no DispatcherServlet defined, because portlet\napplications run in a portlet context, which is different form a servlet context.\nAccording to Portlet Specification 1.0, every portlet application is also a Servlet\nSpecification 2.3–compliant web application, and thus it needs a web application\ndeployment descriptor, meaning a web.xml file:\n<web-app ...>\n<context-param>\n<param-name>contextConfigLocation</param-name>\n<param-value>/WEB-INF/root-context.xml</param-value>\n</context-param>\n<listener>\n<listener-class>o.s.web.context.ContextLoaderListener</listener-class>\n</listener>\n<servlet>\n<servlet-name>ViewRendererServlet</servlet-name>\n<servlet-class>o.s.web.servlet.ViewRendererServlet</servlet-class>\n<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n<servlet-name>ViewRendererServlet</servlet-name>\n<url-pattern>/WEB-INF/servlet/view</url-pattern>\n</servlet-mapping>\n</web-app>\nThe ViewRendererServlet is the bridge servlet for portlet support. During the render\nphase, DispatcherPortlet wraps PortletRequest into ServletRequest and forwards control to\nViewRendererServlet for actual rendering. This process allows the Spring Portlet MVC framework to use the\nsame View infrastructure as that of its servlet version; that is, the Spring Web MVC framework. The /WEB-\nINF/servlet/view is the default value available for internal resource dispatching. The ViewRendererServlet\nbridge servlet can be mapped to a different URL pattern by using the viewRendererUrl property.\n163\nChapter 4 ■ Spring portletS\n! as mentioned at the beginning of the chapter, the controllers can be created without annotations by extending\nthe |o.s.web.portlet.mvc.AbstractController class. this is the old way of doing things, before the\nintroduction of the @Controller annotation. it is still supported, but not recommended, and it is not as practical\nas using an annotated controller. in this case, the <portletName>-portlet.xml looks a little different. the\nHelloWorldController in the book-code/04-chapter-solution module has a configuration file that looks\nlike this:\n<bean id=\"helloWorldController\" class=\"com.book.HelloWorldController\"/>\n<bean id=\"portletModeHandlerMapping\"\nclass=\"o.s.web.portlet.handler.PortletModeHandlerMapping\">\n<property name=\"portletModeMap\">\n<map>\n<entry key=\"view\">\n<ref bean=\"helloWorldController\"/>\n</entry>\n</map>\n</property>\n</bean>\nthe PortletModeHandlerMapping class is an implementation of the o.s.web.portlet.HandlerMapping\ninterface used by Spring to map from the current PortletMode to request handler beans.\nThe Annotation Part of the Configuration\nAt the time this book is being written, a full annotation configuration for a portlet-based application is not\npossible. A combination of XML and annotations can be used, because Spring MVC annotations are available\nfor usage in portlet controllers too. For example, in the PersonAddController, the @ModelAttribute is used\nin a similar manner as for a servlet container. The PersonAddController is a simple controller that allows the\nuser to create a person instance.\nimport org.springframework.stereotype.Controller;\n...\n@Controller(\"personAdd\")\n@RequestMapping(\"VIEW\")\npublic class PersonAddController {\n...\n@RenderMapping\npublic String render(Model model) {\nmodel.addAttribute(new Person());\nreturn \"add\";\n}\n164\nChapter 4 ■ Spring portletS\n@ModelAttribute\nprivate List<Hospital> getHospitals() {\nreturn hospitalManager.findAll();\n}\n@ActionMapping(\"add\")\npublic void addPerson(@Valid @ModelAttribute Person person,\nBindingResult result, ActionRequest actionRequest,\nActionResponse actionResponse,\nSessionStatus sessionStatus, Model model) {\nif (!result.hasErrors()) {\nlogger.info(\"ACTION: action saving person = \" person);\ntry {\npersonManager.save(person);\nmodel.addAttribute(\"message\",\nmessageSource.getMessage(\"label.Person.saved\", null,\nactionRequest.getLocale()));\nsessionStatus.setComplete();\n} catch (Exception e) {\nlogger.error(\"Unexpected error when saving person.\", e);\nmodel.addAttribute(\"error\", \"Internal Error.\nContact Administrator.\");\n}\n} else {\nlogger.info(\"Validation failed\");\nmodel.addAttribute(\"errors\", result);\n}\n}\n}\nThe model attribute defined by getHospitals() is used to populate the hospital drop-down list in the\nview fragment in add.jsp. The view fragment is basically normal JSP code; any taglibs can be used, and the\nportlet taglib is used to define the render and action URLs that will be mapped to methods in the controller\nresponsible for populating and managing data for the JSP fragment.\n(1) <%@ taglib prefix=\"portlet\" uri=\"http://java.sun.com/portlet_2_0\"%>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n(2) <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\n<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %>\n(3) <portlet:defineObjects />\n<h3>\n<spring:message code=\"persons.add.title\"/>\n</h3>\n(4) <portlet:actionURL var=\"addPersonUrl\">\n<portlet:param name=\"javax.portlet.action\" value=\"add\"/>\n</portlet:actionURL>\n165\nChapter 4 ■ Spring portletS\n(5) <portlet:renderURL var=\"cleanPersonUrl\">\n<portlet:param name=\"action\" value=\"clean\" />\n</portlet:renderURL>\n<div class=\"person\">\n...\n<sf:form name=\"person\" modelAttribute=\"person\"\naction=\"${addPersonUrl}\"\nmethod=\"POST\">\n<table>\n<tr>\n<th>\n<label for=\"firstName\">\n<span class=\"man\">*</span>\n<spring:message code=\"label.Person.firstname\"/>\n</label>\n</th>\n<td><sf:input path=\"firstName\"/></td>\n<td><sf:errors cssClass=\"error\" path=\"firstName\"/></td>\n</tr>\n<tr>\n<th>\n<label for=\"middleName\">\n<spring:message code=\"label.Person.middlename\"/>\n</label>\n</th>\n<td><sf:input path=\"middleName\"/></td>\n<td><sf:errors cssClass=\"error\" path=\"middleName\"/></td>\n</tr>\n...\n<!-- other form elements -->\n<tr>\n<td>\n<input type=\"submit\"\nvalue=\" <spring:message code=’command.save’/>\">\n</td>\n<td>\n<a href=\"${cleanPersonUrl}\">\n<spring:message code=\"command.cancel\"/>\n</a>\n</td>\n</tr>\n</table>\n</sf:form>\n</div>\n166\nChapter 4 ■ Spring portletS\nThe previous sample code is a snippet from the definition of the add.jsp fragment. A few lines are\nmarked with numbers in parentheses; here is why those lines are important:\n• (1) The portlet taglib definition for JRS 286. (A portlet container that supports JSR\n286 should also support JSR 168.)\n• (2) The Spring form taglib definition.\n• (3) Needed to use renderRequest, renderResponse, and portletConfig variables.6\n• (4) An element used to define an action URL for a portlet. The javax.portlet.action\nparameter value must match the value of the @ActionMapping annotation placed on\nthe action method in the controller. Other parameters with different names can be\nused and the {name,value} pairs, must appear as a value for the @ActionMapping\nannotation params attribute to correctly identify the action method to use. In the\ncase described in the preceding snippet, the following method will be mapped to the\naddPersonUrl:\n@Controller(\"personAdd\")\n@RequestMapping(\"VIEW\")\npublic class PersonAddController {\n...\n@ActionMapping(\"add\")\npublic void addPerson(...){\n...\n}\n...\n}\n• (5) An element used to define a render URL. This element has a parameter, and\nits name and value appears in the @RenderMapping annotation params attribute to\ncorrectly identify the render method to use. In the case described in the preceding\nsnippet, the following methods will be mapped to the cleanPersonUrl:\n@Controller(\"personAdd\")\n@RequestMapping(\"VIEW\")\npublic class PersonAddController {\n...\n@RenderMapping(params = \"action=clean\")\npublic String renderNew(Model model) {\n//the model attribute is removed from the model and a new on is added\n//causing the form to be emptied of data\nmodel.asMap().remove(\"o.s.validation.BindingResult.person\");\nmodel.addAttribute(new Person());\nreturn \"add\";\n}\n...\n}\n6https://blogs.oracle.com/deepakg/entry/jsr286_defineobjects_tag.\n167\nChapter 4 ■ Spring portletS\nConfiguration Details and Recommendations\nIf you paid enough attention to the example configuration files presented in the previous sections, you\nmight have noticed that there are some common elements between the configuration files; portlet names\nand portlet ids have to respect some strict rules in order for the portlets to be deployed correctly. Figure 4-10\nis a mashup of all files used in defining a portlet. In this image, only configuration elements specific to the\nPersonAdd portlet are depicted. Analogous elements are also defined for the PersonSearch portlet in this\nbook’s code samples. If you decide to experiment with the provided code and create your own portlet, the\nconfiguration should be done similarly to what is presented in Figure 4-10 for the PersonAdd portlet.\nFigure 4-10. All the files defining the PersonAdd portlet\nWhen developing a portlet, it is important to keep a standard for naming beans and configuration\nitems; make it as global as possible, because when elements are not found, Spring reports these as errors in\nthe portal application. Spring is quite clear in telling you what is missing, but portal application exceptions\ncan be quite confusing, especially when you are working with a portal application for the first time. So if you\nwant your portlet development to go flawlessly, try to follow these recommendations:\n1. Try to start development by writing the controller. Name the controller\nappropriately. A controller name should be made of the following:\na. The name of object type being manipulated\nb. The type of manipulation (list, search, edit, add)\nc. The Controller suffix\n168\nChapter 4 ■ Spring portletS\nFor example, a controller that handles requests for searching for a person would be named\nPersonSearchController. The name of the controller bean should be the object type name + manipulation\ntype. So the PersonSearchController name is annotated with @Controller(\"personSearch\").\n2. The second file is the Spring portlet configuration type. It is named as follows:\na. The name of the object type being manipulated\nb. The type of manipulation (list, search, edit, add)\nc. The -portlet suffix\nSo, a file to configure a portlet that performs a person search would be called personSearch-portlet.xml.\nInside this file, a bean defines the controller type that you previously created, and dependencies are injected\nwhen XML configuration is used. The bean id is the name of the controller bean defined in the previous step.\n<bean id=\"personSearch\">\n<property name=\"personManager\" ref=\"personManager\"/>\n</bean>\nWhen annotations are used to configure the necessary components, only the package that you are\ninterested in is scanned, and the <mvc:annotation-driven/> is added:\n<context:component-scan base-package=\"com.pr.search\"/>\n<mvc:annotation-driven/>\n3. The liferay-display.xml is next. Set the portlet id as object type name +\nmanipulation type.\n4. In the liferay-portlet.xml, set the portlet name as object type name +\nmanipulation type too.\nSo, for the portlet that displays a list of people, the portlet id and portlet name should be personList.\n5. In portlet.xml, use the same portlet name as you did in the previous step.\n6. Another recommendation is to make portlets that display data instanceable and\nthe portlets that alter data non-instanceable. The reason for this is as follows: if\na portlet that displays data is placed twice in the page, both portlets will always\ndisplay the same data, because they share the request. The same happens with\nportlets that alter data; so basically, two action requests are made with the same\nparameters, even if the input parameters have been populated in only one of\nthem. This leads to exceptions at the database level if the database is properly\ndesigned. If not, this leads to data duplications, and sometimes data corruption.\n7. If you have only one portlet, the root-context.xml is not necessary and all\nSpring infrastructure beans can be declared in the <portletName>-portlet.xml.\nThe Development and Deployment of a Portlet Application\nSince this chapter does not cover topics required for the certification exam, no quiz or practical exercises are\nin it; instead, a short step-by-step tutorial explains how to install, start, and configure Liferay, and deploys the\ncode samples offered to you. After you understand the process and create some portal pages with the given\nportlets, you can try to create your own portlet by following the recommendations from the previous section.\n169\nChapter 4 ■ Spring portletS\nDownload, Install, Start, and Configure Liferay\nAs mentioned in the beginning of this chapter, Liferay can be downloaded from www.liferay.com/\ndownloads/liferay-portal/available-releases. The following examples use the Community Edition,\nbundled with Tomcat, because it is free and can be downloaded directly. Also, Tomcat is really easy to use.\nAfter you click the Download button a *.zip file is saved onto your computer. The file is usually named\nliferay-portal-tomcat-[version]-ce-ga[index]-[date+build_number].zip. Unpack the archive in a\ndesired location. And this is the end of the install process.\nIf you open the directory, you will see the content depicted in Figure 4-11.\nFigure 4-11. The Liferay installation archive\nThe tomcat-[version] is the version of Tomcat that Liferay is based upon. It has the normal structure\nand functionality of a Tomcat application server, but it contains some extra jars and configuration files for\nthe Liferay Portal application.\n! Currently, liferay is based on tomcat 7, so a configuration without a web.xml file is not possible.\nTo start Liferay, you have to open a shell terminal or a Command Prompt instance. Go to the\ntomcat/bin directory inside the Liferay installation. Start the server as you would start Tomcat.\nWindows / Command Prompt\nC:\\{directory}\\liferay-{version}\\omcat-{version}\\bin catalina.bat run\n# you also have the option to \"double-click\" on startup.bat\nLinux / MacOs shell terminal\ncd /{directory}/liferay-{version}/tomcat-{version}/bin ./startup.sh\n170\nChapter 4 ■ Spring portletS\nYou can look in tomcat-[version]/logs/catalina.out to see when the server is up and whether\nexceptions were thrown due to incompatibilities between the Java version and Liferay. There could be other\ntomcat *.log files in the directory, but the catalina.out file is the one you should be interested in, because\nit is the main logging file for Tomcat and logs are written into it in real time when the server is up. Liferay 6.2\nis compatible with Java 8, however, so no such problem should arise. When the server is started, a window is\nopened in your default system browser at the address http://localhost:8080.\nThis page asks you to insert a few settings details. For the examples in this book, the default\nconfiguration can be used. The page should look like the one shown in Figure 4-12.\nFigure 4-12. The Liferay welcome page\nClick the Finish Configuration button on the bottom-left corner of the page. The default settings are\nsaved in an internal in-memory database. You should see a confirmation page that looks like the shown one\nin Figure 4-13.\n171\nChapter 4 ■ Spring portletS\nFigure 4-13. Liferay configurations saved confirmation page\nClick the Go to my Portal button in the bottom-left corner of the page. The next page is the Terms of\nUse page. Just scroll down and click the I Agree button. Next, you are presented with a page requiring you\nto add a password reminder. Just insert something simple and click the Save button. The default password\nfor user test@liferay.com is test (see Figure 4-14). After introducing a password reminder, you should\nbe redirected to the portal home page (see Figure 4-15). If you see this page, then your server is correctly\nconfigured and you can start deploying custom portlets.\nFigure 4-14. Liferay Password Reminder page\n172\nChapter 4 ■ Spring portletS\nFigure 4-15. Liferay Portal home page\nIn Liferay, portlets have to be added manually to a page by selecting them from a list with available\ncomponents. A page is usually part of a site. In Liferay, there are also site templates, which can be used\nto create multiple sites that inherit the configuration of a template. Of course, you could add the portlets\ndirectly to the home page you see after logging in, and then start testing them; but for the examples in this\nchapter, you will use Liferay the proper way.\nThe first step is to create a site template. To do this, expand the Admin menu and select Control Panel.\nFigure 4-16 shows where this option is found on the menu.\nFigure 4-16. Liferay Admin menu\n173\nChapter 4 ■ Spring portletS\nAfter selecting the Control Panel option, an admin page with all possibilities is displayed (see Figure 4-17).\nFigure 4-17. Liferay admin page\nThese options are numbered in Figure 4-17 to show you their order of usage when creating your site:\n1. Link to the Site Templates administration page.\n2. Link to the portlets (Applications) administration page.\n3. Link to the Sites administration page.\nThis page takes care of administration for the portal application and all sites hosted by it. Sites can be\nsecured or public. They can have users with different access roles and rights. They can have custom pages.\nSite templates can be created and user-provided portlets can be installed by using the App Manager. So let’s\ncreate a public site and populate it with the provided portlet samples.\nClick the Site Templates link to display the Site Template configuration page. Click the +Add button.\nThe form for creating the site template is displayed (see Figure 4-18). Insert the name of the site template\nand a description, if you want (description is not mandatory, the site name is). Click the Save button.\n174\nChapter 4 ■ Spring portletS\nFigure 4-18. Liferay create Site Template page\nThe more extended site template configuration is next. Click the Pages option in the menu on the\nleft. Next, click the Site pages option. In the center of the page, a set of options for all the pages in the site\ntemplate are presented. One of these options is the theme for all pages. Select the Dark radio button under\nthe Color Schemes section to use the dark scheme for the site template, because in the style sheet used in\nthe example, the style is defined to be compatible with it (see Figure 4-5). Then click the Save button on the\nright. Figure 4-19 depicts the actual page and the order of operations.\n1. Link to all site pages configurations.\n2. Select the Dark theme option.\n3. Link to the home page template configuration page.\n4. Click the Save button.\n175\nChapter 4 ■ Spring portletS\nFigure 4-19. Liferay customize site template page\nClick the home link (3), to customize the home page. Change the name if you want; in this example, the\nfirst letter is in uppercase. Next, select a layout. The preferred layout is 2 Columns (50/50), so the portlets\ncan be added side by side in the page. After doing this, click the Save button. A green message box should\nappear at the top of the page, letting you know that all went well (see Figure 4-20).\n176\nChapter 4 ■ Spring portletS\nFigure 4-20. Liferay customize Home Page Template\nSo, now a site template has been created; it contains a single page named Home, which is the page the\nsample portlets implementations will be placed. To do that, you have to preview the site template, which is\ndone by going back to the Site Templates Administration page and clicking the Site Templates button at the\ntop of the page. A list with all the defined site templates is displayed. The last one on the list should be the\nrecently created site template. Click the Actions button for the site and select the View Pages option\n(see Figure 4-21).\n177\nChapter 4 ■ Spring portletS\nFigure 4-21. Liferay Site Templates page\nIn a new browser window or tab, your site template is opened for customizations. On the left, there\nis a light-blue button with a + sign on it. If you click it, a menu opens to allow you to modify the content of\nthe home page. Since there is only one page, it is automatically selected. (When there are multiple pages to\ncustomize, you would just click a page header to select it, and then all customizations to be done on it.) Click\nthe Applications menu item to see a list of the available out-of-the-box Liferay portlets to add on the page.\nThey are grouped by category. The page in administration mode is shown in Figure 4-22.\n178\nChapter 4 ■ Spring portletS\nFigure 4-22. Site Template home page in administration mode\nNow it is time to load the sample portlets.\nOpen the book-code project and run the war task under the 04-chapter-solution project. The\nexecution of this task creates a *.war file under 04-chapter-solution\\build\\libs that needs to be\ndeployed to the Liferay Portal. The module contains two portlets:\n• Hello World Portlet is a simple portlet application with a controller created\nby implementing the o.s.web.portlet.mvc.Controller, as mentioned at the\nbeginning of the chapter. The handleRenderRequest of this portlet sets an attribute\nto the model, which is displayed during the render phase.\nimport javax.portlet.ActionRequest;\nimport javax.portlet.ActionResponse;\nimport javax.portlet.RenderRequest;\nimport javax.portlet.RenderResponse;\nimport o.s.web.portlet.ModelAndView;\nimport o.s.web.portlet.mvc.Controller;\npublic class HelloWorldController implements Controller {\n179\nChapter 4 ■ Spring portletS\npublic ModelAndView handleRenderRequest(RenderRequest request,\nRenderResponse response) throws Exception {\nMap<String, Object> model = new HashMap<String, Object>();\nmodel.put(\"helloWorldMessage\",\n\"Hello World from Spring WEB portlet example application!!\");\nreturn new ModelAndView(\"helloWorld\", model);\n}\npublic void handleActionRequest(ActionRequest request,\nActionResponse response) throws Exception {\n//we do not have action requests\n}\n}\n• Hello World Portlet2 is a simple portlet application with a controller created\nand configured using a typical Spring configuration: annotations and XML. As a\nbonus, this portlet has a @ResourceMapping annotated method that is used to send\na text directly to the browser. These types of methods can be used in AJAX calls, as\nmentioned at the beginning of this chapter.\nimport o.s.stereotype.Controller;\nimport o.s.ui.Model;\nimport o.s.web.bind.annotation.RequestMapping;\nimport o.s.web.portlet.bind.annotation.ActionMapping;\nimport o.s.web.portlet.bind.annotation.RenderMapping;\nimport o.s.web.portlet.bind.annotation.ResourceMapping;\n@Controller(\"helloworld2\")\n@RequestMapping(\"VIEW\")\npublic class HelloWorldController2 {\n@RenderMapping\npublic String render(Model model){\nmodel.addAttribute(\"helloWorldMessage\",\n\"Hello World from Annotated Spring Portlet!!\");\nreturn \"helloWorld2\";\n}\n//We do not need to do anything here.\n//Empty method given as example of how action methods are defined.\n@ActionMapping(value=\"doSomething\")\npublic void action(ActionRequest request, ActionResponse response){\n}\n//Example of resource request method\n@ResourceMapping(value = \"getData\")\npublic void getData(ResourceRequest resourceRequest,\nResourceResponse resourceResponse) throws IOException {\nresourceResponse.getWriter().write(\"Test data for Ajax call.\");\n}\n}\n180\nChapter 4 ■ Spring portletS\nPlease take the time to analyze the code and the configuration files, and then execute the task and build\nthe *.war. If the task is executed correctly, you should see the result in 04-chapter-solution\\build\\libs.\nCompare Figure 4-23 with your own environment.\nFigure 4-23. The 04-chapter-solution portlet sample\nNow that you have the archive with the portlets, it is time to upload them to Liferay. For this you need to\ngo the portal administration page (Control Panel) and click the App Manager link. A page with all available\nportlets is displayed.\nThe following actions must be performed:\n1. Click the Install tab on the menu.\n2. A page with an upload Form will be displayed, asking you to upload an LPKG\nor a WAR file. Click the Browse button. (On some systems, this button might be\nnamed Choose File.)\n3. Select the 04-chapter-solution-1.0-SNAPSHOT.war file.\n4. Click the Install button.\nIf the *.war file is installed correctly, a green message box appears on the top of the page with the\nmessage: The plugin was uploaded successfully and is now being installed (see Figure 4-24).\n181\nChapter 4 ■ Spring portletS\nFigure 4-24. Using the App Manager to install custom portlets in Liferay\n! Community editions of liferay may have minor bugs and throw exceptions, although everything is\nhappening as it should. For example, the liferay version used to test the portlet implementations, liferay-\nportal-6.2-ce-ga4, throws a com.liferay.portal.kernel.messaging. MessageListenerException:java.lang.\nNullPointerException, which is printed in the catalina.out log file, but the portlets are installed correctly.\nTo make sure that the portlets were installed correctly and are ready to use, click the Manage tab. The\n04-chapter-solution-1.0-SNAPSHOT application should be at top of the list because of its name, and if you\nexpand the gray rectangle underneath, you should see something similar to what’s shown in Figure 4-25.\n182\nChapter 4 ■ Spring portletS\nFigure 4-25. Correctly installed portlet samples in Liferay\nNow is the time to go back to the site template and place these two portlets in the home page.\nLiferay has a quick navigation menu on top of the page, which can be used for faster navigation between\nadministrative pages. (It is pinpointed to you in Figure 4-25). There is a Sites option on it. By clicking this,\nthe Liferay site–related configurations page is displayed (see Figure 4-21). Now all you have to do is click the\nSite Templates button, and then preview the site template as shown earlier.\nThe page shown in Figure 4-22 should have an extra category now, the Chapter 04 Sample. Expand\nthis, and then drag each portlet to the page and place it accordingly. The home page should look like what’s\nshown in Figure 4-26; you can also see the new category group for the HelloWorld sample portlets.\nFigure 4-26. Sample portlets added to the page\n183\nChapter 4 ■ Spring portletS\nBefore creating a site using the template, the way to uninstall a war application should be presented,\nbecause things might go wrong during portlet development. For example, the following exception is thrown\nat Liferay deployment when the configuration of a portlet application is incorrect:\no.s.w.p.c.XmlPortletApplicationContext - Refreshing PortletApplicationContext\nfor namespace 'personSearch-portlet'...\no.s.b.f.x.XmlBeanDefinitionReader - Loading XML bean definitions from\nPortletContext resource /WEB-INF/personSearch-portlet.xml\nERROR o.s.w.p.DispatcherPortlet - Context initialization failed\no.spring.beans.factory.BeanDefinitionStoreException: IOException parsing XML\ndocument from PortletContext resource /WEB-INF/personSearch-portlet.xml;\nnested exception is java.io.FileNotFoundException:\nCould not open PortletContext resource /WEB-INF/personSearch-portlet.xml\n...\nConfiguration errors—such as missing beans or missing expected configuration files (like in the\npreceding exception)—are displayed only in the catalina.out file. In the App Manager you can see the\ngreen message confirmation box as long as the file can be read. The difference is message under the portlet\nname in the Manage section: There are no configurable plugins for this app.\nWhen this happens, click the Manage tab, and then click the Actions button attached to the application\nyou want to uninstall. Select the Uninstall option. See Figure 4-27 for the message and uninstall option.\nFigure 4-27. Uninstall a portlet application\nNow let’s create a site. Select Sites from the top menu, and then select Sites. Click the +Add button.\nNext, select the Personal Records Template. The succession of these steps is depicted in Figure 4-28.\n184\nChapter 4 ■ Spring portletS\nFigure 4-28. The steps to create a site using a site template\nYou will be directed to a new page, where a name and description can be inserted for the site. There are\nother options possible, but for now, just accept the default values and click the Save button. The page will\nlook like the one shown in Figure 4-29.\nFigure 4-29. Site configuration page\n185\nChapter 4 ■ Spring portletS\nAfter creating the site, more configuration options become available, and you can see them all in the\npage that is loaded after the save operation. A recommended practice is to customize the site URL, as Liferay\nwill generate one from the site name (which might not be an acceptable URL). For example, for a site named\nPersonal Records Manager, the site URL generated by Liferay is personal-records-manager. To modify a\nsite URL, in the site configuration page, click the Site URL menu option on the right, and then change the\ngenerated site URL with the desired URL under the Friendly URL section, as depicted in Figure 4-30.\nFigure 4-30. Site URL configuration\nClick the Save button, and then access the newly created site from the menu. Go to My Sites. The\nsite name should appear in the menu. By clicking it, you should be redirected to the site home page (see\nFigure 4-31).\n186\nChapter 4 ■ Spring portletS\nFigure 4-31. Accessing a Liferay site\nAfter the two extra-simple HelloWorld portlets from the book-code project are added to the site, look\nin personal-records for the module named 06-pr-mvc-portlet-solution. This module contains two\ncomplex portlets: one for creating a Person instance and one for searching the Person database and deleting\nPerson instances. These are complex portlets that access a database and perform actual data modification;\nthey don’t just display data. Most code samples mentioned in this chapter are from these portlets. These\nportlets have been developed in such a way that all Spring MVC has to offer is included: model attributes,\nSpring forms, automatic conversion and validation, and so on. The code for the Spring form and validation is\nthe same as the one for forms used in a servlet environment, and you can find it all in Chapter 3. The reason\nfor this is that servlet and portlet environments differ only by the type of requests being resolved and the way\nthey are mapped to handlers. Once a request has been mapped to a handler, processing the data inside the\nbody of a request is independent of the application type.\nPlease take a look at the project, and then deploy the portlets on Liferay and add them to the site\ntemplate in the same manner presented so far. Your updated site should afterward look like what is shown in\nFigure 4-32, or a little different if you chose a different way to place your portlets in the page.\n187\nChapter 4 ■ Spring portletS\nFigure 4-32. The Personal Records Manager portal site\nSummary\nAfter reading this chapter, you should have a basic understanding of how to use the Spring MVC Portlet\nframework with the Liferay Portal application. Here is a list of things that you should remember in case you\never end up working on a portal project:\n• Portlets are specialized web components that behave as stand-alone web\napplications and used to create composite pages in portal applications.\n• The Spring MVC Portlet framework mirrors the Spring MVC framework. The role of\nthe front controller is played by the DispatcherPortlet in portlet applications.\n• A portlet works with two types of requests: render and action. The render requests\ndo not involve business logic or data manipulation; they just request data from the\nportal to display it in the page. Actions do the actual data manipulation.\n• Most Spring MVC infrastructure beans and features are available for use in portlet\napplications.\n• Liferay is very compatible with Spring MVC Portlet; the configuration is totally\ndecoupled.\n188\nChapter 5\nSpring RESTful Services\nREST is an acronym for REpresentational State Transfer. It was introduced and defined in 2000 by Roy\nFielding in his doctoral dissertation. REST is a lightweight alternative to mechanisms like RPC (Remote\nProcedure Calls) and web services (SOAP, WSDL, etc.). REST is an architecture style for designing networked\n(distributed) applications. The idea is that, rather than using complex mechanisms such as CORBA, RPC,\nor SOAP to connect machines, simple HTTP is used to make calls between machines. RESTful applications\nuse HTTP requests to post data (create and/or update), read data (e.g., make queries), and delete data. Thus,\nREST uses HTTP for all four CRUD (create/read/update/delete) operations.\nCore REST Concepts\nThe REST architectural style describes six constraints:\n• Uniform interface: Defines the interface between client and server. Rest uses HTTP\nas an application protocol, as a platform, not just a transport protocol. The following\nHTTP specifications are used:\n• HTTP verbs are used as actions to execute on the resources (GET, PUT, PATCH,\nPOST, DELETE, HEAD, and OPTIONS)1\n• URIs are used to identify resource names. The resources are conceptually\nseparate from representations. Representations of the resources are returned\nfrom the server to the client, after a client request (typically JSON or XML).\nRepresentations contain metadata that can be used by the client to modify or\ndelete the resource on the server, provided it has permission to do so.\n• HTTP response: Response codes, the body, and headers are used to deliver state\nto clients. Clients deliver state using body content, query-string parameters,\nrequest headers, and the URI.\n1Although REST seems strongly connected to HTTP, REST principles can be followed using other protocols too,\nfor example: POP, IMAP, and any protocol that uses URL-like paths and supports GET and POST methods.\n189\nChapter 5 ■ Spring reStful ServiCeS\n• Statelessness: The server should contain no client state. Each request has enough\ncontext for the server to process the message. The URI uniquely identifies the\nresource, and the body contains the state (or state change) of that resource if the\nrequest is one that has a body (PUT, POST, PATCH). When working with a specific\ncontainer, a session is used to preserve state across multiple HTTP requests. When\nusing REST, there is no need for this, which increases the scalability because the\nserver does not have to maintain, update, or communicate the session state.\n• Client-server: A RESTful architecture is a client-server architecture, so the system\nis disconnected. The server might not be available all the time, so operations are\nasynchronous.\n• Cacheable: Anything returned by the server can be cached explicitly (the server\nspecifies conditions for caching), implicitly (the client uses its own caching\nconditions), or negotiated(the client and the server negotiate caching conditions)\n• Layered system: The client cannot assume direct connection to the server.\nSometimes a requested resource can be cached, and some other unknown software\nand hardware layers are interposed between the client and the server. Intermediary\nservers may improve system scalability and/or security by enabling load balancing,\nproviding shared caches, and enforcing security policies.\n• Code on demand: Executable code can be transferred as a representation to the\nclient (usually JavaScript or compiled Java applications known as applets).\n■ Note processes running on different hosts communicate over a layered set of network protocols\ndefined by the OSi model. the uppermost level is the application layer and protocols specific to it are called\napplication protocols. this is the layer that is closest to the user, which means the user interacts directly with\nthe software application. Between the application layer and the transport layer are two more layers.\nthe transport layer provides the functional and procedural means of transferring variable-length data\nsequences from a source to a destination host via one or more networks, while maintaining the quality of\nservice functions. the protocols specific to it are called transport protocols.\nWhen using reSt, data is not just sent and received via http (transport), but data is actively manipulated by the\nuser in the context of an application. More information about network layers and protocols can be found on the\ninternet; if you are interested in finding out more, you can check out Wikipedia at https://en.wikipedia.org/\nwiki/OSI_model. advanced networking is not the object of this book or the certification exam.\nComplying with the first five constraints ensures that a RESTful application will be scalable, simple,\neasy to modify, portable, and reliable. The last constraint is optional; a REST application can be built without\ncode being transferred to clients, if there is no need for such operations. The main REST HTTP methods are\npresented in Table 5-1.\n190\nChapter 5 ■ Spring reStful ServiCeS\nTable 5-1. Message Converters\nHTTP Method Purpose Observation\nGET Read Reads a resource; does not change it: therefore, it can be considered safe.\nReading the same resource always returns the same result: therefore, it can\nbe considered idempotent.\nPOST Create Used to create a new resource. Neither safe nor idempotent. Two identical\nPOST requests will result in two identical resources being created or errors\nat application level.\nPUT Update Most often used for update capabilities. It is not safe, because it modifies\nthe state on the server, but is idempotent (unless subsequent calls of the\nsame PUT request increments a counter within the resource, for example).\nDELETE Delete Used to delete resources. Not safe, but can be considered idempotent\nbecause requests to delete a resource that no longer exists will always\nreturn a 404 (not found).\nTo analyze contents of the REST requests and responses handled by the browser, the Firebug plugin in\nFirefox can be used. Simply install it directly from the official site (http://getfirebug.com/) and enable it\nby clicking the little bug on the right corner of the page (1). To see the contents of a request, just click on the\nNet tab (2), as depicted in Figure 5-1.\nFigure 5-1. Using the Firebug plugin in Firefox to analyze REST requests and responses handled by the browser\n191\nChapter 5 ■ Spring reStful ServiCeS\nThe following describes the GET example shown in Figure 5-2:\n• It retrieves a representation of a resource.\n• It might have length restrictions.2\n• It is a safe operation; idempotent; repetitive execution that has no side effects.\n• It is cacheable and ETags are used to keep tags on resource versions.3\n• When a resource is not found, a 404 (Not Found) status code is returned;\notherwise 200 (OK)\nFigure 5-2. GET Request and Response example; snippets form the Firebug console\nThe following describes the POST example shown in Figure 5-3:\n• It creates a new resource.\n• It is not idempotent; repetitive execution causes duplicate data and/or errors.\n• The response has the created resource location URI in the response header.\n• When the resource being created requires a parent that does not exist a\n404 (Not Found) status code is returned. When an identical resource already exists\na 409 (Conflict) status code is returned. When the resource was created correctly a\n201 (Created) status code is returned.\n2Servers should be cautious about depending on URI lengths above 255 bytes, because some older client or proxy\nimplementations may not properly support these lengths. When a browser does not support a certain request length,\na 400 (Bad Request) status code is returned.\n3You can read more about ETags at http://en.wikipedia.org/wiki/HTTP_ETag.\n192\nChapter 5 ■ Spring reStful ServiCeS\nFigure 5-3. POST Request and Response example\nThe following describes the PUT example shown in Figure 5-4:\n• It updates an existing resource or creates it with a known destination URI. The URI of\na resource contains an identifier for that resource. If that identifier is not generated\nby the application, but can be created by the client a behavior such as this can be\nimplemented: when a PUT request refers to an existing resource, the resource is\nupdated, otherwise a new resource with the identifier from the URI and the contents\nin the request body is created.\n• It is idempotent; repetitive execution has the same result.\n• It is not safe; repetitive updates could corrupt data.\n• When the resource being updated requires a parent that does not exist, or the\nresource requested to be updated does not exist, a 404 (Not Found), status code\nis returned. When the resource is updated correctly, a 200 (OK) (or a 204\n(No Content) if not returning any content in the body) status code is returned.\nFigure 5-4. PUT Request and Response example\n193\nChapter 5 ■ Spring reStful ServiCeS\nThe following describes the DELETE example shown in Figure 5-5:\n• It deletes a resource.\n• It is idempotent; repetitive execution has the same result.\n• It is not safe; repetitive deletes could corrupt data.\n• When the resource being deleted does not exist, a 404 (Not Found), status code\nis returned. When the resource was deleted correctly, a 200 (OK) status code is\nreturned.\nFigure 5-5. DELETE Request and Response example\nWhen it comes to REST, everything is about resource states and transferring them between a client\nand a server, in different forms. The request specifies the representation type using the Accept HTTP\nheader for GET and the Content-Type HTTP header for PUT and POST, as you have seen in the preceding\nimages, because when the client is not a browser (remember Chapter 3), the Accept header is taken\ninto consideration. The URI extension can be used as a representation type identifier too. The response\nreports the representation type returned using the Content-Type HTTP header. When using Spring, the\nrepresentation type is specified using an attribute of the @RequestMapping annotation and well-known\nmedia types defined in the MediaType class:\n@RestController\n@RequestMapping(value = \"/rest-persons\")\npublic class PersonsRestController extends BaseController {\n...\n@ResponseStatus(HttpStatus.OK)\n@RequestMapping(value = \"id/{id}\", method = RequestMethod.GET,\nproduces = MediaType.APPLICATION_JSON_VALUE)\npublic Person getPersonById(@PathVariable Long id) throws NotFoundException {\nlogger.info(\"-----> PERSON: \" + id);\nPerson person = personManager.findById(id);\nif (person == null) {\nthrow new NotFoundException(Person.class, id.toString());\n}\nreturn person;\n}\n...\n}\n194\nChapter 5 ■ Spring reStful ServiCeS\n//Exception handler class for Rest errors.\n@ControllerAdvice(basePackages = \"com.pr.rest\")\npublic class RestExceptionProcessor {\n/\nMaps NotFoundException to a 404 Not Found HTTP status code.\n@ResponseStatus(value = HttpStatus.NOT_FOUND,\nreason = \"This entity is not found in the system\")\n@ExceptionHandler({NotFoundException.class})\npublic void handleNotFound(NotFoundException nfe) {\n// just return empty 404\nlogger.info(\"-----> Entity \" + nfe.getObjType() +\n\" with identifier\" + nfe.getObjIdentifier() + \"not found.\");\n}\n}\nHATEOAS\nOn his public blog,4 Roy Fielding mentioned that most REST services are not really RESTful, because\nfully RESTful services should only return links. Basically, HATEOAS implies that when a client makes a\nREST request to a server, the server should return a response that informs the client of all possible REST\noperations using links. For example, a resource should contain links to related resources, including URIs for\nediting it and deleting it, and so forth. Following this idea, well-known author Leonard Richardson defined\nthe Richardson Maturity Model,5 which describes four levels of REST compliance:\n• Level 0, also known as the Swamp of POX. Only HTTP is used as a transport method.\n• Level 1, also known as the Resource Level. HTTP is used as a transport method and\nURIs are used to identify resources.\n• Level 2, also known as the HTTP Verb Level. This is the level where HTTP headers,\nstatuses, methods, distinct URIs and everything else HTTP has to offer to provide a\nREST service. At this level, HTTP is used the way it’s meant to be.\n• Level 3, also known as the Hypermedia Controls Level. This is the final level, where a\nfully complying REST service should be. HATEOAS, an abbreviation for Hypermedia\nAs The Engine Of Application State, is a constraint of the REST application\narchitecture that distinguishes it from most other network application architectures.\nThe principle is that a client interacts with a network application entirely through\nhypermedia provided dynamically by application servers.\nThe Spring team has developed a separate project to make it easy to implement RESTful services that\ncomply with the third level. Spring HATEOAS6 provides APIs to ease creating REST representations that\nfollow the HATEOAS principle when working with Spring, and especially Spring MVC.\n4This blog is at http://roy.gbiv.com.\n5Martin Fowler has a great article on this at http://martinfowler.com/articles/richardsonMaturityModel.html.\n6The project official page is at http://projects.spring.io/spring-hateoas/.\n195\nChapter 5 ■ Spring reStful ServiCeS\nHATEOAS is a concept of application architecture, which defines the way clients interact with servers\nusing hypermedia links they find inside representations returned by the server. To implement HATEOAS,\nresources representations must comply with a set of standards and contain hypermedia information.\nOne of the most common standards used to hyperlink resources is HAL.7 A resource in HAL is just a\nplain-old JSON or XML object with whatever properties needed, but that provides the possibility to\nhyperlink resources. The following is a code snippet showing what a resource representation that complies\nto the HAL standard looks like:\n//GET Request: /persons/5 using JSON format\n// Response representation returned below:\n{\n\" links\": {\n\"self\": { \"href\": \"/persons/5\" },\n\"parents\": [\n{ \"href\": \"/persons/2\", \"title\": \"mother\" },\n{ \"href\": \"/persons/3\", \"title\": \"father }\n]\n},\n\"firstName\" : \"John\",\n\"middleName\" : \"Constantine\",\n\"lastName\" : \"Smith\",\n\"dateOfBirth\" : \"1935-10-01\",\n\"gender\" : \"MALE\",\n\"hospital\" : {\n\"code\" : \"134181\",\n\"name\" : \"General Hospital\",\n\"address\" : \"Sample address\",\n\"location\" : \"Constance, Romania\"\n},\n\"identityCard\" : {\n\"pnc\" : \"1351001134181\",\n\"series\" : \"CO\",\n\"number\" : \"205727\",\n\"emittedAt\" : \"1949-10-01\",\n\"expiresAt\" : \"1985-10-01\",\n\"address\" : \"34eeb1d5-0ff4-4d4a-b811-4ff32aa15ada\"\n}\n}\n//GET Request: /persons/5 analogous example using XML\n<?",
    "answer": "xml version=\"1.0\" encoding=\"utf-8\"?> <person rel=\"self\" href=\"/person/5\"> <linkList> <link rel=\"parent\" title=\"mother\" href=\"/persons/2\"/> <link rel=\"parent\" title=\"father\" href=\"/persons/3\"/> </linkList> 7This is at http://stateless.co/hal_specification.html. 196 Chapter 5 ■ Spring reStful ServiCeS <firstName>John</firstName> <lastName>Constantine</lastName> <!-- other simple properties--> ... <hospital> <code>134181</code> <!-- other simple properties--> ... </hospital> <identityCard> <pnc>1351001134181</pnc> <!-- other simple properties--> ... </identityCard> </person> Advantages of REST The following list describes the advantages of REST.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "REST is simple.\n• REST is widely supported.\n• Resources can be represented in a wide variety of data formats (JSON, XML, Atom, etc.).\n• You can make good use of HTTP cache and proxy servers to help you handle high\nloads and improve performance.\n• It reduces client/server coupling.\n• Browsers can interpret representations.\n• JavaScript can use representations.\n• A REST service can be consumed by applications written in different languages.\n• It is easy for new clients to use a RESTful application, even if the application was not\ndesigned specifically for a client.\n• Because of the statelessness of REST systems, multiple servers can be behind a load\nbalancer and provide services transparently, which means increased scalability.\n• Because of the uniform interface, documentation of the resources and basic API\noperations are unnecessary.\n• The hypermedia constraint assures that application processing transitions are always\nnavigable by clients, simply by following opaque server-provided links. Thus, the\nclient does not need to understand anything more than the data format. (And when\nJSON is used, the data format is quite obvious.)\n• Using REST does not imply specific libraries at the client level in order to\ncommunicate with the server. With REST, all that is needed is a network connection.\n197\nChapter 5 ■ Spring reStful ServiCeS\nREST services can be secured, but as the interaction between the client and server is stateless,\ncredentials have to be embedded in every request header. Basic authentication is the easiest to implement\nwithout additional libraries (HTTP Basic, HTTP Digest, XML-DSIG, or XML-Encryption), but it guarantees\nthe lowest level of security. Basic authentication should never be used without TLS (formerly known as\nSSL) encryption because the credentials can be easily decoded otherwise. In Figure 5-6, you can see how\nbasic authentication is used when a client communicates with a RESTful application that requires basic\nauthentication.\nFigure 5-6. Basic authentication when using RESTful systems\n! When a collection is expected, it is enough use: /persons (plural) and /hospitals (plural). the /all\nlink was used here because the original web controllers implemented in Chapter 3 were kept separate, so you\ncan access the interface and verify the changes you are doing via reSt in the browser. Basically, the reSt and\nweb functionalities are fully decoupled. and because the PersonsController was already mapped to /persons\nand the HospitalController was already mapped to /hospitals, there was no other way to do this but to\nmap the reSt controllers to different urls.\n! Snippets of code from the HospitalsRestController are not mentioned in the book, because the code is\nalmost identical to the one for the reSt methods in PersonsController; the only difference is the resource\ntype. But the code is available for you to practice on in the book’s code samples.\nOther common protocols used with RESTful systems are OAuth 1.0a and OAuth 2.0. Custom security\nimplementation should be used only if necessary, because the skill to understand cryptographic digital\nsignatures is quite difficult to master.\nThere may be a lot more to say about REST in general, but the introduction to REST must end here,\nas this chapter is about Spring and how Spring can be used to develop RESTful applications. And you will\nnotice that providing and consuming REST services with Spring is so easy that a deep understanding of REST\nis not actually needed.\n198\nChapter 5 ■ Spring reStful ServiCeS\nRESTful Applications Using Spring MVC\nTo learn how to implement and test RESTful services using MVC, module 09-pr-rest-practice was\ncreated. This module contains the implementation of the operations depicted in Figure 5-7.\nFigure 5-7. RESTful architecture for the practice section\nRESTful Clients with Spring\nA RESTful application can be accessed by any type of client that can create the type of request supported\nby the application. To test a Spring RESTful application, Spring provides two classes: RestTemplate and\nAsyncRestTemplate.\nThe RestTemplate is Spring’s central class for synchronous client-side HTTP access. This class provides\na wide set of methods for each HTTP method, which can be used to access RESTful services and enforces\nREST principles.8 Figure 5-8 depicts a correspondence between HTTP methods and RestTemplate methods\nthat can be used to access REST services.\n8Javadoc for this class can be found at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/\nspringframework/web/client/RestTemplate.html.\n199\nChapter 5 ■ Spring reStful ServiCeS\nFigure 5-8. RestTemplate api to HTTP methods correspondence\nAs you can see, the execute and exchange methods can be used for any type of REST calls, as long\nas the HTTP method is given as a parameter for the methods. All methods are polymorphic,9 and using\none or another depends on the requirements and the developer’s preferences. URI instances are returned\nto identify resources, and RestTemplate methods support URI templates. So, the following two calls are\nidentical:\n//using URI Template\nString url = \"http://localhost:8080/mvc-rest/rest-person/id/{id}\";\nPerson person = restTemplate.getForObject(url, Person.class, \"1\");\n// using URI\nString url = \"http://localhost:8080/mvc-rest/rest-personid/1\";\nPerson person = restTemplate.getForObject(url, Person.class);\n9Multiple methods with the same name, but different signatures are provided. Just check out the Spring API for\nRestTemplate at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/\nRestTemplate.html.\n200\nChapter 5 ■ Spring reStful ServiCeS\nThe execute method can also be given a RequestCallback implementation as a parameter, which tells\nthe RestTemplate what to do with the request before sending it to the server. Considering this, a GET request\nfor a Person instance with id=1 could be written with the exchange method like this:\nString url =\"http://localhost:8080/mvc-rest/rest-person/id/{id}\";\nPerson person = restTemplate.execute(url, HttpMethod.GET,\nnew RequestCallback() {\n@Override\npublic void doWithRequest(ClientHttpRequest request)\nthrows IOException {\nHttpHeaders headers = request.getHeaders();\nheaders.add(\"Accept\", MediaType.APPLICATION_JSON_VALUE);\nSystem.out.println(\"Request headers = \" + headers);\n}\n}, new HttpMessageConverterExtractor<Person>(Person.class,\nrestTemplate.getMessageConverters())\n, new HashMap<String, Object>() {{\nput(\"id\", \"1\");\n}});\nObjects passed to and returned from the methods getForObject(), postForLocation(), and put()\nare converted to HTTP requests and from HTTP responses by HttpMessageConverters. Message converters\nare automatically detected and used by Spring in applications configured with <mvc:annotation-driven/>\nor @EnableWebMvc. In the code sample for this chapter, the representations are in JSON format, so\nMappingJackson2HttpMessageConverter is used. And because the message format is supported by default,\nthe HttpMessageConverterExtractor<T> is not necessary in the previous example. Also, if no Accept header\nis specified, all formats supported by Spring are considered. So in this case, RequestCallback becomes\nunnecessary too, so you can stick to the simpler restTemplate.getForObject method that was mentioned\nin the previous code snippet.\nSpeaking of message converters, restTemplate deals only with objects, so it internally converts\nresources to representations, and vice-versa, using message converter implementations of the\nHttpMessageConverter<T> interface. Spring comes with a default long list of supported message converters,\nbut if necessary, a developer can provide his own implementation of the HttpMessageConverter<T>.\nTable 5-2 provides a list of the most commonly used message converters and the datatype handled:\nTable 5-2. Message Converters\nMessage Converter Data Type Observation\nStringHttpMessageConverter text/plain\nMappingJackson2HttpMessageConverter application/*+json Only if Jackson 2 is present\non the classpath\nAtomFeedHttpMessageConverter application/atom+xml Only if Rome is present on\nthe classpath\nRssChannelHttpMessageConverter application/rss+xml Only if Rome is present on\nthe classpath\nMappingJackson2XmlHttpMessageConverter application/*+xml Only if Jackson 2 is present\non the classpath\n201\nChapter 5 ■ Spring reStful ServiCeS\nTo use a restTemplate, you can define and initialize it directly where you need it, or declare a bean\nand inject it. restTemplate handles HTTP connections internally, so the developer does not have to write\nextra code with opening and closing connections. A different HTTP client can also be used, and Apache\nprovides an implementation that can be injected into a RestTemplate bean. This is highly recommended for\nproduction applications when authentication and HTTP connection pooling are usually needed.\nTo use the Apache Commons HttpClient, Spring provides a factory class named\nHttpComponentsClientHttpRequestFactory, which provides an HttpClient instance that uses a default\norg.apache.http.impl.conn.PoolingClientConnectionManager10 that is able to service connection\nrequests from multiple execution threads.\n<bean id=\"restTemplate\" class=\"o.s.web.client.RestTemplate\">\n<property name=\"requestFactory\">\n<bean class= \"o.s.http.client.HttpComponentsClientHttpRequestFactory\"/>\n</property>\n</bean>\nConfiguring a RestTemplate bean using Java Configuration looks like this:\n\\\\in the @Configuration and @EnableWebMvc annotated class\n@Bean\npublic RestTemplate restTemplate() {\nRestTemplate restTemplate = new RestTemplate();\nrestTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());\nreturn restTemplate;\n}\nOther examples of restTemplate usage are in the following code snippet:\n// GET request to retrieve all persons born at a hospital with a specific code\nString url = \"http://localhost:8080/mvc-rest/rest-hospitals/{code}/persons\";\nPerson[] persons = restTemplate.getForObject(url, Person[].class, \"134181\");\n// POST request to create a person\nPerson person = buildPerson();\nfinal HttpHeaders headers = new HttpHeaders();\nheaders.setContentType(MediaType.APPLICATION_JSON);\nfinal HttpEntity<Person> personRequest = new HttpEntity<>(person, headers);\nString url = \"http://localhost:8080/mvc-rest/rest-persons/create\";\n// this method returns the created resource\nPerson newPerson = this.restTemplate.postForObject(url, personRequest, Person.class);\n//this method returns the URI of the created resource\nURI uri = this.restTemplate.postForLocation(url, personRequest, Person.class);\n//DELETE request to delete a person by id\nString url = \"http://localhost:8080/mvc-rest/rest-persons/delete/23\";\nrestTemplate.delete(url);\n10The class is part of the Apache http-client library. JavaDoc API can be accessed at http://hc.apache.org/\nhttpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/ conn/PoolingClientConnection\nManager.html.\n202\nChapter 5 ■ Spring reStful ServiCeS\nREST services are used most commonly by AJAX components in a web application, and currently all\nHTTP methods are supported in AJAX. But most browsers do not support any other methods besides GET\nand POST in HTML forms. To use them in a form, Spring has introduced hidden methods. Basically, a\nhidden input is added to a form with a regular POST method. If the POST request is to be treated as a PUT\nrequest, the value of the field will be equal to this method name, as shown in the code sample below. A filter\ninterceptor intercepts the request, searches for that parameter, and modifies the request accordingly before\nsending it to the appropriate handler.\nFor this to work, the Spring form has the method attribute value set to the desired HTTP method, and\nthe resulting HTML form has a hidden field added:\n<!-- Spring form -->\n<sf:form method=\"put\" action=\"..\" modelAttribute=\"..\">\n...\n</sf:form>\n<!-- HTML form -->\n<form method=\"post\" action=\"...\">\n<input type=\"hidden\" name=\"method\" value=\"put\" />\n...\n</form>\nThe filter interceptor that takes care of intercepting requests and modifying the methods is the\nHiddenHttpMethodFilter, which can be configured in a web.xml file or in a class implementing\nWebApplicationInitializer.\n<!-- in web.xml -->\n<!-- Enables use of HTTP methods PUT and DELETE -->\n<filter>\n<filter-name>httpMethodFilter</filter-name>\n<filter-class>o.s.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n<filter-name>httpMethodFilter</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n\\\\in class extending AbstractDispatcherServletInitializer\n\\\\ or AbstractAnnotationConfigDispatcherServletInitializer\n@Override\nprotected Filter[] getServletFilters() {\nreturn new Filter[] { new HiddenHttpMethodFilter()};\n}\nAsynchronous REST Calls\nAt the beginning of this section, AsyncRestTemplate was mentioned. This class can be used to create Spring\nREST clients that make asynchronous calls to a REST service. The AsyncRestTemplate class is nothing\nother than a wrapper class for RestTemplate that provides the asynchronous behavior via a set of methods\n(analogous to the ones in RestTemplate) that return Future<T> wrappers (or ListenableFuture<F>\n203\nChapter 5 ■ Spring reStful ServiCeS\nthat extends Future<T> when a callback method is needed) instead of concrete data. An example of an\nasynchronous GET request can be found in the AsyncRestTemplateTest class, in the 07-pr-rest-solution.\nIn the same class, you can also find an example with a callback.\nprivate static final String PERSON_BASE_URL =\n\"http://localhost:8080/mvc-rest/rest-persons/id/{id}\";\nAsyncRestTemplate asyncRestTemplate = new AsyncRestTemplate();\n...\nFuture<ResponseEntity<Person>> futurePerson =\nasyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\");\n//waiting a little, to give time to the async call to complete\nThread.sleep(1000L);\nResponseEntity<Person> result = futurePerson.get();\nPerson person = result.getBody();\nassertNotNull(person);\n//callback example\nListenableFuture<ResponseEntity<Person>> futurePerson =\nasyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\");\nfuturePerson.addCallback(new ListenableFutureCallback<ResponseEntity<Person>>() {\n@Override\npublic void onSuccess(ResponseEntity result) {\nPerson person = (Person) result.getBody();\nassertNotNull(person);\n}\n@Override\npublic void onFailure(Throwable t) {\nlogger.error(\"------> Async call failure!\", t);\n}\n});\nImplementing REST with Spring MVC\nThere are multiple Java frameworks available for implementing RESTful applications: Spark, Restlet,\nJAX-RS(Java EE), and RESTEasy, but Spring MVC is the easiest to use. This section contains a lot of\ninformation and code snippets to convince you that this affirmation is true. REST support was added to\nSpring MVC in version 3.0, and although developing RESTful applications was always easy, in version 4.x\nthings have become even more practical.\nAmong the aforementioned frameworks, JAX-RS is shipped with out-of-the-box Spring Integration.\nThis framework encapsulates the Java API for RESTful web services (JAX-RS, defined in JSR 311). Jersey, the\nreference implementation of JAX-RS, implements support for the annotations defined in JSR 311, making\nit easy for developers to build RESTful web services by using the Java programming language. It is focused\nmore on application-to-application communication, so the focus is not on browser clients. That’s the\namazing thing about Spring MVC—a Spring RESTful application does not care about its client type at all.\n204\nChapter 5 ■ Spring reStful ServiCeS\nSpring MVC provides the following resources to build RESTful applications:\n• The potential to declare status codes.\n• URI templates.\n• Content negotiation.\n• Many message converters offer out-of-the-box support.\n• RestTemplate and AsyncRestTemplate classes are used for easily creating client\napplications or for testing RESTful application services.\n• Browsers are supported as clients, although HTTP method conversion is necessary\nfor PUT and DELETE methods. When making REST requests from a web page,\njQuery can be used (this is covered in Chapter 6).\nA few of these have already been mentioned in the previous section, as they were involved in creating\nREST clients; the others are covered in this section.\nTo develop a RESTful service class with Spring MVC, you have to do the most obvious thing: create a\ncontroller that contains handler methods that return resources representations instead of views, which are\nthe actual response body. In Spring 3.0, we had to do the following:\n@Controller\n@RequestMapping(value = \"/rest-persons\")\npublic class PersonsRestController {\n@Autowired\nPersonManager personManager;\n@ResponseStatus(HttpStatus.OK)\n@RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET)\npublic @ResponseBody Person getPersonById(@PathVariable Long id)\nthrows NotFoundException {\nPerson person = personManager.findById(id);\nif (person == null) {\nthrow new NotFoundException(Person.class, id.toString());\n}\nreturn person;\n}\n}\nLooks like any MVC controller, right?",
    "answer": "The only difference is the @ResponseBody that indicates a method return value should be bound to the web response body. The advantage here is that, in the same controller you can also have methods that are not used to provide REST representations, having all the people management data in one place. But, because it is a good practice to decouple code with different scopes, in Spring MVC 4.0 the @RestController was introduced. This annotation is conveniently annotated with 205 Chapter 5 ■ Spring reStful ServiCeS @Controller and @ResponseBody, which practically means that if you annotate a class with it, all handler methods are transparently annotated with @ResponseBody. Also, the purpose of this controller becomes quite obvious—it handles only REST requests. Thus, the preceding code becomes the following: @RestController @RequestMapping(value = \"/rest-persons\") public class PersonsRestController extends BaseController { @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET) public Person getPersonById(@PathVariable Long id) throws NotFoundException { ... // identical content as above } } And this is all. All methods defined inside this class can then be called from REST clients, and they will receive the requested representations. What happens in the background—the way that the DispatcherServlet is involved—is depicted in Figure 5-9. Figure 5-9. Spring MVC RESTFul Container 206 Chapter 5 ■ Spring reStful ServiCeS So basically, the controller methods return data directly to the client—data that no longer needs to be processed in order to render a view. Every time a request is mapped to a handler method that has parameters annotated with @RequestBody, or the method is annotated with @ResponseBody, Spring loops over all HttpMessageConverters; it is seeking the first that fits the given MIME type and class, and then uses it for the actual conversion. Mapping requests to methods is the same as with web controllers. All annotations applicable in web handler methods are applicable in REST handler methods too: @PathVariable, @Valid, and so forth. @RequestParam can be used too, but this would break the REST constraints mentioned at the beginning of the chapter. HTTP Status Codes When a web application returns a response, that response has a status code that describes a certain state of the returned resource or the result of the operation that the request triggered on the server. The most familiar is probably the 404 Not Found status code that is returned when a requested resource cannot be found. A full list of HTTP status codes can be found on Wikipedia, which you should look at if you are curious about and unfamiliar with HTTP status codes.11 RESTful applications use HTTP status codes to communicate with their clients. With Spring MVC, the status code of a response can be set easily using the @ResponseStatus annotation. This annotation can receive as a value any of the constants defined in Spring class HttpStatus. Table 5-3 contains the most common response statuses used in RESTful applications. Here are some examples of @ResponseStatus annotated REST handlers that you will work with in the practice project for this chapter: @ResponseStatus(HttpStatus.NO_CONTENT) @RequestMapping(value = \"/delete/{pnc}\", method = RequestMethod.DELETE) public void deletePerson(@PathVariable String pnc) throws NotFoundException { ... } @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public Person createPerson(@RequestBody @Valid Person newPerson) { ... } @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/all\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public List<Person> getAll() { ... } 11See http://en.wikipedia.org/wiki/List_of_HTTP_status_codes. 207 Chapter 5 ■ Spring reStful ServiCeS Table 5-3. HTTP Status Codes HTTP Status HttpStatus Constant Observation 200 OK Successful GET with returned content. 201 CREATED Successful PUT or POST; location header should contain URI or new resource. 204 NO_CONTENT Empty response; after successful PUT or DELETE. 404 NOT_FOUND Resource was not found. 403 FORBIDDEN Server is refusing to respond to the request, because the response is not authorized. 405 METHOD_NOT_ALLOWED HTTP method is not supported for the resource identified by the Request-URI. 409 CONFLICT Problems when making changes, when PUT or POST try to save data that already exists and is marked as unique 415 UNSUPPORTED_MEDIA_TYPE The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method. ! the \"produces\" and \"consumes\" properties are covered later in the chapter. ! normally, void or null returning methods result in a default view name determined by the request’s path information (from @RequestMapping annotations on the class and method, as explained in Chapter 3).the @ResponseStatus overrides the default behavior, causing a null ModelAndView to be used, which indicates that the response has been handled by the controller method already. So, obviously the @ResponseStatus is mandatory for a reStful handler method returning void or null. Exception Handling The status codes can be used for exception handlers too. Yes, RESTful handlers can also throw exceptions, and they have to be properly handled. Similar to Spring MVC web specific controllers, exception handlers can be defined either in the body of the REST controller, or they can be defined in class annotated with @ControllerAdvice. And the same ExceptionHandler annotation is used to annotate the exception handler methods. In the next code snippet, such a class was defined with two exception handlers for different types of exceptions, and the handlers were limited to the com.pr.rest package, using the basePackages attribute, in order to handle exceptions thrown only by controllers in that package. 208 Chapter 5 ■ Spring reStful ServiCeS @ControllerAdvice(basePackages = \"com.pr.rest\") public class RestExceptionProcessor { private Logger logger = LoggerFactory.getLogger(RestExceptionProcessor.class); //Maps IllegalArgumentExceptions to a 404 Not Found HTTP status code @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"This entity is not found in the system\") @ExceptionHandler({NotFoundException.class}) public void handleNotFound(NotFoundException nfe) { // just return empty 404 logger.info(\"-----> Entity \" + nfe.getObjType() + \" with identifier\" + nfe.getObjIdentifier() + \"not found.\"); } // Maps DataIntegrityViolationException to a 409 Conflict HTTP status code. @ResponseStatus(value = HttpStatus.CONFLICT, reason = \"Another entity with the same identity exists\") @ExceptionHandler({DataIntegrityViolationException.class}) public void handleAlreadyExists() { // just return empty 409 logger.info(\"-----> Entity save operation failure\"); } } Content can be returned using an exception handler, but in this case, the client must be implemented to handle the response. @ExceptionHandler(NotFoundException.class) @ResponseStatus(value= HttpStatus.NOT_FOUND) @ResponseBody public JsonError personNotFound(HttpServletRequest req, NotFoundException ex) { Locale locale = LocaleContextHolder.getLocale(); String errorMessage = messageSource. getMessage(\"error.no.person.id\", null, locale); errorMessage += ex.getObjIdentifier(); String errorURL = req.getRequestURL().toString(); return new JsonError(errorURL, errorMessage); } ... public class JsonError { private String url; private String message; public JsonError(String url, String message) { this.url = url; this.message = message; } // getters and setters } 209 Chapter 5 ■ Spring reStful ServiCeS The “produces” and “consumes” Properties In the previous examples, the consumes and produces annotation properties of the @RequestMapping were used. These two attributes are used to narrow the primary mapping for a request. The consumes attribute defines the consumable media types of the mapped request (defined on the server) and the value of the Content-Type header (defined on the client side) must match at least one of the values of this property in order for a method to handle a specific REST request. Let’s say, for example, that in the REST client, the following headers were set: final HttpHeaders headers = new HttpHeaders(); final String url = \"http://localhost:8080/mvc-rest/rest-persons/create\"; \\\\\"application/json\" headers.setContentType(MediaType.APPLICATION_JSON); final HttpEntity<Person> personRequest = new HttpEntity<>(person, headers); Person newPerson = restTemplate.postForObject(url, personRequest, Person.class); On the server, the following REST handler would be mapped to process this request: @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = {MediaType.APPLICATION_JSON_VALUE, //Public constant media type for {@code application/octet-stream}. MediaType.APPLICATION_OCTET_STREAM}) public Person createPerson(@RequestBody @Valid Person newPerson) { ... } The produces attribute defines the producible media types of the mapped request, narrowing the primary mapping. The value of the Accept header (on the client side) must match at least one of the values of this property in order for a method to handle a specific REST request. Let’s say, for example, that in the REST client there is the following request: final String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; Person person = restTemplate.execute(url, HttpMethod.GET, request -> { HttpHeaders headers = request.getHeaders(); headers.add(\"Accept\", MediaType.APPLICATION_JSON_VALUE); }, new HttpMessageConverterExtractor<>(Person.class, restTemplate.getMessageConverters()) , new HashMap<String, Object>() {{ put(\"id\", \"1\"); }}); ! as mentioned, the code for making a reSt request for a person can be far simpler than what was depicted earlier. the execute method was used here to show how this method can be used. 210 Chapter 5 ■ Spring reStful ServiCeS On the server, the following REST handler would be mapped to process this request: @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public Person getPersonById(@PathVariable Long id) throws NotFoundException { return personManager.findById(id) } Accessing Servlet Environment and Request Data Because RESTful controllers are run in a servlet environment, and the interface is the DispatcherServlet, the servlet environment properties can be injected and accessed in the same manner presented in Chapter 3. The RESTful handler methods can have flexible signatures. HttpServletRequest or HttpServletResponse can be used as parameters, and Spring will take care of populating them for you. The @PathVariable and @RequestParam annotations can be used to tell Spring to inject request data automatically. @Valid can be used to validate resources submitted with POST or PUT. And so on. Even SpEL expressions are supported. The next example depicts a REST handler for a POST method, which creates a person and adds the URI of the new resource; this is built from the original request URL that is populated by Spring as a value for the Location header: @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create2\", method = RequestMethod.POST) public void createPerson2(@RequestBody @Valid Person newPerson, @Value(\"#{request.requestURL}\")StringBuffer originalUrl, HttpServletResponse response) { Person person = personManager.save(newPerson); logger.info(\"-----> PERSON: \" + person); response.setHeader(\"Location\", getLocationForPersonResource(originalUrl, person.getId())); } //Determines URL of person resource based on the full URL of the given request, //appending the path info with the given childIdentifier using a UriTemplate. protected static String getLocationForPersonResource (StringBuffer url, Object childIdentifier) { String newURL = url.toString(); newURL = newURL.replace(\"create2\", \"id/{id}\"); UriTemplate template = new UriTemplate(newURL); return template.expand(childIdentifier).toASCIIString(); } 211 Chapter 5 ■ Spring reStful ServiCeS Another method for accessing request and response is the HttpEntity<T> class and its subclasses: RequestEntity<T> and ResponseEntity<T>. By using these classes, you can get access to the request and response body. RequestEntity<T> and ResponseEntity<T> can be used as follows:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "In the REST client to encapsulate every detail about a REST request that is made by\ncalling restTemplate.exchange.\nfinal String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\";\nfinal RequestEntity<Person> entity = RequestEntity.post(new URI(url))\n.accept(MediaType.APPLICATION_JSON)\n.contentType(MediaType.APPLICATION_JSON)\n//setting a custom header that will be accessed in the handler method\n.header(\"custom\", \"true\")\n.body(person);\nResponseEntity<Person> response = restTemplate.exchange(entity,\nPerson.class);\nPerson newPerson = response.getBody();\n//get URI location for the Person created\nHttpHeaders headers = response.getHeaders();\nURI uri = headers.getLocation();\n• In the RESTful handler method to access request headers, read the body of a request,\nand write headers to the response stream.\n@ResponseStatus(HttpStatus.CREATED)\n@RequestMapping(value = \"/create3\", method = RequestMethod.POST)\npublic ResponseEntity<Person> handle(HttpEntity<Person> requestEntity,\n@Value(\"#{request.requestURL}\") StringBuffer originalUrl)\nthrows UnsupportedEncodingException {\n// will return \"true\"\nString requestHeader = requestEntity.getHeaders().getFirst(\"custom\");\n//we are just making sure the header is the one sent from the client\nassertTrue(Boolean.parseBoolean(requestHeader));\nPerson person = requestEntity.getBody();\nHospital hospital = hospitalManager.\nfindByCode(person.getHospital().getCode());\nperson.setHospital(hospital);\nPerson newPerson = personManager.save(person);\nHttpHeaders responseHeaders = new HttpHeaders();\nresponseHeaders.set(\"Location\",\ngetLocationForPersonResource(originalUrl, person.getId()));\nreturn new ResponseEntity<>(newPerson, responseHeaders,\nHttpStatus.CREATED);\n}\n212\nChapter 5 ■ Spring reStful ServiCeS\n! as with @RequestBody and @ResponseBody, Spring uses HttpMessageConverter<T> to convert to and from\nthe request and response streams. the HttpMessageConverter<T> and supported implementations were\ncovered in the “reStful applications using Spring MvC” section.\nAsynchronous REST Services Using @Async Annotated Methods\nThe “Asynchronous REST Calls” section showed how to make an asynchronous REST call using the\nAsyncRestTemplate class. In that case, the client did the rest call and could then focus on other operations\nuntil the Future object returned the concrete data.\nBut asynchronous calls can be made in a different way using @Async annotated methods. This\nannotation marks a method as a candidate for asynchronous execution. It can also be used at type level;\nin this case, all methods in the class are considered asynchronous. Asynchronous methods can have any\nsignature and any parameter types. There are absolutely no restrictions about this. However, the return type\nis restricted to void and Future (and implementations of this interface). Immediately after a client calls an\nasynchronous method, the invocation returns and the execution of the method is submitted to a Spring\nTaskExecutor12. Asynchronous methods that return void are used when the client does not expect a reply.\nBy default, to execute a method annotated with @Async, the executor that is used is the one supplied to\nthe <task:annotation-driven/> element. (The Spring Task namespace was introduced in Spring 3.0 to help\nconfigure TaskExecutor and TaskScheduler instances.)\n<task:annotation-driven executor=\"prExecutor\"/>\n<task:executor id=\"prExecutor\" pool-size=\"100\"/>\nIn Java Configuration, support for @Async can be enabled using @EnableAsync in one of the\nconfiguration classes of the application—those annotated with @Configuration. To provide a different\nexecutor, like in the preceding XML example, the class must implement org.springframework.scheduling.\nannotation.AsyncConfigurer and provide a concrete implementation for the getAsyncExecutor method.\n@Configuration\n@EnableAsync\npublic class AppConfig implements AsyncConfigurer {\n@Override\npublic Executor getAsyncExecutor() {\nThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\nexecutor.setCorePoolSize(100);\nexecutor.initialize();\nreturn executor;\n}\n...\n}\n12Spring’s TaskExecutor interface is equivalent to the java.util.concurrent.Executor interface and extends it\nwithout modifying the API in order for clients to declare a dependency on an executor and receive any TaskExecutor\nimplementation. It was created to remove the need for Java libraries when using thread pools.\n213\nChapter 5 ■ Spring reStful ServiCeS\nAlso the @Async annotation has a value attribute to indicate that an executor other than the default\nshould be used when the executor13 is defined as a bean:\n@Async(\"otherExecutor\")\npublic Future<Person> findPerson(Long id) throws InterruptedException {\nString url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\";\nPerson person = restTemplate.getForObject(url, Person.class, \"1\");\nThread.sleep(1000L);\nreturn new AsyncResult<>(person);\n}\n<!-- in a spring configuration file we define an Executor bean -->\n<bean id=\"otherExecutor\"\nclass=\"o.s.scheduling.concurrent.ThreadPoolTaskExecutor\"\ninit-method=\"initialize\" destroy-method=\"shutdown\">\n<property name=\"corePoolSize\" value=\"100\"/>\n</bean>\n// in a class annotated with @Configuration\n@Bean(name=\"otherExecutor\", destroyMethod = \"shutdown\",\ninitMethod = \"initialize\")\nThreadPoolTaskExecutor getExecutor() {\nThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\nexecutor.setCorePoolSize(100);\nreturn executor;\n}\n! an example of an @Async annotated method and usage can be found in 07-pr-rest-solution. the example\nis covered in the “practical exercise” section.\nIntercepting REST Calls\nThere is a section in Chapter 3 about handler interceptors for controller methods, which mentions that REST\nrequests can be intercepted too, but the REST interceptors have to implement the ResponseBodyAdvice<T>\nor extend one of its subclasses and provide the proper implementation for the beforeBodyWrite and\nsupports.\nWhen extending JsonViewResponseBodyAdvice or AbstractMappingJacksonResponseBodyAdvice,\nthe beforeBodyWriteInternal method must be implemented, because the\nAbstractMappingJacksonResponseBodyAdvice class provides a concrete implementation for beforeBodyWrite,\nwhich calls beforeBodyWriteInternal after creating a proper JSON body container. ResponseBodyAdvice<T>\nimplementation allows you to customize the response after the execution of a @ResponseBody or a\nResponseEntity<T> method, but before being passed for conversion to an HTTP message converter. These\ninterceptors are annotated with @ControllerAdvice and are automatically picked up and used by Spring.\n13You can see all methods available for a ThreadPoolTaskExecutor at http://docs.spring.io/spring/docs/4.1.x/\njavadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html.\n214\nChapter 5 ■ Spring reStful ServiCeS\nIn the 07-pr-rest-solution module, such an interceptor is implemented for you:\n@ControllerAdvice(basePackages = \"com.pr.rest\")\n//this interceptor is retricted to the classes in package \"com.pr.rest\"\npublic class AuditRestInterceptor\nextends JsonViewResponseBodyAdvice {\nprivate Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class);\n@Override\npublic boolean supports(MethodParameter returnType, Class converterType) {\nlogger.info(\"-----> Audit REST interceptor supports(Person.class) ?",
    "answer": "\" + Person.class.isAssignableFrom(returnType.getParameterType())); return (super.supports(returnType, converterType) && returnType.getMethodAnnotation(JsonView.class) != null); } .... } The supports method tests if the AuditRestInterceptor supports the given controller method return type and the selected HttpMessageConverter<T> type. The value logged in the preceding supports method implementation is true if the controller method return type is assignable to a reference of type Person. @ControllerAdvice(basePackages = \"com.pr.rest\") //this interceptor is retricted to the classes in package \"com.pr.rest\" public class AuditRestInterceptor extends JsonViewResponseBodyAdvice { private Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class); ... @Override protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) { logger.info(\"-----> Audit REST interceptor beforeBodyWrite\"); response.getHeaders().add(HttpHeaders.CONTENT_ENCODING, \"UTF-8\"); super.beforeBodyWriteInternal(bodyContainer, contentType, returnType, request, response); } } In the beforeBodyWriteInternal, the CONTENT_ENCODING header is added to the response, so the presence of this header can be tested in the client and you can make sure that the interceptor did its job. After that, the super.beforeBodyWriteInternal() is called to keep the original behavior of the extended class, which is to modify the response body before being converted and sent back to the client. 215 Chapter 5 ■ Spring reStful ServiCeS You see this interceptor in action when testing your REST services, because the log messages are printed in the log console. INFO c.p.r.AuditRestInterceptor - --> Audit REST interceptor supportsPerson.class ? true INFO c.p.r.AuditRestInterceptor - --> Audit REST interceptor beforeBodyWrite Using Spring HATEOAS HATEOAS and Spring HATEOAS project were mentioned at the beginning of the chapter. When the Hypermedia REST constrains are respected by a REST service, it is said that the service is a Hypermedia Driven REST web service. Hypermedia is quite important for REST, because it allows you to build services that are almost fully decoupled from their clients. The representations returned by the REST services contain links that indicate further locations of resources that the client needs access to. To build a Hypermedia Driven REST web service with Spring, the spring-hateoas dependency must be added to the project. The current version of spring-hateoas is 0.17.0.RELEASE. This library (it is only one jar currently, but it will probably grow into a framework) provides a set of classes used to generate resource URIs. It also provides classes to decorate representations with links to return to the HATEOAS complying client. In this chapter’s examples, the Person class is wrapped inside a PersonHateoas class that extends the core class of spring-hateoas: ResourceSupport. This class provides methods useful to add links to representations and to access representations links. The PersonHateoas looks like this: ... import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty; import org.springframework.hateoas.ResourceSupport; public class PersonHateoas extends ResourceSupport { private Person person; @JsonCreator public PersonHateoas(@JsonProperty(\"person\") Person person) { this.person = person; } public Person getPerson() { return person; } } The PersonHateoas class has a field of type Person. By extending class ResourceSupport, methods to generate HATEOAS links and references are inherited. When requesting a Person resource from a HATEOAS REST service, a PersonHateoas is serialized and sent to the client. When the serialization is done in JSON format, some specific JSON annotations are needed when declaring the PersonHateoas class. The @JsonProperty specifies that at serialization time, the resulted object will contain a property named person that will be mapped to a serialized version of the Person instance. Looks like a simple POJO, right? Well, that’s what it is. 216 Chapter 5 ■ Spring reStful ServiCeS A controller that returns an instance of PersonHateoas must define handler methods that populate the PersonHateoas instances with HAREOAS-specific links. In order to do, Spring offers utility methods that allow you to create links by pointing to controller classes, which are grouped under the ControllerLinkBuilder. The controller and the method do nothing special, except that before returning the response, the personHateoas object is populated with its own URI, using utility methods from the ControllerLinkBuilder class that link together in a very readable way. For example, the underlined code snippet in the previous example can be read like this: Add link to which the handler method getPersonHateoasById from the PersonHateoasController class is mapped, with PathVariable id equal to person.getId() to the personHateoas ph instance. The sources for spring-hateoas are available on GitHub at https://github.com/spring-projects/spring-hateoas. In the following code snippet, the linkTo and methodOn methods from ControllerLinkBuilder are statically imported and used to generate the resource link for the Person instance with id=1. ... import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo; import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn; @RestController @RequestMapping(value = \"/hateoas\") public class PersonHateoasController { private Logger logger = LoggerFactory.getLogger(PersonHateoasController.class); @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public HttpEntity<PersonHateoas> getPersonHateoasById( @PathVariable Long id) throws NotFoundException { logger.info(\"-----> PERSON: \" + id); Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } PersonHateoas ph = new PersonHateoas(person); ph.add( linkTo( methodOn(PersonHateoasController.class) .getPersonHateoasById(person.getId()) ).withSelfRel() ); return new ResponseEntity<>(ph, HttpStatus.OK); } } In the previous example, the controller class is the one that takes care of setting the links by inspecting the mappings. But Spring provides another way—by using EntityLinks implementations. To use them, the controller class must be annotated with @ExposesResourcesFor, which makes EntityLinks available 217 Chapter 5 ■ Spring reStful ServiCeS by dependency injection. Also, the configuration class must be annotated with @EnableEntityLinks. The EntityLinks interface API exposes methods to access links pointing to controllers backing an entity type. So the controller becomes this: ... import org.springframework.hateoas.EntityLinks; import org.springframework.hateoas.ExposesResourceFor; @Controller @ExposesResourceFor(Person.class) @RequestMapping(\"/hateoas\") public class PersonHateoasController extends BaseController { private Logger logger = LoggerFactory.getLogger(PersonHateoasController.class); @Autowired private EntityLinks entityLinks; @RequestMapping(value = \"/{id}\", method = RequestMethod.GET, produces = \"application/hal+json\") public HttpEntity<PersonHateoas> getPersonHateoasById (@PathVariable Long id) throws NotFoundException { logger.info(\"-----> PERSON: \" + id); Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } PersonHateoas ph = new PersonHateoas(person); ph.add(entityLinks.linkForSingleResource(Person.class, id).withSelfRel()); return new ResponseEntity<>(ph, HttpStatus.OK); } } And the @EnableEntityLinks annotation is added to the configuration class. Also, to enable HAL support, the EnableHypermediaSupport should be added to the configuration class too. import org.springframework.hateoas.config.EnableEntityLinks; import org.springframework.hateoas.config.EnableHypermediaSupport; import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType; ... @EnableEntityLinks @EnableHypermediaSupport(type= {HypermediaType.HAL}) @Configuration @EnableWebMvc @ComponentScan(basePackages = {\"com.pr, com.pr.web, com.pr.rest, com.pr.hateoas\"}) @ImportResource({\"classpath:spring/app-service-config.xml\", \"classpath:spring/db-config.xml\"}) public class WebConfig extends WebMvcConfigurerAdapter { .... } 218 Chapter 5 ■ Spring reStful ServiCeS The full documentation for spring-hateoas can be found at http://docs.spring.io/spring-hateoas/ docs/current/reference/html/. The Hypermedia Driven REST web service that was just created can be tested with restTemplate, just like any REST service. But to deserialize the HATEOAS links correctly, a custom MappingJackson2HttpMessageConverter must be set for the restTemplate. The ObjectMapper must also be customized to register the Jackson2HalModule implementation provided by Spring HATEOAS. import org.springframework.core.ParameterizedTypeReference; import org.springframework.hateoas.Resource; import org.springframework.hateoas.hal.Jackson2HalModule; ... public class PersonHateoasControllerTest { @Test public void getHateoasPerson() throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.configure (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.registerModule(new Jackson2HalModule()); MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); converter.setSupportedMediaTypes( MediaType.parseMediaTypes(\"application/hal+json\")); converter.setObjectMapper(mapper); RestTemplate restTemplate = new RestTemplate( Collections.<HttpMessageConverter<?>> singletonList(converter)); String url = \"http://localhost:8080/mvc-rest/hateoas/{id}\"; ResponseEntity<PersonHateoas> responseEntity = restTemplate.getForEntity(url, PersonHateoas.class, \"1\"); PersonHateoas personHateoas = responseEntity.getBody(); assertNotNull(personHateoas); assertTrue(personHateoas.hasLinks()); assertEquals(\"http://localhost:8080/mvc-rest/hateoas/1\", ppersonHateoas.getLink(\"self\").getHref()); assertEquals(\"John\", personHateoas.getPerson().getFirstName()); assertEquals(\"Smith\", personHateoas.getPerson().getLastName()); } } 219 Chapter 5 ■ Spring reStful ServiCeS And the response sent to the client will look like this: {\"person\": {\"firstName\":\"John\", \"middleName\":null, \"lastName\":\"Smith\", \"dateOfBirth\":\"1935-10-01\", \"gender\":\"MALE\",\" \"hospital\":{...}, \"identityCard\":{...}, \" links\":{\"self\":{\"href\":\"http://localhost:8080/mvc-rest/hateoas/1\"}} } ! the hospital and identityCard objects are not displayed in the previous example, as their contents are not relevant for it. the content of those properties represents the JSOn serialization of the hospital and identityCard fields specific to the Person instance. their contents are displayed in figure 5-15. The response body contains two properties: \"person\" and \"links\". The \"person\" property value is the JSON representation of the Person instance with id=1. The \"links\" property contains a link and its meaning. The \"rel\":\"self\" tells the client that the link points to the current resource. In this chapter, the fundamentals of creating and consuming RESTful services with Spring MVC were covered, which is enough for the certification exam. Summary After reading this chapter, you should have a proper understanding of how Spring can be used to provide and consume REST services. Here is a simple list of topics that you should keep handy when reviewing your acquired knowledge:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "How do you build a HATEOAS complying service with Spring HATEOAS and MVC?",
    "answer": "220 Chapter 5 ■ Spring reStful ServiCeS Quick Quiz Question 1: What is REST? A. a software design pattern B. a framework C. an architecture style Question 2: Which of the following methods are HTTP methods? A. PUT B. GET C. SUBMIT D. OPTIONS Question 3: What Spring class can be used to access and test REST services? A. RestTemplate B. AsyncRestTemplate C. Both D. None Question 4: What does the RestTemplate handle? A. Resources B. Representations C. Both Question 5: What can be said about the @RestController annotation? A. It is used to declare a controller providing REST services. B. Is annotated with @Controller and @ResponseBody. C. Controller methods annotated with @RequestMapping assume @ResponseStatus semantics by default when the controller is annotated with @RestController. Question 6: What is the effect of annotating a method with @ResponseStatus? A. The default behavior for resolving to a view for methods returning void or null is overridden. B. The HTTP status code matching the @ResponseStatus is added to the response body. C. It forces usage of HTTP message converters. Question 7: Which of the following HTTP message converters are supported by Spring MVC? A. StringHttpMessageConverter B. MappingJackson2HttpMessageConverter, but Jackson2 must be in the classpath C. YamlMessageConverter 221 Chapter 5 ■ Spring reStful ServiCeS Question 8: Which of the following RestTemplates can be used to make a GET REST call to a URL? A. restTemplate.getForObject(...) B. optionsForAllow(...) C. getForEntity(...) D. exchange(..., HttpMethod.GET,...) Question 9: Does the following REST handler method comply with the HATEOAS constraint? @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public Person createPerson(@RequestBody @Valid Person newPerson) { logger.info(\"-----> CREATE\"); Hospital hospital = hospitalManager.findByCode( newPerson.getHospital().getCode()); newPerson.setHospital(hospital); Person person = personManager.save(newPerson); logger.info(\"-----> PERSON: \" + person); return person; } A. Yes, because it returns a representation of the object that was created. B. No, because it does not set the location header to the URI of the created resource. C. This is not a REST handler method. D. No, because a Link object is not added to the returned resource. Practical Exercise The practical exercises for this chapter require you to develop some REST client test methods to check your understanding of implementing RESTful application with Spring MVC. The project module is named 07-pr-rest-practice. An analogous module with proposed solutions exists, which is named 07-pr-rest-solution. The projects and their TODOs are shown in Figure 5-10. 222 Chapter 5 ■ Spring reStful ServiCeS Figure 5-10. Projects associated with this chapter The project is split into packages that contain classes grouped by purpose:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "com.pr.config contains the Java Configuration class used to configure the application.\n• com.pr.hateoas contains classes that describe a hypermedia-driven REST web service\n• com.pr.problem contains classes that handle the exceptions thrown in the application.\n– GlobalExceptionHandler handles exceptions thrown by methods in the\ncontrollers under the com.pr.web package. The restriction is done using\n@ControllerAdvice(basePackages = \"com.pr.web\").\n– NotFoundException is a type of exception thrown when a resource cannot be\nfound.\n– RestExceptionProcessor handles exceptions thrown by methods in the REST\ncontrollers under the com.pr.rest package.\n223\nChapter 5 ■ Spring reStful ServiCeS\n• com.pr.rest contains classes that implement REST services and interceptors.\n– AuditRestInterceptor is an interceptor for REST services that prints simple\nmessages and adds a header to the response before it is written.\n– HospitalsRestController is a REST controller for managing Hospital\nresources.\n– PersonsRestController is a REST controller for managing Person resources.\n• com.pr.web contains the web controllers that receive requests from a browser and\nreturn views. The structure of the project is depicted in Figure 5-11.\nFigure 5-11. Package organization of the 07-pr-rest-practice project module\nThe tests for the rest controllers are located under the same packages as the controllers being tested.\nThe only exception is the com.pr.async that contains a configuration class, a service class, and a test class\nused to test an asynchronous REST method annotated with @Async. You have no TODO tasks in this package;\nthe example is simply provided for you to run it and see how an REST asynchronous is made.\nAll the TODO tasks are in the RestPersonControllerTest class. They cover GET, POST, and DELETE\noperations.\nThe practical exercise for this chapter requires Gradle tasks to be run in parallel, because the REST tests\nrequire the web application to be started. To do this, you have to create an Intellij IDEA Gradle launcher to\nstart the application, and another to stop it. The test cases are run by right-clicking the method you want to\nexecute, and then selecting Run from the menu that appears.\n224\nChapter 5 ■ Spring reStful ServiCeS\nTo create a Gradle launcher, you have to do the following:\n1. In the Gradle Task view, right-click the appStart task. A menu is displayed. Select\nCreate personal-records:07-pr-rest-practice.\n2. In the popup check the Single instance only check box. Modify the name to\nsomething more relevant, like mvc-rest-start.\n3. Click Apply, and then OK. Your launcher should be available in the Intellij IDEA\nlauncher menu.\nThe flow for creating a Gradle launcher is depicted in Figure 5-12. Do the same to create a launcher for\nthe appStop task.\nFigure 5-12. Creating a Gradle launcher\n225\nChapter 5 ■ Spring reStful ServiCeS\nThen from the launcher menu, select the mvc-rest-start launcher and start the application. If the\napplication starts correctly, you should see in the console the following log:\nINFO Jetty 9.2.10.v20150310 started and listening on port 8080\nINFO mvc-rest runs at:\nINFO http://localhost:8080/mvc-rest\nRun 'gradle appStop' to stop the server.\nOpen the link in a browser. You should see the page shown in Figure 5-13.\nFigure 5-13. The mvc-rest web application\nThe web application will help you verify that your REST requests have executed correctly.\nOnce you have the web application up, you can go ahead and try to solve the TODO tasks. There are\neight TODOs, numbered from 15 to 22, that require you to perform certain types of REST requests.\n! get requests can be done directly in the browser, so if you want to get creative with get reSt handler\nmethods, you can test them in a browser. for example, try to access http://localhost:8080/mvc-rest/\nrest-persons/id/1. You should see a JSOn reply like the one depicted in the figure 5-14.\n226\nChapter 5 ■ Spring reStful ServiCeS\nFigure 5-14. JSON response for a GET REST request\nTo format JSON representations properly for display, a @MappingJackson2HttpMessageConverter bean\nhas to be defined and configured accordingly. There are two ways of doing this:\n• Call setPrettyPrint on the @MappingJackson2HttpMessageConverter\n@Bean\npublic MappingJackson2HttpMessageConverter\nmappingJackson2HttpMessageConverter() {\nMappingJackson2HttpMessageConverter converter\n= new MappingJackson2HttpMessageConverter();\nconverter.setObjectMapper(objectMapper());\nconverter.setPrettyPrint(true);\nreturn converter;\n}\n@Bean\npublic ObjectMapper objectMapper() {\nreturn new ObjectMapper();\n}\n227\nChapter 5 ■ Spring reStful ServiCeS\n• Enable the indentation of the serialization output by calling enable on the\nobjectMapper set for the @MappingJackson2HttpMessageConverter bean\n@Bean\npublic ObjectMapper objectMapper() {\nObjectMapper objMapper = new ObjectMapper();\nobjMapper.enable(SerializationFeature.INDENT_OUTPUT);\nreturn objMapper;\n}\n! pOSt and Delete requests can be tested using a firefox plugin called poster.14 figure 5-15 shows a reSt\npOSt request and response done with poster.\nFigure 5-15. POST REST request and response done with Poster. You have to copy and paste the RequestBody\ninto the Poster content text area\n14The plugin can be found at https://addons.mozilla.org/en-US/firefox/addon/poster/.\n228\nChapter 6\nSpring Web with AJAX\nThe topic of this chapter is not a subject in the certification exam, but it is useful to know all the tools that\ncan be used to develop a web application in the most efficient way. A properly designed user interface\nshould ensure that a request is sent to the server only when the content of the request is complete and valid\nso that it can be used by a server operation. Using requests between the client and the server application is\nnot a good practice. It is time-consuming and can go wrong when the network connection is unstable.\nWhat Is AJAX?",
    "answer": "AJAX is an acronym for asynchronous JavaScript and XML, but over the years, this term has grown and means so much more than the technologies that make the acronym. AJAX describes the way that various web technologies can make web applications highly responsive and provide the user with an almost desktop-like interaction. Basically, web applications developed with AJAX can provide rich interaction, just-in-time information, and dynamic information without a page refresh. Of course, this comes with programming complexity; some of the logic that happens on the server must be moved on the client side, where the logic must be implemented in JavaScript. The most obvious example is the validation of user input. There's no point in sending invalid data to the server, right?1 Before AJAX, a web application functioned like this: 1. The user requested a page using a browser. 2. The server where the web application was installed created and sent a response to be rendered in the browser. 3. The user sent some data to the server. 4. The server received the data and validated it. If the validation failed, the data and validation errors were put into a response that was sent back to the browser. 5. The response was received by the browser, which displayed the new page. 1There are JavaScript libraries that can validate form user input before submission; for example, the jQuery validation plugin (http://jqueryvalidation.org). 229 Chapter 6 ■ Spring Web With aJaX This happens for any user request; the whole page is rebuilt and displayed every time a response is received from the server. It is quite a time-consuming process, depending on the health of the network, and the user may see an annoying flickering as the web pages are displayed. Figure 6-1 depicts the traditional pre-AJAX web application communication flow with the client. Figure 6-1. Traditional pre-AJAX web application communication flow The validation case was chosen because an example of an editing form with validation was presented in Chapter 3 (the 05-pr-mvc-form module). The validation was implemented on the server side using the @Valid annotation. This can be easily seen by installing the Firebug plugin in Firefox (see the Net tab). All the steps mentioned next are depicted in Figure 6-2. 1. Start 05-pr-mvc-form-solution. 2. Open the Firebug console (1), click the Net tab (2), and then click (3) Enable. 3. Click the Persons menu item (4). Select a user (5), click the link to see the details, and then click the Edit link (6). 4. Click the Clear option (7) in the Firebug console to make sure that you do not have previous requests polluting the console. 5. Delete the first name (8) and last name (9). Click Save (10) and then analyze what is shown in the Net console. 230 Chapter 6 ■ Spring Web With aJaX Figure 6-2. Steps to analyze the communication between client and server 231 Chapter 6 ■ Spring Web With aJaX After performing the last step, you should see the POST request in the console. If you expand it, you see the response sent by the server (returned by the DispatcherServlet), a new HTML page containing the HTML code of the page, plus the validation elements. There are also a few GET requests for the static contents of the page, which are handled by the default servlet container for static resources. Figure 6-3 depicts the last communication with the server. Figure 6-3. The final step of communication, validation failure response 232 Chapter 6 ■ Spring Web With aJaX In the preceding example, a POST request was sent to the server. The validation was executed on the server and failed, so no data was saved. Basically, this was a useless request, and the full page was rebuilt and redisplayed just to show the user what was wrong with the data. The GET requests to retrieve the header and footer information, and the styling *.css files, are also useless, because they are used to retrieve information already present in the page. These useless requests can be avoided either by using caching or by making sure only the form part of the page is dynamic. AJAX can help with this. A request can be sent to the server with the form data by using an AJAX request; the data retrieved from the server can be used to rebuild only a part of the page by using an AJAX callback. Or even better, validation can be performed on the client side by using JavaScript (pure or competent JavaScript libraries like the jQuery validation plugin). And an AJAX request sends data to the server, which is processed successfully. This is just an example. AJAX can also be used when searching data. An autocomplete behavior can be implemented for the search field by using an AJAX call to build a list (server side) and afterward to display the list using JavaScript (usually below the autocomplete input).2 One of the most popular JavaScript frameworks is jQuery3 because it is small and provides a wide range of functionalities—document traversal and manipulation, event handling, and animations—in a very practical way. Most popular JavaScript frameworks are actually developed using jQuery.4 A new way of developing web applications nowadays is to totally decouple the Web from server functionality, keeping all web logic on the client and all back-end logic on the server, reducing communication between the client and the server as much as possible, and handling requests in a manner similar to REST. AJAX remoting was not supported until Spring 3. JSON also became very popular once jQuery took off and it is now the most common format for performing data exchange between a client and a server. ! a sample of this behavior is implemented in the RestSearchController that you can find in the 08-pr-ajax- solution. it is presented in detail later in the chapter. Making AJAX Requests AJAX requests can be made using a JavaScript object of type XMLHttpRequest, which was designed by Microsoft and adopted by Mozilla, Apple, and Google, and standardized in W3C5. All modern browsers support it. To create an instance of XMLHttpRequest, you just instantiate it: var xhr = new XMLHttpRequest(); 2jQuery UI provides a plugin that to implement the behavior with little effort (https://jqueryui.com/ autocomplete/). 3The official jQuery site (https://jquery.com). 4Examples include jQuery UI (https://jqueryui.com), Bootstrap (http://getbootstrap.com), AngularJS (https://angularjs.org). 5See http://www.w3.org/TR/XMLHttpRequest/. 233 Chapter 6 ■ Spring Web With aJaX The xhr object can make requests to a server and update only a portion of the page. Figure 6-4 depicts XMLHttpRequest. When the client sends a request using this type of object, the server responds by populating the xhr.responseText property. Figure 6-4. AJAX request diagram A search request for a person with a first name that contains the letter a can be send to the server using a function similar to the following. Everything after ? are request parameters. <script type=\"text/javascript\"> var url=\"${personsUrl}/ajax?fieldName=firstName\" ¨&fieldValue=a\" ¨&exactMatch=false\"; var xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { displayResults(xhr.response); } }; </script> The xhr.send() method has multiple forms. It sends the request body to the URL that a connection was previously open to by calling xhr.open(\"GET\", url). In the previous example, there was no request body to send, because all the request parameters were in the URL. The readyState can have different values, but the one in the fourth example tests if the request has finished and the response is ready. The status property is the HttpStatus value that was mentioned in Chapter 3; it is result code from the server. If you want to know more about the XMLHttpRequest type, you can take a look at the full specifications at https://xhr.spec.whatwg.org/. But since jQuery was introduced, there's been no need to use it explicitly because there are better and more practical ways to make AJAX requests. 234 Chapter 6 ■ Spring Web With aJaX ! an example for making a request using an object of type XMLHttpRequest can be found in the 08-pr- ajax-solution. Just look for the legacySearch JavaScript function in the search.jsp file. to test that function, just comment the $.getJSON call in line 112 and uncomment the legacySearch call in line 113. restart the application and try it. but you might want to do this after finishing reading this chapter, when your understanding of jQuery, JavaScript, and the logic of the application will make things easier for you. As you can see, using objects of type XMLHttpRequest to perform AJAX calls is quite cumbersome. A lot of problems might appear when the response type is something more complex than text; like JSON, for example, because a lot of extra code has to be written to perform conversions that get the response body in a proper format. The methods and properties of the XMLHttpRequest class used in the previous example are explained in Table 6-1. Table 6-1. XMLHttpRequest Methods and Properties Method Description open(http method, URL, Initializes a request. This method is to be used from JavaScript code. [asynch-Flag, username, password]) send(content in various formats) This method sends a request. The content can be null. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. onreadystatechange This property returns an EventHandler every time the readyState attribute changes. readystate Returns an unsigned short, the state of the request, and the API. (http://www.w3.org/TR/XMLHttpRequest/#xmlhttprequest) defined values are: 0 -> UNSENT : open() was not called yet 1 -> OPENED : send() was called 2 -> HEADERS_RECEIVED : send() was called and headers and status are available 3 -> LOADING : downloading; responseText holds partial data 4 -> DONE : the request was completed status This property is of type unsigned short and contains the HTTP result code. Most common values are 200 -> ok 201 -> Created 400 -> bad request 404 -> not found 403 -> forbidden 500 -> internal server error responseText This property contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent. 235 Chapter 6 ■ Spring Web With aJaX Introducing jQuery In the practice exercise, you will perform a search request that updates only the content of a <div> element. The JSP page is /webapp/WEB-INF/persons/search.jsp. The contents are as follows: <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %> <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> <h2> <spring:message code=\"persons.search.title\"/> </h2> <div class=\"form\"> <spring:url value=\"/persons\" var=\"personsUrl\"/> <sf:form modelAttribute=\"criteriaDto\" method=\"get\"> <table> <tr> <th> <label for=\"fieldName\"> <spring:message code=\"label.Criteria.fieldname\"/> : </label> </th> <td> <sf:select path=\"fieldName\" id=\"fieldName\"> <sf:option value=\"firstName\"> <spring:message code=\"label.Person.firstname\"/> </sf:option> <sf:option value=\"lastName\"> <spring:message code=\"label.Person.lastname\"/> </sf:option> <sf:option value=\"dob\"> <spring:message code=\"label.Person.dob\"/> </sf:option> <sf:option value=\"pnc\"> <spring:message code=\"label.ic.pnc\"/> </sf:option> <sf:option value=\"hospital\"> <spring:message code=\"label.Hospital.name\"/> </sf:option> </sf:select> </td> <td></td> </tr> <tr> <th> <label for=\"fieldValue\"> <span class=\"man\">*</span> <spring:message code=\"label.Criteria.fieldvalue\"/> : </label> 236 Chapter 6 ■ Spring Web With aJaX </th> <td><sf:input path=\"fieldValue\" id=\"fieldValue\"/> <em> <br><spring:message code=\"label.dateFormat.accepted\"/> </em> </td> <td><label class=\"error\" id=\"fieldValueError\"/> </td> </tr> <tr> <td></td> <td colpan=\"2\"> <sf:checkbox path=\"exactMatch\" id=\"exactMatch\"/> <spring:message code=\"label.Criteria.exactmatch\"/> </td> </tr> <tr> <td> <input id=\"searchButton\" type=\"submit\" value=\"<spring:message code='command.search'/>\"/> </td> <td> <input id=\"cancelButton\" type=\"submit\" value=\"<spring:message code='command.cancel'/>\"/> </td> </tr> <tr> <td colspan=\"3\"> <!-- HTML element that will be dynamically populated --> <label class=\"error\" id=\"noResults\"/> </td> </tr> </table> </sf:form> </div> <!-- The div with results, that will be loaded dynamically --> <div id=\"resultDiv\"> <table> <thead> <tr> <td> <spring:message code=\"label.ic.pnc\"/> </td> <td> <spring:message code=\"label.Person.firstname\"/> </td> <td> <spring:message code=\"label.Person.lastname\"/> </td> </tr> </thead> 237 Chapter 6 ■ Spring Web With aJaX <tbody id=\"resultTable\"> </tbody> </table> </div> <script type=\"text/javascript\"> $(document).ready(function () { // JavaScript content to make the page dynamic } </script> A few Spring form elements have been replaced with HTML elements that will be displayed and populated by JavaScript methods. HTML elements from a page can be populated or emptied, hidden or displayed using JavaScript. If you click the Search button, a request (only one) is made to retrieve results, and the resultTable is populated and the resultDiv is displayed. Figure 6-5 depicts an AJAX request to search for people. The result table is populated and displayed with the response returned. As you can see, no other requests are necessary. This is the power of AJAX: a practical way of retrieving from server only the information that is really needed. Figure 6-5. AJAX request 238 Chapter 6 ■ Spring Web With aJaX The JavaScript code that is missing from the earlier code snippet is written using jQuery. By providing functions that are more practical and easier to use, this framework helps the developer to focus on the key aspects of making a request: which resource is requested from the server (the URI), which parameters are to be used for the request, and which callback method is to be executed when the response is received.6 That is what jQuery is—a library or a collection of JavaScript functions that a developer can use to avoid writing complicated JavaScript logic. jQuery provides the following features:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is jQuery and how can it be used to access Spring applications?",
    "answer": "Quick Quiz Question 1: What is AJAX? A. a framework to create responsive web pages B. a set of standards on how to create responsive web pages C. an acronym for Asynchronous JavaScript and XML D. a set of technologies that can be used to create highly responsive web applications Question 2: What can be said about jQuery? A. It is a tag library. B. It is a set of technologies to create responsive web pages. C. It is the most popular JavaScript library. Question 3: What jQuery method can be used to make a GET request? A. $.get B. $.getJSON C. $.ajax D. $.post 12Oracle custom tags creation; see https://docs.oracle.com/javaee/7/tutorial/. 253 Chapter 6 ■ Spring Web With aJaX Question 4: What is a custom JSP tag? A. a custom tag is a user-defined JSP language element B. a special class that handles JSP tasks execution Practical Exercise The practical exercises for this chapter require you to develop a REST handler method to search and return a list of people matching the criteria sent from the browser, as well as a few JavaScript functions using jQuery to display results and errors. You'll use the 08-pr-ajax-practice project module. 08-pr-ajax-solution is analogous module with a proposed solution. This module also contains extra implementations that were mentioned earlier in the chapter. The TODO tasks for this chapter are shown in Figure 6-9. Figure 6-9. TODO tasks for Spring with AJAX practice module 254 Chapter 6 ■ Spring Web With aJaX The PersonsSearchController is the controller used to handle requests that come from the search.jsp page. The PersonsController contains a single method that is used to retrieve a person's information and return it to the client in JSON format. The rest of the project setup (configuration and tiles) are the same as in previous modules. No extra settings are needed to handle AJAX requests. The application is configured via Jetty to run at http://localhost:8080/mvc-ajax. Just run the application using 'gradle appStart' and stop it using 'gradle appStop'. After you complete the proposed TODOs, as a bonus exercise, you can try creating the start custom tag described in the last section of this chapter. 255 Chapter 7 Spring Web Flow As time went by, and more and more services could remotely use web applications, the web applications became more complex—and designing and implementing them became a cumbersome process. Most applications imply creating objects and passing them through several states, or creating objects depending on each other. Spring Web Flow (SWF) is a component of the Spring Framework’s web stack that was created to help develop complex applications by reducing the difficulty in development. The Spring Web Flow complements the @Controller model and provides the infrastructure needed to build complex web applications that support controlled page navigation and state transition; all of this adds up to a rigorously defined conversation between the end user and the application. It is possible to write such applications with any other web technology, but the definition of a flow is interconnected with the rest of the web components; it is scattered all over the implementation, which makes refactoring and maintenance a real pain. What Spring Web Flow brings to the table is the possibility to define flows as separate components detached from the rest of the implementation—web-specific classes and views. The flow components can be defined and used similar to the way beans are used in Spring. Flow definitions can be inherited, thus implementing flow hierarchies. Flows can be reused and customized as needed. As this book being is written, the current version of Spring Web Flow is the 2.4.2.RELEASE,1 so this is the version added as a dependency for the Web Flow chapter sources. This version includes the ability to configure flows using Java Configuration and many other features. The main library is called spring-webflow. When building the project for the first time, the spring-js and spring-binding transitive dependencies should be downloaded too. What Is a Flow? A flow models the sequence of steps necessary to perform a task. The most common and simple flow example is ordering items on the Internet. This operation requires the following steps in which the user is guided through: choose item, proceed to checkout, create an account or log in to your account, insert shipping detail, insert payment details, and approve payment to complete the process. Each failure to provide the correct information stops the user from advancing to the next step. If the user wants to go back and review a previous screen, he can do so, unless configured otherwise. But there are web operations that depend on the data received from the user to direct them from one flow to another. 1The official site of the project (http://projects.spring.io/spring-webflow/) is usually updated late, so it might show an earlier version; the most recent release can be found on the Maven public repositpry site at http://mvnrepository.com. 257 Chapter 7 ■ Spring Web FloW By using the Personal Records Manager at the completion of this chapter, you will be able to create an account and personal data for a person. This operation requires you to design a flow that executes the following steps: 1. Insert personal data. 2. If the hospital where the user was born is in the system, select it. 3. Otherwise, the user is directed to the page where he can create a Hospital instance. 4. Return to the previous step and complete creating the Person instance. 5. Insert IdentityCard data. 6. Review data. 7. If the person is an adult (age > 18), add an account. These steps are depicted in Figure 7-1. Figure 7-1. Personal Records Manager web flow In Spring Web Flow, a flow consists of a series of steps called states. A flow will always have only one start point and one or more end points. Leaving one state and passing into another can be restricted by the result of a conditional expression. Entering a new state usually results in a view being displayed to the user. The user works with the view, causing user events to occur. The user events trigger transitions between states, which in turn cause navigation to another view. 258 Chapter 7 ■ Spring Web FloW Aside from making development easier and clearer, Spring Web Flow was created to solve the following problems related to complex web navigation:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Duplicate submissions.\n• Pop-up window support within a flow.\n• State synchronization problems between the server and the client caused by using\nthe browser’s back and refresh buttons.\n• State collisions between windows.\n• Stale session state. (A session can end up containing inactive data, when a timeout is\nset. The inactive items must be precisely identified and purged.)\n• Short-circuiting navigation rules. (Possibility to jump over steps in the navigation,\ndepending on navigation conditions.)\nWeb Flow Architecture\nIn Spring Web Flow, flows are defined using an XML-based flow definition language. The backing\nclasses follow the model already established by Spring MVC. Spring Web Flow provides its own classes to\nidentify handler methods matching flow execution requests and resolving views. The DispatcherServlet is\nstill the front controller when the application is servlet based. For implementation with portlets, there is an\nanalogous implementation provided with DispatcherPortlet(s) as entry points. The similarities with the\nSpring MVC model can be observed in Figure 7-2.\nFigure 7-2. The Spring Web Flow backing classes\n259\nChapter 7 ■ Spring Web FloW\nThe FlowController class is the adapter between the Spring MVC Controller layer and the Spring Web\nFlow engine. Its responsibility is to provide implementation so that Spring Web Flow can run embedded as a\ncontroller within a DispatcherServlet. So basically, the FlowController is itself a front controller for Spring\nWeb Flow.\nThe FlowHandlerMapping maps all flow requests to the appropriate handlers using\nFlowDefinitionRegistry. The FlowHandlerAdapter takes care of executing the flow handler methods in a\nservlet environment using the FlowExecutor implementation.\nAfter they do their jobs, the DispatcherServlet uses the FlowViewResolver interface to resolve a view\nfrom the state of an executing flow.\nWhen working with flows, each flow definition is declared in a specific configuration file and is\nregistered in the system by the FlowDefinitionRegistry. For each flow in the system, a configuration file is\ncreated and placed in the same directory with all resources implied in the flow execution: views templates,\nproperty files, and others. In Figure 7-3, you can see how the files are organized in the practice project for\nthis chapter.\nFigure 7-3. Personal Records Manager web flow configuration file and resources\n260\nChapter 7 ■ Spring Web FloW\nThe newPerson-flow.xml configuration file contains the states that the users are directed through to\ncreate a new person. For now, the empty file is presented containing only the Spring Web Flow namespace\nused to define flow elements:\n<?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <!-- states and actions will be placed here later --> </flow> The flows are exposed to the client as web resources. The client starts flows by accessing these resources. For example, accessing http://localhost:8080/webflow-basic/persons/newPerson starts the newPerson flow. (The reason the URL has that particular structure is explained later.) Starting a flow actually means starting a new flow execution, meaning an execution context for the task currently in progress is created. The execution context is user session-scoped, meaning all the variables and data needed for the execution of the task is kept in the user session, unless an execution step requires otherwise. (Sometimes data can be saved to the database and removed from the session.) Web Flow Internal Logic When the flow starts executing, you can use the URL changing to http://localhost:8080/webflow-basic/persons/newPerson?execution=e1s1 The parameter execution is the session-scoped execution key. Its value contains the flow execution identifier (e1) and the identifier of the execution step that is currently in progress (s1). Every time the flow progresses a step, the step identifier is incremented. Every time a new flow execution is started, the execution identifier is incremented. A user resumes flow executions by clicking buttons in the interface—buttons (or links) that have events associated with them using the name property. For example: <button id=\"newPersonButton\" name=\" eventId proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> So when the button with the newPersonButton id is clicked, a request is sent to the URL. .../persons/newPerson?execution=e1s1&_event_id=proceed The data provided by the user is bound to the flow context. The flow handles the event, processes the data as defined, and decides what to do next based on the definition of the flow: display a new view to the user, display the same view, and remain in the same step of execution if validation failed or ends the flow. When a flow execution has ended, the execution cannot be resumed; this implies that the transaction cannot be completed multiple times. After a flow execution ends, the flow state is automatically cleaned. The interaction between a client and a flow always consists of two separate steps: the client will request a resource or activate (trigger) an event and the flow will redirect to the appropriate state. This means that each web flow interaction involves two requests: the client request and the flow redirect request. This has another implication: the data submitted by the initial request will not be available after the redirecting is 261 Chapter 7 ■ Spring Web FloW done and the next view has already been rendered. But there are ways of persisting the data across requests when using web flows; this is covered later in the chapter. In Figure 7-4, the interaction between the client and a flow is displayed. Figure 7-4. Schema of an interaction between the client and a flow Configuration and Infrastructure Beans Spring provides two ways of configuring the environment in which the web flow components can be used: using an the XML namespace and defining the infrastructure beans in an webflow-config.xml file, or using Java Configuration annotations by defining a configuration class that extends a specific Spring class. ■ ! the configuration file can be named in whatever way the developer desires, as long as it is relevant in the context of the developed application. the beans can be defined in any other Spring configuration file already existing in the application; but the recommended approach and best practice is to keep infrastructure beans definitions grouped by their purpose. in the application used for practice with this book, the beans are grouped as follows:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "MVC infrastructure beans in mvc-config.xml\n• application custom beans in app-config.xml\n• Web Flow infrastructure beans in webflow-config.xml\n• Security infrastructure beans in security-config.xml\n262\nChapter 7 ■ Spring Web FloW\nWhen configuring an application that uses Web Flow, there are roughly three steps that have to be\ncovered:\n1. A flow executor and a flow registry bean have to be defined and configured to\nmatch the structure of the application so that the flows can be executed correctly\nby Spring Web Flow.\n2. A flow adapter and a flow mapping bean have to be defined and added to the\nlist of existing handler mapping and handler adapter beans for the Spring MVC\nconfiguration to enable flow handling by Spring MVC.\n3. An MvcViewFactoryCreator bean has to be created and configured to use the\nbean view resolvers already defined in the application.\nThe following two sections cover how this is done when using XML and Java Configuration.\nConfiguration Using XML\nAs mentioned in previous chapters, the Spring MVC configuration infrastructure beans are defined\nin the examples of this book into a file named mvc-config.xml. In this file, FlowHandlerMapping and\nFlowHandlerAdapter bean definitions have to be added:\n<?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <mvc:annotation-driven conversion-service=\"typeConversionService\" validator=\"validator\"/> <bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/> <!-- Define a custom ConversionService --> <bean id=\"typeConversionService\" class=\"o.s.format.support.FormattingConversionServiceFactoryBean\"> ... </bean> 263 Chapter 7 ■ Spring Web FloW <!-- other Spring MVC specific beans, look in Chapter 3 for reference --> ... <!-- Maps requests to flows in the flowRegistry; e.g. a path of /persons/newPerson looks for a flow with id \"persons/newPerson\" --> <bean id=\"flowMappings\" class=\"org.springframework.webflow.mvc.servlet.FlowHandlerMapping\" p:order=\"-1\" p:flowRegistry-ref=\"flowRegistry\"/> <!-- Dispatches requests mapped to flows to FlowHandler implementations --> <bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerAdapter\" p:flowExecutor-ref=\"flowExecutor\"/> </beans> In the previous example, because <mvc:annotation-driven/> is used, the annotation-driven Spring MVC Controller programming model is automatically enabled, and no other HandlerMapping implementation needs to be defined. However, the FlowHandlerMapping must be the first HandlerMapping implementation used to try to retrieve a mapping to make sure that the flow is identified correctly; that’s why order=\"-1\" is used to set the highest priority in the handler mappings list. This class returns null in the case of no flow id match, allowing the next handler mapping in the chain to execute. In the webflow-config.xml file, the Spring Web Flow–specific beans are defined and the specific namespace are used: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:webflow=\"http://www.springframework.org/schema/webflow-config\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/webflow-config http://www.springframework.org/schema/webflow-config/spring-webflow-config.xsd\"> <!-- Executes web flows --> <webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\" /> <!-- Contains the flows defined by this application --> <webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\" flow-builder-services=\"flowBuilderServices\"> <webflow:flow-location-pattern value=\"**/*-flow.xml\" /> </webflow:flow-registry> <!-- Configures services needed to build flow definitions --> <webflow:flow-builder-services id=\"flowBuilderServices\" view-factory-creator=\"mvcViewFactoryCreator\" conversion-service=\"conversionService\" development=\"true\" /> 264 Chapter 7 ■ Spring Web FloW <!-- Configures Web Flow to render Tiles views resolved by Spring MVC --> <bean id=\"mvcViewFactoryCreator\" class=\"org.springframework.webflow.mvc.builder.MvcViewFactoryCreator\"> <property name=\"viewResolvers\" ref=\"tilesViewResolver\" /> <property name=\"useSpringBeanBinding\" value=\"true\"/> </bean> <!-- Configures Web Flow to automatically convert custom types (using the same converter as for Spring MVC) --> <bean id=\"conversionService\" class=\"org.springframework.binding.convert.service.DefaultConversionService\"> <constructor-arg ref=\"typeConversionService\" /> </bean> </beans> The Spring webflow-config namespace provides XML elements that make defining Spring Web Flow components more practical and more readable for the user, but a more detailed explanation is needed for the preceding configuration.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "flowExecutor: This bean created is of type FlowExecutorImpl and it uses the\nflowRegistry bean to identify all flows eligible for execution. This bean is the\nentry point into the Web Flow system, as it manages starting and resuming flow\nexecutions. When an executor bean is created, Spring automatically looks for a flow\nregistry bean named flowRegistry, so the preceding definition can be simplified to\n<webflow:flow-executor id=\"flowExecutor\"/>\nAlso, because this is the central bean of the Spring Web Flow engine, listeners\ncan be registered for it to verify rights to perform specific execution steps or audit\nthe execution steps for debugging purposes.\n<webflow:flow-executor id=\"flowExecutor\">\n<webflow:flow-execution-listeners>\n<webflow:listener ref=\"secureFlowExecutionListener\" />\n<webflow:listener ref=\"auditFlowExecutionListener\" />\n<webflow:flow-execution-listeners>\n</webflow:flow-executor>\n...\n<bean id=\"secureFlowExecutionListener\"\nclass=\"org.springframework.webflow.security.SecurityFlowExecutionListener\"/>\n<bean id=\"auditFlowExecutionListener\"\nclass=\"com.pr.audit.AuditFlowExecutionListener\"/>\n■ ! the flow execution listeners can be configured to be applied only on certain flows; for example:\n<webflow:listener ref=\"secureFlowExecutionListener\"\ncriteria=\"administrativeFlow1, administrativeFlow2\"/>\n265\nChapter 7 ■ Spring Web FloW\nthe flowExecutor can be configured to tune flow execution persistence settings by adding a customized\ndefinition for flow-execution-repository.\n<webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\">\n<webflow:flow-execution-repository max-executions=\"5\"\nmax-execution-snapshots=\"30\" />\n</webflow:flow-executor>\nthe max-executions property is used to configure the maximum number of persistent flow executions allowed\nper user session. When the maximum number of executions is exceeded, the oldest execution is removed.\nthe max-execution-snapshots property is used to configure the maximum number of history snapshots\nallowed per flow execution. history snapshots enable browser back button support. When snapshotting is\ndisabled, pressing the browser back button will not work. it will result in using an execution key that points to a\nsnapshot that has not been recorded.\n• flowRegistry: Each flow definition registered in this registry bean is assigned a\nunique identifier. The base-path property is used specify the root directory, under\nwhich all the flow definition files are found; usually this is the WEB-INF directory.\nThe flow-location-pattern further narrows the search for the flow definitions,\nproviding a wildcard template file name for the flow definition files. But flow\ndefinitions can be also registered one at a time using flow-location elements. For\nexample:\n<webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\"\nflow-builder-services=\"flowBuilderServices\">\n<webflow:flow-location path=\"persons/newPerson/newPerson-flow.xml\"/>\n</webflow:flow-registry>\n• flowBuilderServices: This bean registers custom implementations of services\nneeded to build flow definitions: view resolvers, data convertors, formatters,\nvalidators, and others. In version 2.4.0.RELEASE, the validation-hints were added,\nso flow definition can apply partial validation on the model through the validation-\nhints attribute supported on view state and transition elements. This bean was\nmodified to add a property named validation-hint-resolver that can be used to\nset a custom validation hints resolver. (An example is presented later in the book.)\n■ ! the development=\"true\" is quite important, because as you will solve the practice exercises, you might\nnot want to restart the application every time you make a change to a flow definition. Setting the development\nproperty to \"true\" ensures that changes to a flow definition is autodetected and results in a flow refresh.\n266\nChapter 7 ■ Spring Web FloW\n• mvcViewFactoryCreator: This bean is used by a FlowBuilder to configure a flow’s\nview states with Spring MVC–based view factories. In this case, the tiles view\nresolver is injected into it, so it can be used to resolve view states using it. The\nuseSpringBeanBinding property is set to “true” to enable the same binding system\nused by the Spring MVC in a Web Flow environment.\n• conversionService: This bean is a wrapper for the conversion service bean used by\nSpring MVC, which is provided to the flowBuilderServices bean to be used during\na flow execution.\nConfiguration Using Annotations\nFor the 09-pr-webflow-basic-practice, a full Java Configuration is used; no web.xml. Three classes were\ndefined for such proposes under the com.pr.config package. Figure 7-5 depicts all three classes, their\nparents, and the relationship between them.\nFigure 7-5. Configuration classes for Personal Records Manager project when Spring Web Flow is used\n■ ?",
    "answer": "Can you tell which class takes care of a certain part of the infrastructure just by looking at the diagram in Figure 7-5? 267 Chapter 7 ■ Spring Web FloW Each class covers a part of the infrastructure setup needed to run a Spring web application without a web.xml file that uses Spring Web Flow.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The MvcConfig class encapsulates the Spring MVC infrastructure bean definitions\nthat were covered in Chapter 3. To plug in the Web Flow beans, some modifications\nwere done. The webFlowConfig was injected so the handler mapping and handler\nadapter specific to flows could be configured.\n...\nimport org.springframework.webflow.mvc.servlet.FlowHandlerAdapter;\nimport org.springframework.webflow.mvc.servlet.FlowHandlerMapping;\n@Configuration\n@EnableWebMvc\npublic class MvcConfig extends WebMvcConfigurerAdapter {\n@Autowired\nprivate WebFlowConfig webFlowConfig;\n//other Spring MVC infrastructure beans: formatters, interceptors,\n// resolvers, etc. Review Chapter 3 for reference.\n...\n//Web Flow specific infrastructure beans\n@Bean\npublic FlowHandlerMapping flowHandlerMapping() {\nFlowHandlerMapping handlerMapping = new FlowHandlerMapping();\nhandlerMapping.setOrder(-1);\nhandlerMapping.setFlowRegistry(this.webFlowConfig.flowRegistry());\nreturn handlerMapping;\n}\n@Bean\npublic FlowHandlerAdapter flowHandlerAdapter() {\nFlowHandlerAdapter handlerAdapter = new FlowHandlerAdapter();\nhandlerAdapter.setFlowExecutor(this.webFlowConfig.flowExecutor());\nhandlerAdapter.setSaveOutputToFlashScopeOnRedirect(true);\nreturn handlerAdapter;\n}\n}\nThe WebFlowConfig class encapsulates the Spring Web Flow infrastructure\nbean definitions. To align these beans with Spring MVC, the mvcConfig\nbean was injected, so formatter, validators, and view resolvers could be\naccessed and set to use during flow executions. This class extends the\nSpring specialized AbstractFlowConfiguration class, which does not\nprovide any configuration itself but provides access via protected methods\nto builders for flow executor (getFlowExecutorBuilder()), flow registry\n(getFlowDefinitionRegistryBuilder()), and flow builder services\n(getFlowBuilderServicesBuilder()).\n268\nChapter 7 ■ Spring Web FloW\n...\nimport org.springframework.webflow.config.AbstractFlowConfiguration;\nimport org.springframework.webflow.definition.registry.FlowDefinitionRegistry;\nimport org.springframework.webflow.engine.builder.support.FlowBuilderServices;\nimport org.springframework.webflow.executor.FlowExecutor;\nimport org.springframework.webflow.mvc.builder.MvcViewFactoryCreator;\n@Configuration\npublic class WebFlowConfig extends AbstractFlowConfiguration {\n@Autowired\nprivate MvcConfig mvcConfig;\n@Bean\npublic FlowExecutor flowExecutor() {\nreturn getFlowExecutorBuilder(flowRegistry())\n// apply the listener for all flow definitions\n.addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\")\n.build();\n}\n@Bean\npublic FlowDefinitionRegistry flowRegistry() {\nreturn getFlowDefinitionRegistryBuilder(flowBuilderServices())\n.setBasePath(\"/WEB-INF\")\n.addFlowLocationPattern(\"/**/*-flow.xml\")\n.build();\n}\n@Bean\npublic FlowBuilderServices flowBuilderServices() {\nreturn getFlowBuilderServicesBuilder()\n.setViewFactoryCreator(mvcViewFactoryCreator())\n.setValidator(this.mvcConfig.validator())\n.setConversionService(conversionService())\n.setDevelopmentMode(true)\n.build();\n}\n@Bean\npublic MvcViewFactoryCreator mvcViewFactoryCreator() {\nMvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator();\nfactoryCreator.setViewResolvers(Arrays.<ViewResolver>asList(\nthis.mvcConfig.tilesViewResolver()));\nfactoryCreator.setUseSpringBeanBinding(true);\nreturn factoryCreator;\n}\n269\nChapter 7 ■ Spring Web FloW\n@Bean\nDefaultConversionService conversionService() {\nreturn new DefaultConversionService(\nconversionServiceFactoryBean().getObject());\n}\n@Bean\nFormattingConversionServiceFactoryBean conversionServiceFactoryBean() {\nFormattingConversionServiceFactoryBean\nfcs = new FormattingConversionServiceFactoryBean();\nSet<Formatter> fmts = new HashSet<>();\nfmts.add(this.mvcConfig.dateFormatter());\nfmts.add(this.mvcConfig.hospitalFormatter());\nfcs.setFormatters(fmts);\nreturn fcs;\n}\n}\n■ ! to tune the flow execution persistence settings in Java, the following configuration has to be present in\nthe WebFlowConfig class:\n@Bean\npublic FlowExecutor flowExecutor() {\nreturn getFlowExecutorBuilder(flowRegistry())\n.addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\")\n.setMaxFlowExecutions(5)\n.setMaxFlowExecutionSnapshots(30)\n.build();\n}\n• The WebInitializer class provides the Servlet 3.0 configuration that replaces the\nweb.xml file. The configuration classes are added to the array of configuration classes\nused to create the application context by providing the proper implementation for\nthe getRootConfigClasses.\npublic class WebInitializer extends\nAbstractAnnotationConfigDispatcherServletInitializer {\n@Override\nprotected Class<?",
    "answer": "> getRootConfigClasses() { return null; } @Override protected Class<?> getServletConfigClasses() { return new Class<?>{ MvcConfig.class, WebFlowConfig.class }; } 270 Chapter 7 ■ Spring Web FloW @Override protected String getServletMappings() { return new String{\"/\"}; } @Override protected Filter getServletFilters() { CharacterEncodingFilter cef = new CharacterEncodingFilter(); cef.setEncoding(\"UTF-8\"); cef.setForceEncoding(true); return new Filter{new HiddenHttpMethodFilter(), cef}; } } At this time, you might be wondering about the FlowController that you saw in Figure 7-2 and why it wasn’t mentioned anywhere in the configuration section. This class is the bridge between the Spring MVC Controller layer and the Spring Web Flow engine; it allows Spring Web Flow to run embedded as a Controller within a DispatcherServlet and it is used internally. This class uses the handlers and executor defined in the configuration to execute flows; it does this transparently.2 ■ ! before continuing to the next section, look at the 09-pr-webflow-basic-practice module under the person-manger project. Start the application using the appStart gretty task for this module. in the browser, you will notice that a new link has appeared, named New Person. the application is depicted in Figure 7-6. if you click the link, you will notice it fails with a 404 error. this is because no handler has been registered for this resource Url. a few configurations have been set up, but some beans and configurations are missing so that this application can use the Spring Web Flow engine. this is left for you to do. the toDo tasks contain comments that direct you where you could implement the required changes. this module will help you test your understanding of the Spring Web Flow Java Configuration. the configuration files have been created, but it is your responsibility to fill them correctly. the flow itself is empty, and no execution step is defined. after clicking New Person link, you see the form in Figure 7-6. this means your configuration is correct and you can continue with the chapter. if you have difficulties in completing the configuration, you can look at the 09-pr-webflow-basic-solution module, which contains the proposed solution for the given tasks. 2The code for the class is publicly available on GitHub at https://github.com/spring-projects/spring-webflow/ blob/master/spring-webflow/src/main/java/org/springframework/webflow/mvc/servlet/FlowController. java. 271 Chapter 7 ■ Spring Web FloW Figure 7-6. Link to the New Person flow Create a Flow A flow describes a sequence of steps that is executed in the order established by the flow definition. A web flow is made of tree types of elements: states, transitions, and data. In a flow definition, the following types of states can be used:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "View state: In this type of state, the execution of a flow is paused to render a view\nto the user and wait for input data. It is defined using the <view-state ../> XML\nelement.\n• Action state: In this type of state, Java code is executed, and sometimes the next state\nto transition to depends on the outcome of this code. It is defined using the <action-\nstate ../> XML element.\n• Decision state: In this type of state, some branch logic is implemented using the\nXML flow definition language. It is defined using the <decision-state ../> XML\nelement.\n• Subflow state: The execution is transferred to another flow. When the subflow\nexecution is completed, the execution will return to this state. It is defined using the\n<decision-state ../> XML element.\n• End state: The final state of the flow execution. It is not mandatory for this state to\nrender a view, but usually a confirmation view is rendered to the user. It is defined\nusing the <end-state ../> XML element.\nThe states will be referred to using the XML element names in order to faciltate association between the\nstate type and the element used to configure it.\nThe switch from one state to the other is called a transition and it is triggered by events. Some data can\nbe shared among states, depending on the scope of that data. The simple schema of a flow definition and\ncomposing elements is depicted in Figure 7-7. The data is the information that is carried from one state to\nthe other; it has a life span that depends on the scope on which it was declared.\n272\nChapter 7 ■ Spring Web FloW\nFigure 7-7. The general schema of a flow definition and composing elements\nFlow Definition\nA flow is defined in a single XML file, and all the states composing it are defined as child elements of the\nflow element. The content of the flow element is actually a task algorithm. All resources used by a flow\n(views, internationalization files) when being executed must be placed in the same directory as the flow\ndefinition file. Basically, each flow defined in an application has its own directory that contains all flow\ndefinition resources. This was mentioned in the “Spring Web Flow Architecture” section. In this section, all\nthe necessary steps in defining a flow are covered in detail. For example, to develop the /persons/newPerson\nflow, the following has to be created (use Figure 7-8 or reference ).\nFigure 7-8. The components of a flow definition\n273\nChapter 7 ■ Spring Web FloW\n• A directory with the same name as the flow you are trying to create, so as the path\ninside the WEB-INF matches the URL path that you want to map the flow to\n• message.properties internationalization files\n• View files\n• A tiles configuration file, if tiles are used\n• A *-flow.xml spring configuration flow definition file\nWhen developing a flow, it is recommended to think and design the flow logic first—define the states\nand transitions, review the flow with business analysts, use mock views (plain HTML files that replace the\nview in testing scenarios)—to depict the steps and then add the behavior. To define the states of a flow, the\n*-flow.xml file must be populated. Usually, the first step is a view-state that displays a view to the user to\nprovide data to the flow.\n<!-- newPerson-flow.xml -->\n<?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <view-state id=\"enterPersonInfo\"/> </flow> The view-state id resolves to a view template; by default, a *.jsp file is searched for in the current directory. View resolution is pluggable, depending on the view technology used. In the examples given in this book, Apache Tiles are used to define and resolve views; so the view to display when entering the enterPersonInfo state is defined in the tiles.xml under the flow directory. The views used for the workflows extend the same tiles template, webapp/WEB-INF/standard/layout.jsp, defined for views in Chapter 3. <!-- tiles.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE tiles-definitions PUBLIC \"-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN\" \"http://tiles.apache.org/dtds/tiles-config_3_0.dtd\"> <tiles-definitions> <definition name=\"enterPersonInfo\" extends=\"layout\"> <put-attribute name=\"pageTitle\" value=\"persons.new.title\" /> <put-attribute name=\"content\" value=\"/WEB-INF/persons/newPerson/newPersonInfo.jsp\" /> <put-attribute name=\"menuTab\" value=\"newPerson\" /> </definition> </tiles-definitions> 274 Chapter 7 ■ Spring Web FloW In the newPersonInfo.jsp view file template, the user event is linked to a button using the name attribute. <!-- newPersonInfo.jsp --> <h2> <spring:message code=\"persons.new.title\"/> </h2> <div class=\"person\"> <sf:form id=\"newPersonForm\" method=\"POST\" modelAttribute=\"person\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> : </label> </th> <td><sf:input path=\"firstName\"/></td> <td><sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> <!-- other form elements --> ... <tr> <td colspan=\"2\"> <button id=\"newPersonButton\" name=\"_eventId_proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> </td> </tr> </table> </sf:form> </div> Next, a transition must be defined by adding the <transition> element as a child to the state you are transitioning from when a user event is activated. If no navigation is performed (for example, when validation fails), the initial view is refreshed. <!-- newPerson-flow.xml --> <flow ...> <view-state id=\"enterPersonInfo\"> <transition on=\"proceed\" to=\"reviewPerson\" /> </view-state> <view-state id=\"reviewPerson\"> <transition on=\"confirm\" to=\"enterIdentityCard\"/> </view-state> ... </flow> 275 Chapter 7 ■ Spring Web FloW When performing typical web navigations, there is always a Cancel button that allows the user to cancel the whole process. When using Spring Web Flow, this can be done by declaring a <global-transition> element, but using global transition elements sort of breaks the flow. It’s similar to using a goto statement. It also makes the flow definition less readable.3 <flow ...> <global-transition on=\"cancel\" to=\"cancelled\" /> ... </flow> A flow can have one or multiple end-states defined (<end-state> elements are used to define them) and a flow execution can end in any of them, based on the events the user triggers. After a flow execution reaches an end state, the flow terminates and the outcome is returned, unless the end state sends a final response or redirects the user to another resource, typically a confirmation page. <flow ...> <end-state id=\"end\" /> </flow> Redirecting to a confirmation page after a flow has finished the execution is tricky, as the flow data is gone. The solution is to use a redirect to a stateless confirmation page and to use a parameter that has a value that can be used to display confirmation data. The <end-state> element has a view attribute that can be used to specify the URL to redirect to. <flow ...> <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/1\" /> </flow> ■ ! the value is hard-coded id value (“1”) in the previous example only because the concept that could be used to make that link dynamic— flow variable—has not been covered yet. The contextRelative prefix is one of the explicit redirects supported in the context of a flow execution. Without these prefixes, the returned resource location is relative to the current servlet mapping. The flow redirect prefixes help you have more control over where the user is redirected. The following is the complete list of flow redirection prefixes:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "servletRelative: Redirects to a resource relative to the current server\n• contextRelative: Redirects to a resource relative to the current web application\ncontext path\n• serverRelative: Redirects to a resource relative to the server root\n• http:// or https:// Redirects to a fully qualified resource URI\n3The GOTO statement (see https://en.wikipedia.org/wiki/Goto).\n276\nChapter 7 ■ Spring Web FloW\nThese redirect prefixes are supported in a flow definition together with the externalRedirect: directive\nin view-state or end-state elements. The view-state element has a view property that can be used to\nspecify a different view than the one with the same state id, and this view can be outside the newPerson flow\ndirectory:\n<flow ...>\n<view-state id=\"reviewPerson\"\nview=\"externalRedirect:contextRelative:/verifyPerson\">\n<transition on=\"confirm\" to=\"enterIdentityCard\"/>\n</view-state>\n</flow>\nA flow can also redirect to a different flow by using the flowRedirect: directive in its end state; this\nbasically means the current flow ends and a new one is started.\nIn conclusion, when creating a web flow, it is recommended that the following steps be followed in this\norder:\n1. Define view states and end states.\n2. Define transition between states.\n3. Create mock views to test the connection of the states.\n4. Add the intended behavior.\nTo create a web flow like the one shown in Figure 7-1, the following must be done:\n• When defining view states and end states, the focus is on the steps that the user is\nguided through. The why (conditions and events) and how (business logic) is left for\nlater.\n<flow ...>\n<!-- newPerson-flow.xml -->\n<view-state id=\"enterPersonInfo\" />\n<view-state id=\"enterHospitalInfo\" />\n<view-state id=\"enterIdentityCard\" />\n<view-state id=\"reviewPersonData\" />\n<view-state id=\"enterAccountInfo\" />\n<view-state id=\"reviewAccountData\" />\n<end-state id=\"end\" />\n</flow>\n• Then transitions should be defined as follows:\n<!-- newPerson-flow.xml -->\n<flow ...>\n<view-state id=\"enterPersonInfo\" >\n<transition on=\"addHospital\" to=\"enterHospitalInfo\" />\n<transition on=\"proceed\" to=\"enterIdentityCard\" />\n</view-state>\n<view-state id=\"enterHospitalInfo\" >\n<transition on=\"save\" to=\"enterPersonInfo\" />\n</view-state>\n277\nChapter 7 ■ Spring Web FloW\n<view-state id=\"enterIdentityCard\" >\n<transition on=\"review\" to=\"reviewPersonData\" />\n</view-state>\n<view-state id=\"reviewPersonData\" >\n<transition on=\"addAcount\" to=\"enterAccountInfo\" />\n</view-state>\n<view-state id=\"enterAccountInfo\" >\n<transition on=\"review\" to=\"reviewAccountData\" />\n</view-state>\n<view-state id=\"reviewAccountData\" >\n<transition on=\"save\" to=\"end\" />\n<view-state>\n<end-state id=\"end\" />\n</flow>\n• To test the connections between the states, mock views should be created. This is\nan approach that helps users interact with the flow process to test the transitions\nbetween the states. Mock views contain static data; no extra data needs to be\ninserted by the user and no validation is performed. The dynamic behavior is added\nlater, when the back end of the application is developed.\n<!-- newPersonInfo.jsp -->\n<h2> Mock New Person </h2>\n<div class=\"person\">\n<form id=\"newPersonForm\" method=\"POST\" >\n<table>\n<tr>\n<th>\nFirst Name\n</th>\n<td><input path=\"firstName\"/></td>\n</tr>\n<!-- other form elements -->\n...\n<tr>\n<td colspan=\"2\">\n<button id=\"newPersonButton\" name=\" eventId proceed\"\ntype=\"submit\">\nProceed\n</button>\n</td>\n</tr>\n</table>\n</form>\n</div>\n278\nChapter 7 ■ Spring Web FloW\n<!-- enterIdentityCard.jsp -->\n<h2> Mock New Account </h2>\n<div class=\"identityCard\">\n<form id=\"newIdentityCardForm\" method=\"POST\" >\n<table>\n<tr>\n<th>\nAccount Number\n</th>\n<td><input path=\"accountNumber\"/></td>\n</tr>\n<!-- other form elements -->\n...\n<tr>\n<td colspan=\"2\">\n<button id=\"newAccountButton\" name=\"_eventId_review\"\ntype=\"submit\">\nReview\n</button>\n</td>\n</tr>\n</table>\n</form>\n</div>\n<!-- other mock views look similar so their content will not be listed here -->\n■ ! as you probably noticed in the previous example, only view and end states were used. this is because\nthese are the simplest states that can be used to create a flow; also, defining them is very easy and intuitive.\nthe other types of states (action, decision, and subflow) are covered later and added, one by one, to the flow\nyou have become familiar with to allow you to gradually increase your understanding of Spring Web Flow.\nTesting Web Flows\nEvery flow in an application should have a unit test to verify that the flow logic works as expected.\nThe Spring Web Flow provides a test class at org.springframework.webflow.test.execution.\nAbstractXmlFlowExecutionTests that has to be extended to use unit tests to test flows. This class provides\nthe test infrastructure needed to test that a flow definition executes as expected; no Spring or JUnit\nannotations are needed. All that is needed is for the getResource(FlowDefinitionResourceFactory\nresourceFactory) method to be implemented correctly is to provide the test a flow definition file.\n279\nChapter 7 ■ Spring Web FloW\nimport org.springframework.webflow.config.FlowDefinitionResource;\nimport org.springframework.webflow.config.FlowDefinitionResourceFactory;\nimport org.springframework.webflow.test.MockExternalContext;\nimport org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests;\npublic class NewPersonFlowTest extends AbstractXmlFlowExecutionTests {\nprivate static final String ENTER_PERSON_INFO = \"enterPersonInfo\";\nprivate static final String ENTER_IDENTITY_CARD = \"enterIdentityCard\";\nprivate static final String REVIEW_ACCOUNT_DATA = \"reviewAccountData\";\nprivate static final String END = \"end\";\n@Override\nprotected FlowDefinitionResource getResource\n(FlowDefinitionResourceFactory resourceFactory) {\nreturn resourceFactory.createFileResource(\n\"src/main/webapp/WEB-INF/persons/newPerson/newPerson-flow.xml\");\n}\npublic void testStart() throws Exception {\nstartFlow(new MockExternalContext());\nassertCurrentStateEquals(ENTER_PERSON_INFO);\n}\npublic void testEnterPersonInfoProceed() throws Exception {\nsetCurrentState(ENTER_PERSON_INFO);\nMockExternalContext externalContext = new MockExternalContext();\nexternalContext.setEventId(\"proceed\");\nresumeFlow(externalContext);\nassertCurrentStateEquals(ENTER_IDENTITY_CARD);\n}\n// other similar transition tests\n..\npublic void testReviewPersonConfirm() throws Exception {\nsetCurrentState(REVIEW_ACCOUNT_DATA);\nMockExternalContext externalContext = new MockExternalContext();\nexternalContext.setEventId(\"save\");\nresumeFlow(externalContext);\nassertFlowExecutionEnded();\nassertFlowExecutionOutcomeEquals(END);\nassertTrue(externalContext.getExternalRedirectRequested());\nassertEquals(\"contextRelative:/persons/1\",\nexternalContext.getExternalRedirectUrl());\n}\n}\nThe testStart method starts the flow by calling startFlow and tests that the flow has entered the start\nstate by calling assertCurrentStateEquals.\n280\nChapter 7 ■ Spring Web FloW\nThe testEnterPersonInfoProceed tests that starting from an exact state when an event is triggered,\nthe transition is done to the expected state. Triggering the event is done by using a mock context and calling\nsetEventId on it.\n■ ! before continuing to the next section, take a look at the 10-pr-webflow-fundamentals-practice\nmodule under the person-manger project. all the files necessary for creating a very simple flow have been\nprovided for you. Figure 7-9 depicts the simplified version of the newPerson flow that is required to complete\nthe practice example. it uses mock views and only view states; no business logic is required to complete this\npractice exercise. the purpose of this module is to help you test your understanding of defining states and\ntransitions, and using mock flows and testing the simple flow you have created.\nFigure 7-9. Link to the simplified New Person flow\nthis flow guides the user through the process of creating a person using the minimum amount of information.\nthe first step of this flow should display a form to the user. after submitting the form, the user should be taken\nto a screen where he can review the information before being confirmed. after confirming, the user should be\ntaken to the screen displaying the details of the completed transaction.\nthe practice module has ten toDo tasks to be resolved, numbered from 40 to 49. each task has a short\ndescription instructing you on what you have to do. the web application can be started by executing the\nappStart gradle task. the newPerson flow definition has been completed and the execution works completely\nif the user can be guided through all the expected steps. the test has been implemented correctly if all the\nmethods pass.\nWhen executing the flow, and the current state is the reviewPersonData. try clicking the back button of the\nbrowser to see what happens. You should be able to go back and resubmit. no browser warnings should occur,\nand the request Url should depict that you are back to the previous step of the same flow execution.\nif the current Url were http://localhost:8080/persons/newPerson?",
    "answer": "execution=e1s2, clicking the back button should redirect the user to http://localhost:8080/persons/newPerson?execution=e1s1. try the same after the flow has finished its execution and note the parameters in the request Url. the flow execution should be restarted and the execution Url parameter should have the expected value. ■ ? Can you remember how the execution parameter value should change when a new flow execution is started? 281 Chapter 7 ■ Spring Web FloW Actions and Scopes During the execution of a web flow, it is expected for business services to be called for the flow to accomplish its task. Using view states only rendering a view and establishing the next view state in the navigation is possible. Thus, more elements are needed to define which business services are called and what to do with the results in the context of a flow. These elements are called actions; they can be called within a flow on several execution points. Actions are defined in Spring Web Flow using the Spring Expression Language. Most of the time, their result has to be stored in a flow variable that has a life span defined by the scope that they are declared for. Explaining the type of actions that can be defined for a web flow, and when and how they should be used, cannot be done properly without first mentioning web flow scopes. In Figure 7-7, in the bottom-left corner of each rectangle grouping state, you see a scope specific to that group of states, written in italics. Within a flow, you can define instance variables. For example, when creating a new person using a flow, the Person instance can be stored in a flow variable and be made available during the flow execution; and so at the end of the flow execution, redirection can be done to a page to render the instance just created: <flow ...> <var name=\"person\" class=\"com.pr.ents.Person\"/> ... <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/#{person.id}\" /> </flow> Flow variables and other data objects exist in a scope, and when using web flows, multiple types of scopes are available to implement the desired functionality. Each flow provides a context where objects are stored. The data scopes are provided by this context and its state is managed by the Spring Web Flow. During flow execution, objects are added to different scopes, depending on the flow definition. They are cleaned when they go out of scope. The previous example depicted the explicit creation of a flow variable; the <var /> element was used for that. But variables can be assigned dynamically by using actions. The advantage of using actions to assign variables is that the variables can be assigned to any scope possible. Explicit variables, declared with <var/>, can be assigned only a flow scope and a view scope. There are five web flow scopes that are supported by the context of a flow:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Flow scope: This is the scope that lasts until the flow ends.\n• View scope: This is the scope associated with each view-state.\n• Request scope: This is the scope matching a single request\n• Flash scope: This the scope allocated when a flow starts; it is cleaned automatically\nafter each view is rendered and destroyed when the flow ends.\n• Conversation scope: This is a global execution scope; all subflows share this scope.\nIt gets allocated when a top-level flow starts and it is destroyed when the top-level\nflow ends.\n■ ! the conversation-scoped objects are stored in the http session and should generally be serializable to\naccount for typical session replication.\n282\nChapter 7 ■ Spring Web FloW\nFlow Variables\nThe scope of a variable can be determined contextually. For example, when the explicit definition of a\nvariable is directly under the <flow/> element, the scope for that variable is the flow scope. When the\nexplicit definition of a variable is under the <view-state/> element, the scope of that variable is view scope.\nBut when using EL expressions and Java code, the scope needs to be specified explicitly.\nWhen using <var/> to define variables, you have to keep in mind that if the objects are complex and\nrequire other properties to be injected, they must either have a constructor, setters annotated with\n@Autowired, or both depending on the chosen configuration.\n<!-- newPerson-flow.xml -->\n<flow ...>\n<var name=\"identityCardProcessor\" class=\"com.pr.webflow.IdentityCardProcessor\"/>\n...\n</flow>\n// com.pr.webflow.IdentityCardProcessor.java\npublic class IdentityCardProcessor implements Serializable {\nprivate IdentityCardManager identityCardManager;\n@Autowired\npublic IdentityCardProcessor(\nIdentityCardManager identityCardManager){...}\n}\n// or\npublic class IdentityCardProcessor implements Serializable {\nprivate IdentityCardManager identityCardManager\n@Autowired\npublic void setIdentityCardManager(\nIdentityCardManager identityCardManager){...}\n}\nExplicit variables are most often used as data models for views. They are used to pass as arguments to\nbusiness services invoked by the flow; such an implementation is depicted in Figure 7-10.\nFigure 7-10. Explicit flow variable usages example\n283\nChapter 7 ■ Spring Web FloW\n■ ?",
    "answer": "From what has been covered so far, can you tell to which scope the person variable in the previous code sample belongs? Explicit variables can be defined as view-scoped objects too. In this case, the variable is created when the view-state is entered and is destroyed when the transition to the next view-state occurs. They can be used as data models for a single view. They are often updated using AJAX requests before being used for the expression conditioning the transition to the next state; such an implementation is depicted in Figure 7-11. Figure 7-11. Explicit flow variable in view scope usages example In the previous examples, you can see that performing the transition depends on the result of the evaluation of the expression in the <evaluate /> element. The expression in that element is a standard EL expression that can be evaluated directly by the EL; it does not need to be enclosed in delimiters such as #{ }. The delimiters are not needed when the expression is a string that represents a method call or property access, and using them will throw an IllegalArgumentException. The delimiters are only needed when the argument string is a template EL expression that implies mixing literal text with one or more standard expressions, as in the redirect link for the end state in previous examples. <flow ...> <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/#{person.id}\" /> </flow> Conversation Variables The conversation scope is the widest web flow scope. Variables defined within this scope are available to subflows too. The conversation variables are similar to global variables and have the same disadvantages. Conversation variables introduce a dependency between top-level flows and their subflows; that’s why the recommendation is to not use them if a different option exists. When working with subflows, input/output parameters can be used to avoid conversation variables. A variable can be assigned to the conversation scope using the <evaluate /> element. 284 Chapter 7 ■ Spring Web FloW In the following example, a Person instance retrieved using a PersonManager service is being assigned to the conversation scope: <flow ...> <!-- The result of this expression is stored into the person variable --> <evaluate result=\"conversationScope.person\" expression=\"personManager.findById(personId)\"/> </flow> Request and Flash Scopes Attributes placed in flash scope exist through the life of the current request and until the next view rendering. After the view renders, the flash scope is cleared. Flash scope is typically used to store messages that should be preserved until after the next view renders. This scope is useful to pass data from one request to another as one flow state involves two requests, as depicted in Figure 7-4.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The first request lasts between the transition from the current state until entering the\nnext state.\n• The second lasts from the moment before the view is rendered to the end of\nrendering the same state.\nYou can consider the flash scope as an extension of the request scope in the Web Flow context, because\nthe request scope is not quite useful when using web flow, as is explained later in this section.\nAttributes placed in request scope exist for the life of the current request into the flow execution. When\nthe request ends, any attributes in request scope goes out of scope. Variables should be assigned the request\nscope when their values are refetched every time a state is redisplayed. If the data can be cached, the view\nscope would be more appropriate for the variable.\n■ ! the request scope can be useful when creating a sports betting site. the application should have a web\nflow defined, through which the user can place a bet. a request variable should be used to extract the most\nrecent results of games being played, so the user can be informed in real time of his winning chances.\nAlso, data with request scope can be used in cases where it is needed only to initialize the next view; but\nit should not be displayed by it.\n■ ! Consider the example of a betting site: only the list of games currently being played should be displayed,\nso a specific time interval value can be stored in a variable and used as criteria for selection.\nTo implement the previously mentioned cases, the flow scope can be used, and the games the user\ncan bet on can be retrieved using AJAX calls. Request scope is pretty useless, considering that usually a\ndeveloper is interested in sharing the data between the two requests implied by a web flow state.\n285\nChapter 7 ■ Spring Web FloW\nFigure 7-12 is a simple diagram with the duration of the flash scope and the request scope depicted to\nmake their differences in the context of a flow execution more obvious.\nFigure 7-12. Comparison between request and flash scope\nIn Figure 7-12, you can clearly see the two requests implied by a flow state. One of them is the user\nrequest to start the flow with URL /person/newPerson. Accessing this URL makes the web flow engine send\na request to /persons/newPerson?",
    "answer": "execution=e1s1. The request to this web flow resource is the second request. The two arrows under the REQUEST bubble show exactly how long the attributes in the request scope is available. And under the FLASH bubble, you can see the longer arrow, which depicts how long the attributes in the flash scope are available. The execution points— :on-entry, on-render, and so forth—are covered in the next section. Actions Now that web flow scopes have been covered, it is time to introduce actions. Actions execute behavior at specific points within the flow. There are several points where you can execute actions:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "on flow start: The <evaluate /> element is declared as a child of the <on-start />\nelement that marks the start of a flow execution. This action is executed only once,\nwhen the flow execution starts.\n<flow ...>\n<on-start>\n<evaluate expression=\"...\"/>\n</on-start>\n</flow>\n286\nChapter 7 ■ Spring Web FloW\n• on state entry: The <evaluate /> element is declared as a child of the <on-entry />\nelement that marks the entry in a state. (A view state in the following example). This\naction is executed only once, when entering the state.\n<flow ...>\n<view-state ...>\n<on-entry>\n<evaluate expression=\"...\"/>\n</on-entry>\n</view-state>\n</flow>\n• on view render: The <evaluate /> element is declared as a child of the <on-render\n/> element that marks the moment immediately before a view is rendered. The\naction is executed on every browser refresh.\n<flow ...>\n<view-state ...>\n<on-render>\n<evaluate expression=\"...\"/>\n</on-render>\n</view-state>\n</flow>\n• on transition execution: The <evaluate /> element is declared as a child of the\n<transition /> element. Actions imply evaluating expressions and the results are\nassigned to variables that have a specific scope assigned. The <evaluate /> action\nelement used in the following example can be used to evaluate an expression and\nassign the result a specific scope. It can prevent a transition if an exception is thrown\nor false is returned as a result when the expression is evaluated. How exceptions are\nhandled in the web flow context is covered later in the chapter. Only one <evaluate />\nexpression is allowed.\n<flow ...>\n<view-state ...>\n<transition on=\"confirm\" to=\"nextStep\">\n<evaluate expression=\"...\"/>\n</transition>\n</view-state>\n</flow>\n• on state exit: The <evaluate /> element is declared as a child of the <on-exit/>\nelement that marks the exit of a state. (A view state in the following example).\nThis action is executed only once, when exiting the state.\n<flow ...>\n<view-state ...>\n<on-exit>\n<evaluate expression=\"...\"/>\n</on-exit>\n</view-state>\n</flow>\n287\nChapter 7 ■ Spring Web FloW\n• on flow end: The <evaluate /> element is declared as a child of the <on-end />\nelement that marks the end of a flow execution. This action is executed only once,\nwhen the flow execution ends.\n<flow ...>\n...\n<on-end>\n<evaluate expression=\"...\"/>\n</on-end>\n</flow>\nThe examples presented so far were simplified to set the focus on the syntax when defining your\nactions. The following example is a concrete one that you will use in the practice exercises:\n<flow ...>\n<!-- newPerson-flow.xml -->\n<view-state id=\"enterPersonInfo\">\n<on-render>\n<evaluate expression=\"hospitalManager.findAll()\"\nresult=\"flowScope.hospitalList\" />\n</on-render>\n<transition on=\"proceed\" to=\"reviewPerson\" />\n</view-state>\n</flow>\nThe <evaluate /> element can also be used to resolve properties on beans and even perform\nconversions. The actions are usually expressed in Spring EL,4 but Unified EL Standard and OGNL are\nsupported too. Using this type of syntax makes the actions more concise for executing behavior and easier to\nread from a development point of view.\nA Spring EL expression has the following template:\n<variable_name>.property_or_method\nThe variable_name is resolved against the current flow context. Variables referring to data scopes\n(flowScope, viewScope, requestScope, etc.) should only be used when assigning a new variable to one of the\nscopes. To resolve a flow variable, reserved variables are searched first, then the variable is searched within\neach flow scope, starting with request and expanding the scope gradually: flash, view, flow, conversation.\nIf the variable is not found, the flow application context is searched for a bean matching the variable name.\nLet’s look at a few examples to make usage of Spring EL expressions with web flows easier to understand:\n• flowScope.person: The person variable is resolved in flow scope\n• person: The person variable is searched in all scopes\n• hospitalManager.findAll(): The findAll method is called on the\nhospitalManager variable (in this book’s examples, hospitalManager is actually a\nbean).\n• hospitalManager.findByCode(hospitalCode): Calling a bean method and using\nthe hospitalCode variable as an argument.\n4See http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.\nhtml#expressions-language-ref.\n288\nChapter 7 ■ Spring Web FloW\nWhen using Spring EL to write expressions, a few reserved variables can be used without any prior\nmanual initialization (Spring takes care of initializing them).\n• scope-specific variables: requestScope, flashScope, viewScope, flowScope,\nconversationScope\n• environment-specific variables: flowExecutionUrl, flowRequestContext,\nrequestParameters, externalContext, messageContext, resourceBundle,\ncurrentEvent, currentUser\n• externalContext.sessionMap is used to access HTTP session contents.\n(No sessionScope variable exists in the context of a flow definition.)\nSome of these variables can be used in view template files also; in JSP, all scope variables are accessible,\nflowExecutionUrl is the URL of the current page, flowRequestContext is the RequestContext. Additional\nvariables are available: pageScope, requestParameters, sessionScope, and so forth.\nSo far, only the <evaluate /> element has been used, but there are alternatives more suitable in\nparticular cases. The <set /> action element is used to set the value of a variable, but it does not prevent a\ntransition and can be used multiple times within a transition element. For example, if you just want to view\nthe details on a person after it was selected from a list; there is nothing to evaluate, you just want view some\ndata. The <set /> element is more suitable for this case:\n<flow ...>\n<!-- reviewPerson-flow.xml -->\n<view-state id=\"reviewPersonInfo\">\n<on-render>\n<evaluate expression=\"personManager.getByDateOfBirth(dob)\"\nresult=\"viewScope.persons\" result-type=\"dataModel\" />\n</on-render>\n<transition on=\"select\" to=\"viewPerson\">\n<set name=\"flowScope.person\" value=\"persons.selectedRow\" />\n</transition>\n</view-state>\n</flow>\nWhen using <set />, a scope must be specified when creating a new variable, as there is no default.\nIn the following example, the firstName variable is assigned to the flowScope scope.\n<set name=\"flowScope.firstName\"\nvalue=\"requestParameters.firstName\"/>\nWhen updating an existing variable, or one of its properties, the scope is no longer required and the\nalgorithm presented previously is used to perform scope resolution.\n<set name=\"person.firstName\"\nvalue=\"requestParameters.firstName\"/>\n289\nChapter 7 ■ Spring Web FloW\nRequest Parameters\nIn the previous code sample, the requestParameters system variable was used. This variable contains all\nthe URL parameters for the current request. These parameters are not in the requestScope, and if they are\nneeded further in the execution flow, they need to be assigned to a proper scope; otherwise, they will be lost\nwhen the current request ends.\n<view-state id=\"reviewPersonInfo\">\n<transition on=\"cancel\" to=\"cancelled\">\n<evaluate expression=\n\"personManager.delete(requestParameters.personId)\">\n</transition>\n</view-state>\n■ ?",
    "answer": "to test your understanding, look at the following code snippet: <view-state id=\"practiceInfo\"> <on-entry> <set name=\"flashScope.var1\" value=\"var1\" > <set name=\"requestScope.var2\" value=\"var2\" > <on-entry> <on-render> <set name=\"requestScope.var3\" value=\"var3\" > <set name=\"flashScope.var4\" value=\"var4\" > <set name=\"requestScope.var5\" value=\"var5\" > </on-render> </view-state> try to determine which of the following affirmations is true and which is not, and why.5 1. var2 is available after the view is rendered. 2. var2 can be used to initialize the view, but is lost when the view is rendered. 3. var1, var3, var4, and var5 are available after the view is rendered. 4. var1 is lost if the view is refreshed. 51. False. This variable is defined in the first requestScope and a state has two requests. Rendering the view is done in the second request. 2. True. As explained earlier. 3. True. var1 and var4 are defined in flashScope; var3 and var5 are defined in the scope of the rendering requestScope. 4. True. var1 is lost because it is defined when entering the state, and if the page is reloaded, entering the page is done only once. So when the page is reloaded, the flash scope is cleaned and var1 is lost. 290 Chapter 7 ■ Spring Web FloW Actions are really useful components of a flow, but a flow definition must stay clear and readable. The recommended practice is to keep your flow definition as simple as possible, use actions only to prevent transactions or to decide to which state to transition next. The heavy-lifting actions should be performed in Java. As you probably figured out by now, a web flow definition is a bridge between the service and the web layer that can be used to control the navigation. Model Objects In Chapter 3, you learned about controllers, models, and views. A model object handles data used in a view. The views used in web flows view states also need model objects to render data. In web flow definitions, model objects can be assigned different scopes and are associated to a view state using the model attribute. <flow ...> <view-state id=\"enterPersonInfo\" model=\"person\"> ... </view-state> </flow> The model object is accessible from the view template files and can be set as a model attribute for forms. The Spring forms used in web flow views are identical to the ones used when working with Spring MVC; the only difference is represented by the Submit button, which is used to trigger a user event when using web flows. This is what a Spring MVC view used to save a Person instance looks like: <!-- addPerson.jsp --> <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> <spring:url value=\"/persons/{id}\" var=\"editUrl\"> <spring:param name=\"id\" value=\"${person.id}\"/> </spring:url> <sf:form modelAttribute=\"person\" action=\"${editUrl}\" method=\"POST\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> : </label> </th> <td><sf:input path=\"firstName\"/></td> <td><sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> <!-- other form fields--> ... <tr> <td> <button id=\"saveButton\" type=\"submit\"> <spring:message code=\"command.save\"/> </button> </td> <td> 291 Chapter 7 ■ Spring Web FloW <a href=\"${editUrl}\"> <spring:message code=\"command.cancel\"/> </a> </td> </tr> </table> </sf:form> This is what a Spring Web Flow view used to save a Person instance looks like: <!-- newPersonInfo.jsp --> <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> <sf:form modelAttribute=\"person\" method=\"POST\" id=\"newPersonForm\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> : </label> </th> <td><sf:input path=\"firstName\"/></td> <td><sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> <!-- other form fields--> ... <tr> <td> <button id=\"newPersonButton\" name=\"_eventId_proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> </td> <td> <button id=\"cancelOpButton\" name=\"_eventId_cancel\" type=\"submit\"> <spring:message code=\"command.cancel\" /> </button> </td> </tr> </table> </sf:form> The cancel user event is handled by a global transition, a concept that is covered later. The model is populated with the request parameter process, also known as data binding. Validation and conversion are supported for all properties, but can be suppressed if needed (usually during development) using the bind and validation attributes on the <transition /> element, by setting them to \"false\". <view-state id=\"enterPersonInfo\" 292 Chapter 7 ■ Spring Web FloW model=\"person\"> <transition on=\"submit\" to=\"reviewPersonInfo\" /> <transition on=\"cancel\" to=\"end\" bind=\"false\" validate=\"false\"/> </view-state> When using Spring MVC, the @InitBinder annotation was used to customize the properties of a model object that should be binded to a view. Spring Web Flow has an equivalent for this too, because there is no point in binding properties that the user does not modify or is not meant to use for security reasons. For example, after personal data is introduced and the validation has passed, the enterIdentityCardInfo data used to generate the unique personal numerical code should no longer be editable by the user; otherwise, the personal numerical code is no longer valid. The <binder /> element can be used to white-list elements eligible for binding, like in the following example: <!-- enterIdentityCardInfo-floq.xml --> <view-state id=\"enterIdentityCardInfo\" model=\"identityCard\"> <binder> <binding property=\"series\" required=\"true\"/> <binding property=\"number\" required=\"true\"/> <!--current date will be used--> <binding property=\"emittedAt\" required=\"false\"/> <!-- current date 10 years will be used--> <binding property=\"expiresAt\" required=\"false\"/> <binding property=\"address\" required=\"true\"/> </binder> </view-state> When the form is really big, the model object has a lot of fields and the web flow definition might become too verbose. A more appropriate solution in cases like this is to create a validator bean or method for the model objects, as covered in Chapter 3. Validation, Formatting, and Conversion Formatters and converters used with web flows are the same as in Spring MVC: default ones are present out of the box, and custom formatters and converters have to be declared and associated with the web flow engine using the flow builder services, as shown in the “Configuration and Infrastructure Beans” section. The same goes for validators: they have to be set on the flow builder services to be used. ■ ! a Spring convertor is a general-purpose class used for conversion between two types that implement org.springframework.core.convert.converter.GenericConverter or one of its subinterfaces, or implement org.springframework.core.convert.converter.Converter<S,T> or subinterfaces. 293 Chapter 7 ■ Spring Web FloW a Spring formatter is a class specializing in transforming objects into strings or vice-versa, because when Spring MVC or Spring Web Flow is used, this is the focus of model objects. the classes must implement the org.springframework.format.Formatter<T> interface or one of its subinterfaces. the Formatter<T> interface is favored by developers because it is more suitable for web applications. Although the registered converters are applied to any model objects, if needed, a different converter can be set for a property using the converter attribute of the <binding /> element. A converter cannot be specified in the web flow definition on a property that is not required; otherwise, when no value is provided, validation errors are generated and rendered in the view. <!-- enterIdentityCardInfo-floq.xml --> <view-state id=\"enterIdentityCardInfo\" model=\"identityCard\"> <binder> <binding property=\"series\" required=\"true\"/> <binding property=\"number\" required=\"true\"/> <binding property=\"emittedAt\" required=\"true\" converter=\"simpleDate\"/> <binding property=\"expiresAt\" required=\"true\" converter=\"simpleDate\"/> <binding property=\"address\" required=\"true\"/> </binder> </view-state> JSR 349 bean validation is supported and annotations on the form object properties are used to set up the validation; but to enable it, a bean of type LocalValidatorFactoryBean has to be defined and set on the on the flowBuilderServices bean. A validator set on the FlowBuilderServices bean is applied to all model objects in the application. For customizations, custom validators can also be used, just like in Spring MVC. ■ ! remember the annotation validations? @Entity @SequenceGenerator(name = \"seqGen\", allocationSize = 1) public class Person implements Serializable { @Column(nullable = false) @Size(min=2, max=50) @NotEmpty public String firstName; @Enumerated(EnumType.STRING) @NotNull private Gender gender; ... } 294 Chapter 7 ■ Spring Web FloW When it comes to validation, there is one major difference between Spring MVC and Spring Web Flow— the template of the internationalized validation message keys. In Spring Web Flow, the message key must match the following template to be picked up automatically. In Spring MVC, the message name is placed at the beginning; in Spring Web Flow is placed at the end. #MVC messageName.modelObject.property #Web Flow modelObject.property.messageName But this difference can be eliminated by using a bean of type DefaultMessageCodesResolver that is set on the MvcViewFactoryCreator. Here is the XML configuration needed to make this happen: <!-- webflow-config.xml --> <!-- Configures Web Flow to render Tiles views resolved by Spring MVC --> <bean id=\"mvcViewFactoryCreator\" class=\"org.springframework.webflow.mvc.builder.MvcViewFactoryCreator\"> <property name=\"viewResolvers\" ref=\"tilesViewResolver\" /> <property name=\"useSpringBeanBinding\" value=\"true\"/> <property name=\"messageCodesResolver\" ref=\"mcr\" /> </bean> <bean id=\"mcr\" class=\"org.springframework.validation.DefaultMessageCodesResolver\"/> And here is the Java Configuration: \\\\ WebFlowConfig.java @Bean public MvcViewFactoryCreator mvcViewFactoryCreator() { MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator(); factoryCreator.setViewResolvers(Arrays.<ViewResolver>asList( this.mvcConfig.tilesViewResolver())); factoryCreator.setUseSpringBeanBinding(true); factoryCreator .setMessageCodesResolver(messageCodesResolver()); return factoryCreator; } @Bean public DefaultMessageCodesResolver messageCodesResolver(){ return new DefaultMessageCodesResolver(); } 295 Chapter 7 ■ Spring Web FloW Another way to validate a model object is to use programmatic validation. You can define a validation method in the model object class specific to the view state. The method must have a specific name to be discovered and the convention naming is \"validate\" + {view-state-id(first letter is up-cased)} So if instead of using a Person instance as model object, a specific form object implementation would be used. That implementation can also be defined with a view-state specific validation method: <!-- Flow definition file--> <view-state id=\"enterPersonInfo\" model=\"personModelObject\" > ... </view-state> <!-- PersonModelObject.java --> public class PersonModelObject implements Serializable { public void validateEnterPersonInfo( ValidationContext validationContext) { ... } } Keep in mind that model objects are being serialized and deserialized by Spring to populate the form with values, or retrieve field values from the form, so the model object class must implement the java. io.Serializable interface. If the model object cannot be modified, a validator bean can be used. The bean name must match a specific convention: {model object name} + \"Validator\" To be automatically detected, the validation method must match the preceding conventions, but the signature has an extra parameter—the model object that is automatically passed as an argument. <!-- Flow definition file--> <view-state id=\"enterPersonInfo\" model=\"person\" > ...</view-state> <!-- PersonValidator.java --> @Component public class PersonValidator { public void validateEnterPersonInfo( Person person, ValidationContext validationContext) { ... } } 296 Chapter 7 ■ Spring Web FloW ■ ! When writing a validator class and using annotations to define the bean, make sure to specify a name corresponding to the convention mentioned earlier, or make sure that you name the class appropriately. Another way of defining validation with web flows is using the <evaluate /> element to call validation methods and prevent transitions if the validation fails. But doing this is not recommended because it will overcrowd the flow definition. Still, in some cases, this kind of approach could be necessary, so that’s why it is covered. <!-- Flow definition file--> <view-state id=\"enterPersonInfo\" model=\"person\" > <transition on=\"submit\" to=\"enterIdentityCardInfo\"> <evaluate expression=\"personValidator.check(person, messageContext)\"/> </transition> </view-state> <!-- PersonValidator.java --> @Component(\"personValidator\") public class PersonValidator{ public boolean check( Person person, MessageContext messageContext) { ... } } The method returns a Boolean value that can be used to prevent a transition when the result of its evaluation is false. Validation methods have flexible signatures and can use different types of objects to register errors. They can use a ValidationContext object to register errors: import org.springframework.binding.message.MessageBuilder; import org.springframework.binding.validation.ValidationContext; ... public void validateEnterPersonInfo(ValidationContext validationContext) { validationContext.getMessageContext(). addMessage(new MessageBuilder().error() .source(\"person\") .code(\"Size.person.firstName\") .defaultText (\"Length must be between 2 and 50\").build()); } 297 Chapter 7 ■ Spring Web FloW Or a MessageContext object: import org.springframework.binding.message.MessageBuilder; import org.springframework.binding.message.MessageContext; ... public boolean check(Person person, MessageContext messageContext) { messageContext.addMessage (new MessageBuilder().error().source(\"firstName\") .code(\"Size.person.firstName\").build()); return true; } Or an Errors object: import org.springframework.validation.Errors; ... public boolean check(Person person, Errors errors) { errors.rejectValue(\"person\", \"Size.person.firstName\", \"Length must be between 2 and 50\"); return true; } JSR-349 bean validation supports partial validation through validation groups.6 A group defines a subset of constraints. Instead of validating all constraints for a given object graph, only a subset is validated. This subset is defined by the group or groups targeted. @NotEmpty @Size(min=2, max=50, groups=NameRule.class) public String firstName; @NotEmpty @Size(min=2, max=50, groups=NameRule.class) public String lastName; Groups are represented by interfaces that are defined inside the model class or its parent. package com.pr.validator; public class PersonModelObject implements Serializable { ... public interface NameRule { } } 6If you want more information about validation groups, the official documentation is a great start; it can be found at https://docs.oracle.com/javaee/7/tutorial/index.html. 298 Chapter 7 ■ Spring Web FloW In a flow definition, the equivalent of validation groups can be implemented using the validation-hints attribute on the <view-state />: <!-- Flow definition file--> <view-state id=\"enterPersonInfo\" model=\"person\" validation-hints=\"group1,group2\"> <transition on=\"submit\" to=\"enterIdentityCardInfo\"> <evaluate expression=\"personValidator.check(person, messageContext)\"/> </transition> </view-state> The validation groups are used to group together fields of the model object that are subjected to validation together. @NotEmpty @Size(min=2, max=50, groups={\"group1,group2\"}) public String firstName; @NotEmpty @Size(min=2, max=50, groups={\"group1\"}) public String lastName; The validation-hints attribute is an expression that resolves to a comma-delimited string consisting of hints that are resolved by a ValidationHintResolver bean. By default, Spring uses a bean of type org. springframework.webflow.validation. BeanValidationHintResolver matches the string values to class-based bean validation groups. In the preceding case, this bean looked for interfaces named Group1 and Group2 in the model or its parent. Fully qualified class names can also be provided. A custom ValidationHintResolver can also be provided if necessary, but has to be set on the FlowBuilderServices in the web flow configuration. In the following, you can see an XML and Java Configuration sample: <!-- webflow-config.xml --> <webflow:flow-builder-services id=\"flowBuilderServices\" view-factory-creator=\"mvcViewFactoryCreator\" conversion-service=\"conversionService\" validation-hint-resolver=\"customValidationHintResolver\" /> <!-- WebFlowConfig.class--> @Bean public FlowBuilderServices flowBuilderServices() { return getFlowBuilderServicesBuilder() .setViewFactoryCreator(mvcViewFactoryCreator()) .setValidator(this.mvcConfig.validator()) .setConversionService(conversionService()) .setValidationHintResolver(customValidationHintResolver()) .setDevelopmentMode(true) .build(); } 299 Chapter 7 ■ Spring Web FloW @Bean public CustomValidationHintResolver customValidationHintResolver(){ return new CustomValidationHintResolver(); } //CustomValidationHintResolver.java import org.springframework.webflow.validation.BeanValidationHintResolver; ... @Component(\"customValidationHintResolver\") public class CustomValidationHintResolver extends BeanValidationHintResolver { ... } ■ ! if you want to test your understanding so far, check if you understand how view-states, actions, and transactions interact in the context of a flow. You can take a break from reading and try to solve the 11-pr-webflow-actions-practice practice project. this project contains all the classes necessary to implement a flow that creates a Person instance in two steps. the view templates are provided, and in the newPerson-flow.xml, the view-states and transaction elements are already in place. the only thing you have to do is to complete the web flow definition by adding actions and model objects. (toDo 40) Figure 7-13 shows the elements of the flow definition and some hints about which actions should be used and where. Figure 7-13. Web Flow action practice project flow definition 300 Chapter 7 ■ Spring Web FloW A PersonModelObject class is provided to use an instance of this type in the flow definition. A class called PersonBuilder is defined with helper methods that can be used to create a person model object and save the person that the flow will create. The following are the steps executed by the web flow: 1. The enterPersonInfo view-state is entered and a form with the minimal data required to create a person is displayed. Almost all properties of the person model object for this form must be binded and are required, except for the middleName. When this view is rendered, the list of hospitals must be populated. In this example, the hospitalList is only needed to render the view. Keep this in mind when deciding which scope this variable should be assigned to. When leaving this state, the personal object model must be created from all the data introduced by the user. The personal numerical code is generated by the application. Just add an action to call the buildPersonObject of the personBuilder bean and save the result to a variable. This variable must be accessible to all view-states from this step on, so take this into account when choosing the scope for it. Figure 7-14 depicts the view specific to this view-state. Figure 7-14. The enterPersonInfo view-state 301 Chapter 7 ■ Spring Web FloW 2. Clicking the Review button must direct the user to the reviewPerson view-state, where the information introduced by the user and the application-generated personal numeric code is displayed. Only the transition element is missing from the configuration state. The next state to go to is enterIdentityCardInfo. Figure 7-15 depicts the view specific to this view-state. Figure 7-15. The reviewPerson view-state 302 Chapter 7 ■ Spring Web FloW 3. The enterIdentityCardInfo is entered, and in this state, the personal details introduced and generated so far are displayed. The view specific to this view- state also contains a form that is used to insert data for the IdentityCard instance. A Person instance cannot be created without an IdentityCard. The personal numerical code cannot be edited; to change it, you have to go back to the first step of the flow and change the data there. All the properties of the identityCard object model for this form must be binded and all are mandatory. Figure 7-16 depicts the view specific to this view-state. Figure 7-16. The enterIdentityCardInfo view-state 303 Chapter 7 ■ Spring Web FloW To save a person’s data, just click the Save button. In the web flow definition, the savePersonEntity in the personBuilder bean call must be added when transitioning away to the end state. The IdentityCardValidator class defines a validator method that is applied automatically before saving an IdentityCard instance. The validation method is discovered and applied specifically when the flow is transitioning away from the enterIdentityCardInfo view-state, and checks if another person with the same personal numerical code already exists in the system. To try it out, just add a person born on January 8, 1942 at Oxford Hospital. You should get an error message like the one shown in Figure 7-17. Figure 7-17. The enterIdentityCardInfo view-state when invalid data is inserted ■ Note as an exercise, you could try to make the validation more precise by testing for number and series duplication in an identity card. Action States If you remember the first logical schema (see Figure 7-1) of the web flow execution that it is meant to be implemented after studying this chapter, you should remember that it had some decisional elements in the if-then-else style that made the navigation flow dynamic; because when transitioning based on the value of a variable, you can end up in different states. In the examples presented so far, this was not possible, because view-states and actions are not enough to do this. What can be done with view-states and actions, however, is preventing transitioning when an action fails, but not changing the state to transition to. To make this happen dynamically, two new state types are needed: action-states and decision-states. An action state allows transition to a state that executes one or more actions using <evaluate /> and <set /> elements. The result of this action is raised as an event and a transition to another state is triggered. Different events can be raised to trigger different transitions dynamically, so an action state should be used when there is need of an action to be executed and the state to transition to is decided by the result of that action. Multiple <evaluate /> are allowed inside an action-state, but the last one is used to control the transition. The <set /> element can be used to define variables needed to execute that action and it is recommended for usage when transition control is not required. 304 Chapter 7 ■ Spring Web FloW The result of an action state can be any of the types in the following list, but it will always be converted to a string following the rules mentioned for each type, because to trigger a transition, the returned value must be mapped to an event:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Boolean: Always evaluates to \"yes\" or \"no\".\n• String: The name of the event to trigger.\n• Enumerated types: The enumerated values is converted to String using the\ntoString() method. The toString method must be defined in such a way that it\nreturns acceptable values to transition on. Look at the following example; depending\non the result of the evaluation of the getDecision(...) method, the transition is\ndone to a different state.\n//ActionEnum.java\npublic enum ActionEnum {\nEDIT_ACCOUNT(\"accountEditState\"),\nDELETE_ACCOUNT(\"accountDeleteState\"),\nCREATE_ACCOUNT(\"accountCreateState\");\nprivate String value;\nActionEnum(String value) {\nthis.value = value;\n}\npublic String getValue() {\nreturn value;\n}\n@Override\npublic String toString() {\nreturn value;\n}\n}\n//DecisionBean.java\n@Component\npublic class DecisionBean implements Serializable {\npublic ActionEnum getDecision(int decisionId) {\nswitch (decisionId){\ncase 0:\nreturn ActionEnum.EDIT_ACCOUNT;\ncase 1:\nreturn ActionEnum.DELETE_ACCOUNT;\ncase 2:\nreturn ActionEnum.CREATE_ACCOUNT;\n}\nthrow new IllegalArgumentException(\"Option not supported!\");\n}\n}\n305\nChapter 7 ■ Spring Web FloW\n//account-flow.xml\n<flow...>\n<action-state id=\"accountDecision\">\n<evaluate\nexpression=\"decisionBean.getDecision(requestParameters.decisionId)\" />\n<transition on=\"EDIT_ACCOUNT\" to=\"edit\"/>\n<transition on=\"DELETE_ACCOUNT\" to=\"delete\"/>\n<transition on=\"CREATE_ACCOUNT\" to=\"create\"/>\n</action-state>\n<view-state id=\"edit\" ... >\n..\n</view-state>\n<view-state id=\"delete\" ... >\n..\n</view-state>\n< view-state id=\"create\" ... >\n..\n</view-state>\n</flow>\n• org.springframework.webflow.execution.Event: The transition will use the id of\nthe event object converted to String.\n• Any other value that evaluates to \"success\".\n■ ! When using an <evaluate /> expression inside a transition, a transition will occur if the result is any\nof the true(Boolean), “yes”, “true”(String), “success”. enumerated types are converted to a String using its\ntoString() method and the previous rule applies. any other object is treated as “success”.\n<view-state id=\"enterPersonInfo\" model=\"person\">\n...\n<transition on=\"proceed\" to=\"enterIdentityCardInfo\" >\n<evaluate expression=\"personService.isNewPerson(person)\"/>\n<!-- Must return \"true\", \"yes\",\n\"success\" or an object-->\n</transition>\n</view-state>\n306\nChapter 7 ■ Spring Web FloW\nSo far, actions have been used in quite a simple manner and used to invoke methods on existing beans.\nThese actions can be categorized as No action because they are used to invoke business services directly.\nThe concept of “No action” might be confusing. The reason such a category exists is to categorize actions\nthat are not defined by action classes.\n<!-- newPerson-flow.xml-->\n<action-state id=\"checkDuplicate\">\n<evaluate expression=\"personService.isNewPerson(person)\"/>\n<transition on=\"success\" to=\"enterIdentityCardInfo\"/>\n<!-- Transition always occurs -->\n</action-state>\n// PersonService.java\n@Service(\"personService\")\npublic class PersonService {\n@Autowired\nPersonManager personManager;\npublic boolean isNewPerson(Person person) {\nString pnc = PncBuilder.build(person);\nPerson existingPerson = personManager.getByPnc(pnc);\nreturn existingPerson == null;\n}\n}\nBut when the logic of an action becomes complicated, and even needs access to the flow context,\nactions can be implemented in different ways. The most simple way is to create a POJO (a bean), pass the\nflow context as an argument, and then invoke its methods by the flow. These are called the POJO actions.\n■ ! to mark poJo actions, developers usually create their own annotation and set it to be component-\nscanned. in the personal records Manager project, the annotation is called @WebFlowAction.\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface WebFlowAction {\n/**\n* The value may indicate a suggestion for a logical component name,\n* to be turned into a Spring bean in case of an autodetected component.\n* @return the suggested component name, if any\n*/\nString value() default \"\";\n}\n307\nChapter 7 ■ Spring Web FloW\nFor Spring to scan for this annotation, you have to add it to the configuration:\n@Configuration\n@EnableWebMvc\n@ComponentScan(basePackages = {\"com.pr, com.pr.persons,\ncom.pr.hospitals, com.pr.validator\"},\nincludeFilters = @ComponentScan.Filter(\nvalue = WebFlowAction.class,\ntype = FilterType.ANNOTATION\n))\n@ImportResource({\"classpath:spring/app-service-config.xml\",\n\"classpath:spring/db-config.xml\"})\npublic class MvcConfig extends WebMvcConfigurerAdapter {\n...\n}\nSo, the following code can be written using a POJO action in the following manner:\n<!-- newPerson-flow.xml-->\n<action-state id=\"checkDuplicate\">\n<evaluate expression=\n\"personAction.isNewPerson(requestContext)\" />\n<transition on=\"success\" to=\"enterIdentityCardInfo\"/>\n</action-state>\n//PersonAction.java\nimport com.pr.WebFlowAction;\nimport org.springframework.webflow.execution.RequestContext;\n@WebFlowAction\npublic class PersonAction {\npublic String isNewPerson(RequestContext context) {\nPerson person = (Person) context.getFlowScope().get(\"person\");\nString pnc = PncBuilder.build(person);\nPerson existingPerson = personManager.getByPnc(pnc);\nif (existingPerson == null) {\nreturn \"success\";\n} else{\nthrow new DuplicatePersonException(existingPerson);\n}\n}\n}\nNotice how the context is declared as a parameter and set as an argument by the developer in the web\nflow action definition. They way that exceptions are handled in a web flow execution is covered later.\n308\nChapter 7 ■ Spring Web FloW\nAnother type of actions are the plain actions. For each action, a class is created that implements the\norg.springframework.webflow.execution.Action interface or extends the Spring-provided implementation,\nthe org.springframework.webflow.action.AbstractAction class. The implementation provided by Spring\nprovides some methods that can be used to generate events. For example, this class implements the\norg.springframework.beans.factory.InitializingBean interface (covered in Chapter 2) to receive an\ninit callback when deployed within a Spring bean factory and exposes hooks to execute pre- (doPreExecute\n(RequestContext context)) and post- (doPostExecute(RequestContext context)) action execution.\nThe Action interface exposes only one method, named execute. Implementations of this interface are\nusually used to create singleton beans instantiated and managed by a Spring web application context. The\nrequest context is no longer declared as an argument in the flow definition, as an action defined this way is\nhandled by Spring, which knows the argument to call the action method with. The advantages of using plain\nactions is that they can easily be parametrized with mocks and stubs in test environments. Also, action proxies\nmay also be generated at runtime for delegating to POJO business operations that have no dependency on the\nSpring Web Flow API, which helps with decoupling components inside an application. They can be used to\nsimplify a flow definition when an action is simple enough, because there is no need for a SpEL in the evaluate\nelement or a method call; the name of the action component is enough for Spring to know what to do.\npackage org.springframework.webflow.execution;\npublic interface Action {\npublic Event execute(RequestContext context)\nthrows Exception;\n}\nThe previous example can be written using a plain action too, and the code will look as follows:\n<!-- newPerson-flow.xml -->\n<action-state id=\"checkDuplicate\">\n<evaluate expression=\"personAction\" />\n<transition on=\"success\" to=\"enterIdentityCardInfo\"/>\n</action-state>\n//PersonAction.java\nimport org.springframework.webflow.execution.Action;\n...\n@WebFlowAction\npublic class PersonAction implements Action {\n@Autowired\nPersonManager personManager;\n@Override\npublic Event execute(RequestContext context) throws Exception {\nPerson person = (Person) context.getFlowScope().get(\"person\");\nString pnc = PncBuilder.build(person);\nPerson existingPerson = personManager.getByPnc(pnc);\nif (existingPerson == null) {\nreturn new Event(this, \"success\");\n} else{\n\\\\ how an exception is handled in webflow context is covered\n\\\\later in the chapter\nthrow new DuplicatePersonException(existingPerson);\n}\n}\n}\n309\nChapter 7 ■ Spring Web FloW\nThe context is automatically passed as an argument by Spring.\nThe most complex type of actions are the MultiActions. They are implemented by extending the org.\nspringframework.webflow.action.MultiAction class, an extension of AbstractAction that provides\nmultiple helper methods for returning events. All action methods must have the same signature as the\nexecute method from the previous example; the context is also automatically passed as argument by Spring.\n• success(), error(), yes(), no()\n• result(), result(String), error(Exception)\nThe code in the previous example does not differ much when implemented with MultiAction, but it is\nadded here to underline the differences between the two implementations:\n<!-- newPerson-flow.xml -->\n<action-state id=\"checkDuplicate\">\n<evaluate expression=\"personAction.isNewPerson\" />\n<transition on=\"success\" to=\"enterIdentityCardInfo\"/>\n</action-state>\n//PersonAction.java\nimport org.springframework.webflow.action.MultiAction;\n...\n@WebFlowAction\npublic class PersonAction extends MultiAction {\n@Autowired\nPersonManager personManager;\npublic Event isNewPerson(RequestContext context) throws Exception {\nPerson person = (Person) context.getFlowScope().get(\"person\");\nString pnc = PncBuilder.build(person);\nPerson existingPerson = personManager.getByPnc(pnc);\nif (existingPerson == null) {\nreturn success();\n} else{\nthrow new DuplicatePersonException(existingPerson);\n}\n}\n}\nIn the previous examples, the same behavior was implemented using all types of actions, but\ntechnically, each type of action implementation is suitable to a certain case.\n• No action: Easy to use: just plug in a business method call in the web flow definition.\nThe main disadvantage here is the tight coupling between business logic and\nthe flow definition, and the fact that business method calls can make your web\nflow definition look crowded. It is proper for usage in simple web flows in simple\napplications.\n• POJO action: Can be used to glue the flow logic with the business login in a\ndecoupled way and provides a flexible way to solve business layer exceptions; but the\ndisadvantage is that the flow definitions might become more complex.\n310\nChapter 7 ■ Spring Web FloW\n• Plain action: There are not many cases when this should be used, except of course,\nfor explanatory exercises when teaching Spring Web Flow.\n• MultiAction: Offers all the advantages of a POJO action, and the code for the\nimplementation class might become quite complex.\nIt is recommended to use POJO actions and MultiActions, if possible, while taking into account the\ncomplexity of the flow definition vs. the complexity of the action class.\nFor any classes used to implement actions, the RequestContext is needed to obtain access to contextual\ninformation about the executing request. A new instance of this object is created every time there is a start,\nsignalEvent(resume flow), or refresh to reconstruct the last viewed selection when the user requests a\ndifferent response.\n• getFlowScope(): Returns a map that can be used to get/set flowScope attributes.\n• getRequestScope(): The same as getFlowScope(), but for the requestScope.\n• getActiveFlow(), getCurrentState(), getFlowExecutionURL(): Access\ninformation about the flow itself; typically used for auditing and debugging\napplications.\n• getMessageContext(): This can be used when an exception is thrown during an\naction execution on order to display an internationalized message regarding the\nerror.\n• getExternalContext(): Accesses information about the calling context.\nDecision States\nThe decision state type is an alternative for an action state type; when based on an evaluated expression,\nthere are multiple possibilities of transitioning. As you have seen so far with action-state, the only outcome\nis the transition to a \"success\" view-state or the reload of the current view-state to display an error message.\nThe decision state allows for branching of the transition process by using a practical if/then/else syntax,\nwhich allows an easier transitioning control. Similar to if/then/else statements in Java, the condition\nreturns a Boolean value that determines the next state to go. When more conditions are required, an action\nstate is more suitable.\n<!-- newPerson-flow.xml -->\n<decision-state id=\"checkDuplicate\">\n<if test=\"personService.isNewPerson(person)\" then=\"enterIdentityCardInfo\"\nelse=\"reviewExistingPerson\"/>\n</decision-state>\nA new view-state has been introduced in this example, reviewExistingPerson; it allows the user to\ninspect the person already in the system to verify that the existing person is the one he tried to insert.\nA decision state can be used in the final proposed flow to implement in this chapter, which is to check if\na person’s age is greater than 18 so that an account can be created; else, end the execution:\n<!-- newPerson-flow.xml -->\n<decision-state id=\"checkAdult\">\n<if test=\"personService.isAdult(person)\" then=\"enterAccountInfo\"\nelse=\"end\"/>\n</decision-state>\n311\nChapter 7 ■ Spring Web FloW\n//PersonService.java\nimport java.time.*;\n...\n@Service(\"personService\")\npublic class PersonService {\n// using Java 8 classes to determine age\npublic boolean isAdult(Person person){\nDate input = person.getDateOfBirth();\nInstant instant = input.toInstant();\nZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());\nLocalDate birthday = zdt.toLocalDate();\nlong yearsDelta = birthday.until(LocalDate.now(), ChronoUnit.YEARS);\nreturn yearsDelta>=18;\n}\n}\nException Handling\nIn the previous examples, the DuplicatePersonException exception class was mentioned. This class\nwas introduced to throw an exception when the user tries to add an existing person to the system and to\nexemplify exception handling in the context of web flows.\npublic class DuplicatePersonException extends RuntimeException {\nprivate Person person;\npublic DuplicatePersonException(Person person) {\nsuper(\"The person already exists in the system.\");\nthis.person = person;\n}\npublic Person getPerson() {\nreturn person;\n}\n}\nWhen exceptions are raised in the context of a flow execution, they can be taken care of in a few ways:\n• Let the exception propagate and define the web flow in such a way that an exception\nwill cause a transition to an exception view-state.\n<transition on-exception=\"com.pr.problem.DuplicatePersonException\"\nto=\"errorEndState\" />\n312\nChapter 7 ■ Spring Web FloW\n• Handle any exception globally; define a state in which any other state will transition\ninto when an exception is thrown.\n<flow>\n...\n<global-transitions>\n<transition\non-exception=\"com.pr.problem.DuplicatePersonException\"\nto=\"errorEndState\" />\n</global-transitions>\n</flow>\n• Use an <exception-handler bean=\"flowExceptionHandler\"/> element as a child\nelement to any state type. The bean set by the bean attribute of this element is a bean\nof type org.springframework.webflow.engine.FlowExecutionExceptionHandler.\nIt is recommended to avoid this option, as it can leave the flow in an invalid state\nwhen used incorrectly. The most simple way to create a flow executor handler is\nto extend the TransitionExecutingFlowExecutionExceptionHandler class that\nextends the previously mentioned interface. The following code snippet is the\nequivalent of the <global-transition /> element defined previously.\nimport org.springframework.webflow.engine.support.\nTransitionExecutingFlowExecutionExceptionHandler;\npublic class PersonFlowExceptionHandler\nextends TransitionExecutingFlowExecutionExceptionHandler {\npublic PersonFlowExceptionHandler() {\nsuper.add(DuplicatePersonException.class, \"errorStateId\");\n}\n}\n• Catch the exception in an Action class and return an error event.\n//PersonAction.java\n@WebFlowAction\npublic class PersonAction extends MultiAction {\n@Autowired\nPersonManager personManager;\npublic Event isNewPerson(RequestContext context) throws Exception {\nPerson person = (Person) context.getFlowScope().get(\"person\");\nString pnc = PncBuilder.build(person);\nPerson existingPerson = personManager.getByPnc(pnc);\nif (existingPerson == null) {\nreturn success();\n} else {\nreturn error();\n}\n}\n}\n313\nChapter 7 ■ Spring Web FloW\n■ ! before continuing further, take a look at the 12-pr-webflow-actions2-practice module project. this\nproject is expected to create a new Person instance, add all the details for it, and also insert a bank account into\nthe system. to do this, all the elements presented until now are used: actions, action-states, decision-states, and\nalso exception handling. the flow in Figure 7-18 requires a Hospital instance to be selected to create a Person\ninstance. but what if the Hospital instance does not already exist in the system and has to be created first?",
    "answer": "adding extra logic to do this will make the definition of the flow complicated and will connect the person and hospital logic. the proper way to do this is to add a subflow with the specific purpose of creating a new hospital instance. Figure 7-18. Add person and account flow definition 314 Chapter 7 ■ Spring Web FloW Figure 7-18 depicts a logical schema of the web flow definition to be implemented in this project. All elements are required to be defined in the newPerson-flow.xml. The isNewPerson is represented as a triangle, a decision-state, and the confirmAdult is represented as a fancy rectangle, an action-state. The Cancel and the Error states can be reached form any other state using global transitions, so they are not connected to the schema because it would make it quite difficult to read. In this example, some pieces of the flow definition are missing, but all the classes needed to wrap up the flow are fully developed and ready to use. The flow execution require three flow model objects: a PersonObjectModel instance, an IdentityCard, and an Account instance. The Account class was not used until now because every notion presented was covered without any complex logic being necessary. The Account class contains four fields that are populated by the user.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The IBAN7 field is mandatory and is considered to be 10 to 30 characters long, all\ndigits. An exception is thrown if the data introduced by the user does not match this\nrestriction.\n• The bank field is mandatory and a string representing a bank name is required.\n• The status field represents the status of the account and is also mandatory.\n• The amount field is the amount of money being held by the banking account; this\nfield is not mandatory.\nIn the following list, they steps of the execution and resources are presented to you, in the order you\nhave to use them in the newPerson-flow.xml definition:\n• The enterPersonInfo view-state is the same as in the previous code sample; the\ninitial state of the flow where a form is displayed to the user for basic personal\ninformation to be provided. All fields but middleName are mandatory and must be\nvalidated; the hospital drop-down list must be populated when the view-state is\nrendered. The event name that causes the transition to the next step is called next\nand the next state is called isNewPerson.\n• The contents of the view-state definition are missing and must be implemented to\nbehave as described previously. (TODO 41) After the implementation is done you\nshould see the view as in Figure 7-19.\n7See https://en.wikipedia.org/wiki/International_Bank_Account_Number.\n315\nChapter 7 ■ Spring Web FloW\nFigure 7-19. The enterPersonInfo view\n• The isNewPerson is a decision state using the result returned by calling the\npersonService.isNewPerson(person) method as a condition. The method is\ndefined in the com.pr.servicePersonService class, and a bean of this type named\npersonService is already defined. If the evaluation returns true, transitioning is\ndone to the enterIdentityCardInfo state, otherwise to the reviewExistingPerson\nstate. To test the transition to the reviewExistingPerson state, insert a person born\non October 1, 1935 at General Hospital.\nThe content of this decision-state definition is missing and must be implemented\nto behave as described earlier. (TODO 42)\n• The enterIdentityCardInfo is a view state that displays to the user a form\nrequesting identification information: values for the fields in the identityCard\nobject. All information is mandatory. The event to transition to the next state,\nconfirmAdult, is called save. The transition is done after evaluation of the\npersonBuilder.savePersonEntity(person, identityCard) method, and saving\nthe result in flowScope.existingPerson, because this flow variable is later used to\ncreate an account.\n316\nChapter 7 ■ Spring Web FloW\n• The content of this view-state definition is missing and must be implemented to\nbehave as described earlier. (TODO 43) After the implementation is done you should\nsee the view as in Figure 7-20.\nFigure 7-20. The enterIdentityCardInfo view\n• The reviewExistingPerson is a view-state that displays the basic information of\nan existing person in the system, with the same personal numerical code as the\nPerson instance that the user is trying to create. The data to populate the view is\nextracted at rendering time by calling personManager.getByPnc(person.pnc). The\npersonManager id one of the data management beans presented in Chapter 2. It is\ndefined in the 01-pr-service module project. The result of calling this method is\nsaved in the flowScope.existingPerson, because this flow variable is later used to\ncreate an account. From this state, the user can transition to the confirmAdult state\nby using the event named continue.\n317\nChapter 7 ■ Spring Web FloW\n• The content of this view-state definition is missing and must be implemented to\nbehave as described earlier. (TODO 44) After the implementation is done you should\nsee the view as in Figure 7-21.\nFigure 7-21. The reviewExistingPerson view\n• The confirmAdult state is an action-state that evaluates the personActions.\nisAdult expression. The class providing the implementation for this is com.\npr.PersonActions; it is a class extending the MultiAction class presented earlier.\nOn success, transition is done to the enterAccountInfo, and on error, transition is\ndone to end, because obviously the Person instance does not represent an adult so a\nbank account cannot be added for this instance, thus this is where the flow execution\nends. (TODO 45) The content of this action-state definition is missing and must be\nimplemented to behave as described earlier.\n• The enterAccountInfo is a view state that displays a form requesting minimum\ninformation for a bank account. The IBAN of the account must be unique in\nthe system. If you want to test the validation for this field, just insert the value\nUS1301101250000000012300695. Using the add event, if the information introduced\nis valid, a transition is done to the end state that displays the created person and\nbanking information existing for it in the system.\n318\nChapter 7 ■ Spring Web FloW\n• The content of this view-state definition is missing and must be implemented to\nbehave as described earlier. (TODO 46) After the implementation is done you should\nsee the view as in Figure 7-22.\nFigure 7-22. The enterAccountInfo view\n• error is a view-state used to display explicit content of the exceptions thrown in the\napplication. It was implemented this way so that while resolving this exercise, you\nhave a practical way to debug your problems, if you have any. In a real production\napplication, the error view is simpler and more user-friendly.\n• cancel is an end-state that the flow transitions into any time the user presses the\nCancel button in any view.\n• end is an end-state that redirects the user to a view with all the existing data for that\nperson in the system.\n• The <global-transaction /> element has two transition elements: one for the\ncancel scenario, when any the flow transitions to cancel, and one for any exception\nthat is being thrown in the flow transition to the error state.\n• When your implementation is correct and the data you inserted is valid, a new\nperson should be created in the system and a new bank account should be added for\nit, and after the flow execution, you should be redirected to a view that displays the\ninformation, which looks similar to the one shown in Figure 7-23.\n319\nChapter 7 ■ Spring Web FloW\nFigure 7-23. The view that the flow should redirect to after a successful execution\nIMpOrtaNt OBSerVatIONS\nthe bind=\"false\" attribute is needed, so the form is not validated before transitioning to the cancel\nstate, as validation errors will prevent the transition.\n<global-transitions>\n<transition on=\"cancel\" to=\"cancel\" bind=\"false\" />\n<transition on-exception=\"java.lang.Exception\" to=\"error\" />\n</global-transitions>\nWhen using web flows, the exception handling is the most undocumented part of Spring Web Flow.\nUnless a web flow exception handler is used, or action states that return error events and add the\nexception object to the flowScope, catching and treating exceptions is very tricky. Developers are\nbasically forced into writing the code. that’s why all web flow exceptions in this project cause a\ntransition to the error view that uses JSp scriptlets to display a very detailed stacktrace that help\ndevelopers reading this book to easily identify the mistakes in the code and configuration. the exception\ncan be retrieved using the request. as mentioned, this view is only to be used for development\npurposes; for production, a more user-friendly view implementation should be used.\n320\nChapter 7 ■ Spring Web FloW\n<!-- webapp/WEB-INF/error.jsp -->\n<div class=\"error\">\n<%\nException exception =\n(Exception) request.getAttribute(\"flowExecutionException\");\nException cause =\n(Exception) request.getAttribute(\"rootCauseException\");\n%>\n...\n<%\nexception.printStackTrace(new java.io.PrintWriter(out));\n%>\n...\n<% if (cause != null) { %>\n<h3>Cause: <%=cause.getMessage()%></h3>\n<p>\n<%\ncause.printStackTrace(new java.io.PrintWriter(out));\n%>\n</p>\n<%} %>\n</div>\nin case you insert data that is invalid, you can use the browser back button to go back to the previous\nstate and change the information. to prevent browsing back to a state previous to a transition with the\nback button, the history attribute of the transaction element can be used:\n<transition on=\"confirm\" to=\"end\" history=\"discard\">\n<!-- or invalidate all previous visited views in the browser history -->\n<transition on=\"confirm\" to=\"end\" history=\"invalidate\">\nthe default value for this attribute is preserve, which allows returning to a state before the execution of\nthe transition and the data for the state is still accessible.\ndiscard prevents backtracking to the state, meaning that all information related to the state is\ndiscarded and using the browser back button results in a 500 http internal server error.\ninvalidate prevents backtracking to the state, as well as any previously entered view-state, and\npressing the browser back button has the same effect as the previous case.\nthe proposed solution for this project can be found in the 12-pr-webflow-actions2-solution project.\n321\nChapter 7 ■ Spring Web FloW\nSubflows\nA subflow is a flow that is being invoked by another flow. It has its own scope and the parent flow execution is\nsuspended while the subflow is being executed. The conversation scope is the only scope that is shared between\nthe parent flow and the subflows, as depicted in Figure 7-7. The subflow must be defined in the application in\nthe same manner as any flow; it has its own views and language resources, because it is essentially a flow.\nA subflow is launched from a special state in a parent flow called subflow-state. In the following\nexample, the newPerson flow calls the newHospital subflow.\n<!-- newPerson-flow.xml-->\n<flow ...>\n<view-state id=\"enterPersonInfo\" model=\"person\">\n<binder>...</binder>\n<transition on=\"next\" to=\"isNewPerson\" />\n<transition on=\"addHospital\" to=\"newHospital\"/>\n</view-state>\n<subflow-state id=\"newHospital\"\nsubflow=\"hospitals/newHospital\" >\n<output name=\"hospital\"/>\n<transition on=\"saveHospital\" to=\"enterPersonInfo\">\n<evaluate expression=\"hospitalManager.save(hospital)\"\nresult=\"flashScope.hospital\" />\n<set name=\"flashScope.hospitalMessage\"\nvalue=\"hospital.msg.success\" />\n</transition>\n<transition on=\"cancel\" to=\"enterPersonInfo\" />\n</subflow-state>\n</flow>\nThe subflow in the previous example allows the user to insert a new Hospital instance in the system\nso that it can be used when the person is created, if the state transitioning into is saveHospital. The id of\nthe subflow-state is the id of this state inside the newPerson flow definition. The subflow attribute is used to\nlink this flow invocation with the flow definition, and contains the path inside the WEB-INF, where the flow\ndefinition and resources can be found. In the previous case, the flow definition file is located at /WEB-INF/\nhospitals/newHospital/newHospital-flow.xml. Once registered with the FlowDefinitionRegistry,\nthe subflow can be referred from any flow using its logical name, which is composed of the location and the\nflow name as a value for the subflow attribute:\n\\\\WebFlowConfig.java\n@Configuration\npublic class WebFlowConfig extends AbstractFlowConfiguration {\n...\n@Bean\npublic FlowDefinitionRegistry flowRegistry() {\nreturn getFlowDefinitionRegistryBuilder(flowBuilderServices())\n.setBasePath(\"/WEB-INF\")\n.addFlowLocation(\"/persons/newPerson/newPerson-flow.xml\")\n.addFlowLocation(\"/hospitals/newHospital/newHospital-flow.xml\")\n.build();\n}\n}\n322\nChapter 7 ■ Spring Web FloW\n<subflow-state id=\"newHospital\"\nsubflow=\"hospitals/newHospital\" >\n<!-- hospitals = directory for Hospital specific resources -->\n<!-- newHospital = flow name-->\nThe key values used for transitions inside the parent flow are the ids of end-states in the subflow:\n<!-- newHospital-flow.xml-->\n<flow ..>\n<var name=\"hospital\" class=\"com.pr.ents.Hospital\"/>\n<view-state id=\"enterHospitalInfo\" model=\"hospital\">\n<binder>\n<binding property=\"name\" required=\"true\"/>\n<binding property=\"code\" required=\"true\"/>\n<binding property=\"address\"/>\n<binding property=\"location\" required=\"true\"/>\n</binder>\n<transition on=\"save\" to=\"saveHospital\"/>\n<transition on=\"cancel\" to=\"cancel\" bind=\"false\" />\n</view-state>\n<end-state id=\"saveHospital\">\n<output name=\"hospital\" value=\"hospital\"/>\n</end-state>\n<end-state id=\"cancel\"/>\n</flow>\nThe flashScope.hospitalMessage variable is used to display a message telling the user that the\nHospital instance was saved correctly and can be used.\nAlthough the conversation scope is accessible to the parent flow and subflows, global variables usage is\ndiscouraged, because it reduces the readability of the code, so that passing parameters between the parent\nflow and the subflow is more appropriate.\nThe <output name=\"hospital\"/> is an output parameter designed to return the Hospital instance\ncreated by the newHospital flow to the parent flow; it is assigned the flashScope (see the evaluate element\nmarked with (1) in the following code snippet).\nThere are also input parameters, required or not, to provide a parent flow variable value to the subflow.\nIn the previous case, there is nothing needed, but assuming that you would need to send a Person instance\nas a manager for the hospital we are trying to create, the preceding definitions will change a little. The\ninstance given as parameter has the flowScope in both of the flows because it is defined right under the\n<flow /> element.\n323\nChapter 7 ■ Spring Web FloW\n<!-- newPerson-flow.xml-->\n<flow ...>\n<var name=\"person\" class=\"com.pr.ents.Person\"/>\n<view-state id=\"enterPersonInfo\" model=\"person\">\n<binder>...</binder>\n<transition on=\"next\" to=\"isNewPerson\" />\n<transition on=\"addHospital\" to=\"newHospital\"/>\n</view-state>\n<subflow-state id=\"newHospital\"\nsubflow=\"hospitals/newHospital\" >\n<input name=\"manager\" value=\"person\"/>\n<output name=\"hospital\"/>\n<transition on=\"saveHospital\" to=\"enterPersonInfo\">\n(1) <evaluate expression=\"hospitalManager.save(hospital)\"\nresult=\"flashScope.hospital\" />\n<set name=\"flashScope.hospitalMessage\"\nvalue=\"hospital.msg.success\" />\n</transition>\n<transition on=\"cancel\" to=\"enterPersonInfo\" />\n</subflow-state>\n</flow>\n<!-- newHospital-flow.xml-->\n<flow ...>\n<input name=\"manager\" required=\"true\"/>\n<var name=\"hospital\" class=\"com.pr.ents.Hospital\"/>\n<view-state id=\"enterHospitalInfo\" model=\"hospital\">\n...\n</view-state>\n</flow>\nWhen subflows are involved, unit testing is quite tricky; that’s why it is recommended to mock or stub\nthem when the focus of the testing is on the parent flow. By overriding the configureFlowBuilderContext\nmethod from AbstractXmlFlowExecutionTests, a mock definition for the subflow can be added to the\ncontext:\nimport org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests;\npublic class NewPersonFlowTest extends AbstractXmlFlowExecutionTests {\n...\n@Override\nprotected void configureFlowBuilderContext\n(MockFlowBuilderContext builderContext) {\n324\nChapter 7 ■ Spring Web FloW\n// setup newHospital subflow\nFlow newHospital = new Flow(\"newHospital\");\nState start = new State(newHospital, \"newHospital\") {\n@Override\nprotected void doEnter(RequestControlContext context)\nthrows FlowExecutionException {\n// empty\n}\n};\nnewHospital.setStartState(start);\nbuilderContext.registerSubflow(newHospital);\n}\n...\n}\nUnfortunately, even as this book is being written, testing subflows is still cumbersome and there are a\nlot of bugs opened and unresolved.8\nWhen the scope is to test the subflows too, the getModelResources method of\nAbstractXmlFlowExecutionTests must be overridden. Add the subflow definition to the flow resources\nbeing tested:\nimport org.springframework.webflow.engine.Flow;\nimport org.springframework.webflow.test.MockExternalContext;\nimport org.springframework.webflow.test.MockFlowBuilderContext;\nimport org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests;\npublic class NewPersonFlowTest extends AbstractXmlFlowExecutionTests {\n...\n@Override\nprotected FlowDefinitionResource\ngetModelResources(FlowDefinitionResourceFactory resourceFactory) {\nFlowDefinitionResource flowDefinitionResources =\nnew FlowDefinitionResource2;\nflowDefinitionResources0 = resourceFactory.createResource\n(\"src/main/webapp/WEB-INF/persons/newPerson/newPerson-flow.xml\");\nflowDefinitionResources1 = resourceFactory.createResource\n(\"src/main/webapp/WEB-INF/hospitals/newHospital/newHospital-flow.xml\");\nreturn flowDefinitionResources;\n}\n...\n}\n8A bug related to mocking subflows; still open and unresolved since version 2.0.6. See\nhttps://jira.spring.io/browse/SWF-1079.\n325\nChapter 7 ■ Spring Web FloW\n■ ! Considering that the subflows are not a topic for the exam, there is no practice project with configurations\nmissing, but a project was created that you can run and inspect to see the subflow to add a Hospital instance\nrunning:\n13-pr-webflow-subflow-solution.\n■ ?",
    "answer": "as a proposed exercise, if you want to test your understanding of subflows, you can try to turn the creating of an Account instance into a subflow. Flow Definition Inheritance Flow definitions can be organized in hierarchies in a way similar way to bean definitions. Organizing them in hierarchies allows global transitions, common states, and actions to be shared among parent and children flows. The child flow and the parent flow are both registered in the same flow registry. There are a few things regarding flow definition inheritance that are interesting and worth covering. One of them is that multiple inheritance is supported, because inheritance between web flow definitions is more like a composition; basically, a child flow definition inherits all configuration elements form its parents, and elements with the same id are merged. Multiple parents are specified using comma as a separator: <flow ... parent=\"parentFlow1, parentFlow2\" /> ... </flow> Parent flow definitions can also be abstract. In this case, these flows cannot be instantiated and executed; their purpose in the code is to wrap up common definition elements for multiple child flow definitions, to respect the DRY principle.9 <flow ... abstract=\"true\" /> ... </flow> Flow inheritance is analogous to bean definition inheritance. It is more a composition than inheritance, as parent and child are merged together to create a new flow. Another interesting thing is that flow definition inheritance can be selective, meaning there is a way that only certain state definitions can be inherited, instead of the whole parent flow definition: <flow ... parent=\"parentFlowName\"/> <view-state id=\"childState\" parent=\"parentFlowName#stateId\"> </flow> The restriction here is that the child flow can inherit only from one parent when restrictions are defined at the state level. Also, the child state definition type must be one and the same with the parent state definition. In the preceding example, the state element with stateId must be of type view-state in the parent too; otherwise, the web flow configuration is invalid. 9Don’t Repeat Yourself. 326 Chapter 7 ■ Spring Web FloW Securing Web Flows Before talking about how to secure web flows, a detailed introduction into Spring Security is necessary, because you need to understand core security concepts and how they can be configured with Spring Security. Introduction to Spring Security Spring Security is a framework that can be used to secure web applications. It is very easy to use and highly customizable, providing access control over units of an application. When writing secure Spring web applications, this is the default tool that developers go to because configuration follows the same standard with all the Spring projects. Infrastructure beans are provided out of the box for multiple types of authentication and they are clearly compatible with other Spring projects. Spring Security provides a wide set of capabilities that can be grouped in four areas of interest: authentication, authorizing web requests, authorizing methods calls, and authorizing access to individual domain objects. The following are Spring Security’s core features:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Authentication (user identification) and authorization (managing access to\nresources); comprehensible and extensible support is provided.\n• It is easy to configure.\n• It is highly customizable.\n• Protection against session fixation, clickjacking, cross-site request forgery, and other\ntype of attacks is provided via simple and flexible configurations.\n• It can be integrated with the Servlet API.\nOf course, there are more. You can read more about them on the official page of this project.10\nThere are five security concepts that you have to familiarize yourself with and understand to use Spring\nSecurity:\n• Credentials are identification keys that an entity presents to the application to\nconfirm their identity( a password or a token).\n• Principal represents an authenticated entity that was recognized by the application\nbased on its credentials.\n• Authentication is the process that determines if the credentials of an entity are valid.\n• Authorization is the process that determines if a principal is allowed access to a\nresource or performs a certain action. The decision process is often based on roles.\nThe following are the most common roles:\n• GUEST, usually can just view data\n• MEMBER (or USER), can insert data\n• ADMIN, can insert and delete data\n• Secured item is a resource that is being secured.\n10Spring Security page at http://spring.io/spring-security.\n327\nChapter 7 ■ Spring Web FloW\nThe Spring Security version used in the book is 4.0.2.RELEASE and it is compatible with Spring 4. In\nthe Gradle configuration of the 14-pr-web-security-practice module project, notice that the following\nlibraries have been added:\nspringSecurityVersion = '4.0.2.RELEASE'\n...\nsecurityConfig : \"org.springframework.security:spring-security-config:\n$springSecurityVersion\",\nsecurityWeb : \"org.springframework.security:spring-security-web:\n$springSecurityVersion\",\nsecurityTaglibs: \"org.springframework.security:spring-security-taglibs:\n$springSecurityVersion\",\n...\n}\nWhy Spring Security Is Awesome\nThe spring-security-config module provides security namespace parsing code and is needed when using\nXML configuration. As some developers still prefer to use XML configuration, the minimum configuration\nneeded in XML is explained in the book alongside the Java Configuration. The spring-security-web\nprovides filters and related web-security infrastructure beans. This library is needed for web-based\nauthentication. The spring-security-taglibs provides security tags that can be used to secure elements in\nJSP pages.\nThe main reason why Spring Security is preferred when developing web applications is portability.\nSpring Security does not need a special container to run in; it can be deployed as a secured archive (WAR or\nEAR) and can run in stand-alone environments. For example, a secured web application archived as a WAR\ncan be deployed on a JBoss or an Apache Tomcat application server. And as long as the underlying method of\nstoring credentials is configured, the application will run exactly the same in any of these application servers.\nWhen it comes to authentication and credential storage, Spring Security is very flexible. All common\nauthentication mechanisms are supported (Basic, Form, OAuth, X.509, cookies, single sign-on). Regarding\nsupport storage for credentials databases, Spring Security supports anything—LDAP, properties file, custom\nDAOs, and even beans, among many others.11\nConfiguring Spring Security is easy. A common practice is to define a separate file when using XML and\na separate configuration class when using Java Configuration. Infrastructure beans can be used to customize\nthe following:\n• How a principal is defined\n• Where authentication information is stored\n• How authorization decisions are made\n• Where security constraints are stored\nAs we have seen so far when using Spring, anything can be done by keeping components as decoupled\nas possible. Spring Security respects the principle of separation of concerns (SoC). Restrictions are applied\nusing an interceptor-based approach. It was mentioned at the beginning of the book that AOP is used when\nsecuring resources. Also, authentication and authorization are decoupled; changing the authentication\nmethod and credentials support does not affect authorization.\n11A full list of authentication technologies that Spring Security integrates with; it can be found at http://docs.\nspring.io/spring-security/site/docs/current/reference/htmlsingle/#what-is-acegi-security.\n328\nChapter 7 ■ Spring Web FloW\nSpring Security is consistent. The authentication purpose is to create a security context with the\nprincipal’s information; it does not depend on the mechanism used. The authorization process has the same\npurpose, regardless of the resource type: consult resource properties, consult the principal’s role, and decide\nto grant or deny access.\nThe way Spring Security works and the core components are depicted in Figure 7-24.\nFigure 7-24. Spring Security anatomy\nThe following explains the flow described in Figure 7-24:\n1. The user makes a login request. (Introduces credentials in a login form and\nsubmits it.)\n2. The user logs into the application and the Authentication Manager populates\nthe security information of the user into the security context.\n3. When the user makes resource requests (requests to view a page, starts a flow,\nrequests a document) after logging in, the security interceptor intercepts them\nbefore they invoke a protected/secured resource.\n4. The Security Interceptor then retrieves the user information from the context.\n5. The Access Decision Manager polls a list of voters to return a decision regarding\nthe rights the authenticated user has on system resources\n6. The Spring Interceptor consults the resource attributes that are configured in the\napplication.\n7. Access is granted or denied to the resource based on the user rights (5) and the\nresource attributes (6).\n329\nChapter 7 ■ Spring Web FloW\nSpring Security XML Configuration\nWhen using XML to configure Spring Security, any tag can be used by adding the security namespace to the\nSpring configuration file at http://www.springframework.org/schema/\nsecurity/spring-security.xsd. The recommended practice is to have a separate configuration file\nthat contains only the security-related configurations.\nTo log in to the Personal Records Manager application, a separate file should be created, named\nsecurity-config.xml. This file should define the users and credentials needed to access the application\nand which resources these users can access:\n<!-- security-config.xml -->\n<beans xmlns:sec=\"http://www.springframework.org/schema/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/security\nhttp://www.springframework.org/schema/security/spring-security.xsd\">\n<!-- styling&internationalization resources do not need to be secured -->\n<sec:http pattern=\"/images/*\" security=\"none\"/>\n<sec:http pattern=\"/styles/*\" security=\"none\"/>\n<sec:http pattern=\"/resources/*\" security=\"none\"/>\n<sec:http auto-config=\"true\">\n<sec:intercept-url pattern=\"/auth*\" access=\"permitAll\"/>\n<sec:intercept-url pattern=\"/persons/newPerson\"\naccess=\"ROLE_ADMIN\"/>\n<sec:intercept-url pattern=\"/**\"\naccess=\"ROLE_USER, ROLE_ADMIN\"/>\n<sec:form-login login-page=\"/auth\"\nauthentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <sec:logout logout-url=\"/j_spring_security_logout\" logout-success-url=\"/home /> </sec:http> <sec:authentication-manager> <sec:authentication-provider> <sec:user-service> <sec:user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <sec:user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <sec:user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </sec:user-service> </sec:authentication-provider> </sec:authentication-manager> </beans> 330 Chapter 7 ■ Spring Web FloW The configuration presented earlier uses basic authentication, without any password encryption. The auto-config=\"true\" is a legacy attribute that automatically registers a login form, BASIC authentication, and a logout URL and logout services. It is not meant to be used for production applications, as the level of security required is higher than the default one provided by Spring Security out of the box for educational purposes. The <intercept-url /> elements are evaluated in the order they are listed into the configuration, so the most restrictive ones need to be at the top of the list; otherwise, the result might not be the expected one. Three users are defined with different roles. Access to the newPerson flow has been restricted to users having the ROLE_ADMIN role, to test the configuration. This file is Spring Security 3.0–specific and it won’t work in a Spring Security 4 environment, because this version has introduced a lot of changes. The <sec:logout /> logout element is used to customize logout details. The logout-url attribute specifies the URL that will cause a logout. Spring Security initializes a filter that responds to this particular URL. The logout-success-url attribute is used to define where the user is redirected after logging out. In the <sec:form-login /> the URL of the page used for authentication is set as a value for the login- page attribute. After successfully logging in, the user is redirected to the page set as a value for the default- target-url attribute. In case of failure, the user is redirected to the login view, and using the auth_error parameter, a proper value is displayed to the user. The auth.jsp template file presents to the user a login form looks like this for Spring Security 3: <!-- auth.jsp --> <form action=\"<c:url value='/j_spring_security_check'/>\" method=\"post\"> <table> <tr> <td> <label for=\"j_username\"> <spring:message code=\"login.username\"/> </label> </td> <td> <input type='text' id='j_username' name='j_username' value='<c:out value=\"${user}\"/>'/> </td> </tr> <tr> <td> <label for=\"j_password\"> <spring:message code=\"login.password\"/> </label> </td> <td><input type='j_password' id='password' name='j_password'/></td> </tr> <tr> <td colspan=\"2\"> <button type=\"submit\"> <spring:message code=\"login.submit\"/> </button> </td> </tr> </table> <c:if test=\"${not empty param.auth_error}\"> 331 Chapter 7 ■ Spring Web FloW <div id=\"errors\" class=\"error\"> <!-- detailed security exception message is printed for development purposes --> <!-- obviously, not recommended to be used in a production application --> <p><spring:message code=\"login.fail\"/>: ${SPRING_SECURITY_LAST_EXCEPTION.message} </p> </div> </c:if> </form> There is another way to specify access by using Spring Security Expressions, but they must be enabled by declaring the use-expressions=\"true\" attribute on the <sec:http /> configuration element. So, the access attributes under the <sec:http /> configuration element become this: <sec:http auto-config=\"true\" use-expressions=\"true\"> <sec:intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <sec:intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ROLE_ADMIN')\"/> <sec:intercept-url pattern=\"/**\" access=\"hasAnyRole('ROLE_USER, ROLE_ADMIN')\"/> <sec:form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <sec:logout logout-url=\"/j_spring_security_logout\"/> </sec:http> ■ ! Mixing expression style configuration with direct configuration is not permitted. You either use expressions or you don’t. Mixing them will make your configuration file invalid. Spring Security Expressions are quite easy to use and understand:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "hasRole('role') checks whether the principal has the given role.\n• hasAnyRole('role1', 'role2', ?",
    "answer": ") checks whether the principal has any of the given roles.",
    "source": "extracted",
    "confidence": 0.58
  },
  {
    "question": "isAuthenticated() allows access for authenticated or remembered principals.\n• permitAll allows unauthenticated users access to a resource. In the previous\nexample, this is used to make sure that the login form is accessible so a user can\ninsert his credentials for authentication to take place.\n• Expressions can be aggregated hasRole('ROLE_ADMIN') and\nhasRole('ROLE_MANAGER').\n332\nChapter 7 ■ Spring Web FloW\nThe preceding configuration is relative to the beans namespace. Considering that the configuration file\ncontains only security tags, the file could be created relative to the security namespace, and so the sec prefix\nwould not be necessary, which makes the file more readable:\n<?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <http pattern=\"/images/*\" security=\"none\"/> <http pattern=\"/styles/*\" security=\"none\"/> <http pattern=\"/resources/*\" security=\"none\"/> <http auto-config=\"true\" use-expressions=\"true\"> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ROLE_ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('ROLE_USER, ROLE_ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> <authentication-manager> <authentication-provider> <user-service> <user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </user-service> </authentication-provider> </authentication-manager> </beans:beans> Spring Security 4 has introduced a few critical changes that need coverage in this book; because by the time this book is published, Spring Security 4 might be a subject on the exam. 333 Chapter 7 ■ Spring Web FloW ■ ! Spring Security 4 has introduced the possibility of using CSFr tokens in Spring forms to prevent cross- site request forgery.12 a configuration without a <csrf /> element configuration is invalid, and any login requests direct you to a 403 error page stating: Invalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-CSRF-TOKEN'. To migrate from Spring Security 3 to version 4, you have to add a configuration for that element, even if all you do is disable using CSRF tokens. <http auto-config=\"true\" use-expressions=\"true\"> <csrf disabled=\"true\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" logout-success-url=\"/\"/> </http> The delete-cookies attribute can be used to specify a list of cookies to delete at logout time. In the previous configuration, only one is specified, named JSESSIONID; but if the application uses more cookies, they can be specified as a value for this attribute using their names separated by commas. 12This type of attack consists of hacking an existing session to execute unauthorized commands in a web application. You can read more about it at https://en.wikipedia.org/wiki/Cross-site_request_forgery. 334 Chapter 7 ■ Spring Web FloW ■ ! other critical changes are related to the login form default Spring resources, such as the login Url (that indicates an authentication request) and names of the request parameters (expected keys for generation of an authentication token).13 these were changed to match JavaConfig. the login form in the auth.jsp view became the following: <form action=\"<c:url value='/login'/>\" method=\"post\"> <table> <tr> <td> <label for=\"username\"> <spring:message code=\"login.username\"/> </label> </td> <td> <input type='text' id='username' name='username' value='<c:out value=\"${user}\"/>'/> </td> </tr> <tr> <td> <label for=\"password\"> <spring:message code=\"login.password\"/> </label> </td> <td><input type='password' id='password' name='password'/></td> </tr> <tr> <td colspan=\"2\"> <button type=\"submit\"> <spring:message code=\"login.submit\"/> </button> </td> </tr> </table> </form> 13The full list of configuration changes that were made to match Java Configuration is at https://jira.spring.io/ browse/SEC-2783. 335 Chapter 7 ■ Spring Web FloW ■ ! all previous examples used default values for the login Url and the authentication key names j_spring_ security_check, j_username, j_password (in Spring Security 3), login, username, password (in Spring Security 4). Keep in mind that all of them can be redefined using Spring configuration. If you are interested in keeping your form as secure as possible, you can configure CSRF usage and add the token generated by Spring to your form. The following are the required modifications:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "First you must enable CSRF generation in your security-config.xml file by adding\na <csrf /> configuration element and a repository to generate the value for it.\nModify the logout element appropriately; the third bullet in this list tells you why.\n<beans:beans .../>\n<beans:bean id=\"tokenRepo\"\nclass=\"org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository\">\n<beans:property name=\"sessionAttributeName\" value=\"_csrf\"/>\n</beans:bean>\n<http auto-config=\"true\" use-expressions=\"true\">\n<csrf token-repository-ref=\"tokenRepo\"/>\n<intercept-url pattern=\"/auth*\" access=\"permitAll\"/>\n<intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/>\n<intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/>\n<form-login login-page=\"/auth\"\nauthentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" invalidate-session=\"true\" logout-success-url=\"/\"/> </http> ... </beans:beans>",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Second, you must add a hidden parameter in every form that you are interested in\nprotecting form cross-site request forgery.\n<form action=\"<c:url value='/login'/>\" method=\"post\">\n<input type=\"hidden\"\nname=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/>\n<table>\n<tr>\n<td>\n<label for=\"username\">\n<spring:message code=\"login.username\"/>\n</label>\n</td>\n<td>\n<input type='text' id='username' name='username'\nvalue='<c:out value=\"${user}\"/>'/>\n</td>\n336\nChapter 7 ■ Spring Web FloW\n</tr>\n<tr>\n<td>\n<label for=\"password\">\n<spring:message code=\"login.password\"/>\n</label>\n</td>\n<td><input type='password' id='password' name='password'/></td>\n</tr>\n<tr>\n<td colspan=\"2\">\n<button type=\"submit\">\n<spring:message code=\"login.submit\"/>\n</button>\n</td>\n</tr>\n</table>\n</form>\n• And last, logging out becomes a pain when CSRF is enabled, because you need to\nlog out using a POST request. Thus, you cannot just use a link build like this (like in\nSpring Security 3):\n<a href=\"<spring:url value=\"/j_spring_security_logout\"/>\">\n<spring:message code=\"menu.logout\"/>\n</a>\nYou need to add a logout form to the page and submit it using JavaScript:\n<spring:url value=\"/logout\" var=\"logoutUrl\" />\n<form action=\"${logoutUrl}\" id=\"logout\" method=\"post\">\n<input type=\"hidden\" name=\"${_csrf.parameterName}\"\nvalue=\"${_csrf.token}\"/>\n</form>\n<a href=\"#\" onclick=\"document.getElementById('logout').submit();\">\n<spring:message code=\"menu.logout\"/>\n</a>\nAlso, as we’ve been mentioning logout, you probably noticed the extra attributes of the <logout />\nelement; their names are quite obvious, and if specified at logout, the specific resources are cleaned\naccordingly:\n<logout logout-url=\"/logout\"\ndelete-cookies=\"JSESSIONID\"\ninvalidate-session=\"true\"\nlogout-success-url=\"/\"/>\n337\nChapter 7 ■ Spring Web FloW\nAlso, a handler can be used instead of the logout-success-url that takes care of redirecting to the\nproper page and eventually cleaning up any resources:\n<logout logout-url=\"/logout\"\ndelete-cookies=\"JSESSIONID\"\nsuccess-handler-ref=\"logoutSuccessHandler\"/>\nTo view the token Spring Security has generated, you can use Firebug to view the contents of your login\nrequest. You should see something similar to what is depicted in Figure 7-25.\nFigure 7-25. Spring Security CSRF token\n■ ! another simplification change that can be done to this file is provided by a new feature introduced in\nSpring Security 4 that allows access expressions to be specified without the ROLE_ prefix in front of them; thus,\nthe preceding configuration becomes this:\n<http auto-config=\"true\" use-expressions=\"true\">\n<csrf disabled=\"true\"/>\n<intercept-url pattern=\"/auth*\" access=\"permitAll\"/>\n<intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/>\n<intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/>\n<form-login login-page=\"/auth\" authentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> 338 Chapter 7 ■ Spring Web FloW <authentication-manager> <authentication-provider> <user-service> <user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </user-service> </authentication-provider> </authentication-manager> Another part of configuration needs to be added in the web.xml file, if used. A security filter needs to be added to intercept all requests to the application. springSecurityFilterChain is a mandatory name and refers to an infrastructure bean with the same name. This bean is responsible for all the security within the application (protecting the application URLs, validating submitted usernames and passwords, redirecting to the log in form, etc.). <filter> <filter-name>springSecurityFilterChain</filter-name> <filter-class> org.springframework.web.filter.DelegatingFilterProxy </filter-class> </filter> <filter-mapping> <filter-name>springSecurityFilterChain</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> Configure Authentication It was mentioned that authentication can be configured to work with almost any credential support technology. In this subsection, a few of them are covered. By default, in Spring Security the DAO authentication provider is used, as well as a specific UserDetailsService implementation to provide credentials and authorities. In the examples so far, the credentials were basically read from the configuration file and stored into memory. The credentials were not encrypted, so even if Spring Security is used, the application is not that secure. To encrypt credentials, the configuration must be modified to specify the encryption type: <!-- spring-config.xml --> <authentication-manager> <authentication-provider> <password-encoder hash=\"md5\" > <salt-source system-wide=\"MySalt\"/> </password-encoder> <user-service properties=\"/WEB-INF/users.properties\" /> </authentication-provider> </authentication-manager> 339 Chapter 7 ■ Spring Web FloW #/WEB-INF/users.properties john=a1c093d7a2742f0afef7720883a59016,ROLE_USER #password: john jane=a1c093d7a2742f0afef7720883a59016,ROLE_USER,ROLE_ADMIN #password: jane admin=5a693853b2958ecb256db46b808ac488,ROLE_ADMIN #password: admin In the preceding configuration, the md514 algorithm is used to encrypt the passwords and a method called password-salting is used to increase the security passwords by adding a well-known string to them. The string added to the password can be an application-wide string, like in the previous example where the String is \"MySalt\", or it can be a property of the entity—something that won’t change, like its unique identifier in the system, for example. A combination of properties can be used as salt too, but all the properties must be constant for the duration of the entity; if any of the property values changes, the user won’t be able to log in anymore because the authentication system won’t be able to create the correct hash. The preceding encrypted strings were generated using an instance of org.springframework.security. authentication.encoding.Md5PasswordEncoder: import org.springframework.security.authentication.encoding.Md5PasswordEncoder; public class PasswordGenerator { public static void main(String args) { Md5PasswordEncoder encoder = new Md5PasswordEncoder(); String encrypted = encoder.encodePassword(\"doe\", \"MySalt\"); System.out.println(encrypted); encrypted = encoder.encodePassword(\"admin\", \"MySalt\"); System.out.println(encrypted); } } To use an entity property as salt, the previous configuration must be modified like this: <authentication-manager> <authentication-provider> <password-encoder hash=\"md5\"> <salt-source user-property=\"id\" /> </password-encoder> </authentication-provider> </authentication-manager> The credentials were decoupled from the configuration by isolating them in a property file, which can be easily edited without needing to recompile the application. The credentials property file has a specific syntax: [username] = [password(encrypted)],[role1,role2...] 14Read more about MD5 at https://en.wikipedia.org/wiki/MD5. 340 Chapter 7 ■ Spring Web FloW But credentials in memory storage is not a solution for production applications; this is only suitable for very small and educational applications. For production application, the most common storage for credentials is a database. To provide these credentials to the authentication manager, a data source is needed: <authentication-manager> <authentication-provider> <jdbc-user-service data-source-ref=\"authDataSource\" /> </provider> </authentication-manager> Two tables must be accessible using the authDataSource: one named users containing user credentials and one named authorities continuing user-role correspondences. The following queries are run by the authentication provider and must execute successfully: SELECT username, password, enabled FROM users WHERE username = ? SELECT username, authority FROM authorities WHERE username = ? Another way to provide credentials is to write a custom implementation for an authentication provider: <authentication-manager> <authentication-provider user-service-ref=\"customCredentialsProvider\" /> </authentication-manager> The provider class can delegate to a DAO implementation to retrieve principals from a database using a data source and customized queries. The information is returned into a format recognized in the application. In the following example, an instance of type UserInfo is used as a principal in the application: [commandchars=* @Repository public class CustomCredentialsProvider { private JdbcTemplate jdbcTemplate; @Autowired public void setDataSource(DataSource dataSource) { this.jdbcTemplate = new JdbcTemplate(dataSource); } public UserInfo getUserInfo(String username){ String sql = \"SELECT u.username name, u.password pass,\"+ a.authority role FROM \"+ \"users u INNER JOIN authorities a\" + on u.username=a.username WHERE \"+ \"u.enabled =1 and u.username = ?\"; UserInfo userInfo = (UserInfo)jdbcTemplate.queryForObject(sql, new Object{username}, new RowMapper<UserInfo>() { public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException { UserInfo user = new UserInfo(); user.setUsername(rs.getString(\"name\")); user.setPassword(rs.getString(\"pass\")); 341 Chapter 7 ■ Spring Web FloW user.setRole(rs.getString(\"role\")); return user; } }); return userInfo; } } //UserInfo.java public class UserInfo { private String username; private String password; private String role; //setter and getters for fields } No web.xml Configuration As the official documentation says, if Spring Security is used with Spring MVC, you need an extra empty class that extends org.springframework.security.web.context. AbstractSecurityWebApplicationInitializer, a class provided by Spring Security that ensures that the springSecurityFilterChain gets registered. Also, you need to include the Spring Security XML configuration file in the Java Configuration, as depicted in the following code sample: import org.springframework.security.web.context. AbstractSecurityWebApplicationInitializer; // Empty class needed to register the springSecurityFilterChain bean public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { } public class WebInitializer extends AbstractDispatcherServletInitializer { @Override protected WebApplicationContext createRootApplicationContext() { XmlWebApplicationContext ctx = new XmlWebApplicationContext(); ctx.setConfigLocation(\"/WEB-INF/spring/security-config.xml\"); return ctx; } @Override protected WebApplicationContext createServletApplicationContext() { XmlWebApplicationContext ctx = new XmlWebApplicationContext(); ctx.setConfigLocations(\"/WEB-INF/spring/mvc-config.xml\", \"/WEB-INF/spring/app-config.xml\", \"/WEB-INF/spring/webflow-config.xml\"); return ctx; } ... } But as Java Configuration and web initializer classes were introduced to simplify configuration and get rid of all XML, all the preceding configurations will soon be deprecated. 342 Chapter 7 ■ Spring Web FloW Spring Security Java Configuration The XML configuration style is close to its death, as Java Configuration gains popularity. So it was expected that Spring Security adapt, and they did. The Java Configuration is super-simple and intuitive. When working with Spring MVC and Spring Security to develop a working security configuration, you need to do the following: 1. Create an empty class extending AbstractSecurityWebApplicationInitializer to get the springSecurityFilterChain registered (as mentioned at the end of the previous section). 2. Create a security configuration class that extends WebSecurityConfigurerAdapter so that the developer can write the minimum amount of code for a valid security configuration. The security configuration class equivalent to the XML configuration presented in the previous section is depicted in following code snippet: package com.pr.config; ... import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation .authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation .web.builders.HttpSecurity; import org.springframework.security.config.annotation .web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation .web.configuration.WebSecurityConfigurerAdapter; @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) { try { auth.inMemoryAuthentication() .withUser(\"john\").password(\"doe\").roles(\"USER\").and() .withUser(\"jane\").password(\"doe\").roles(\"USER,ADMIN\").and() .withUser(\"admin\").password(\"admin\").roles(\"ADMIN\"); } catch (Exception e) { e.printStackTrace(); } } @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/resources/**\",\"/images/**\",\"/styles/**\") .permitAll() 343 Chapter 7 ■ Spring Web FloW .antMatchers(\"/persons/newPerson\").hasRole(\"ADMIN\") .antMatchers(\"/**\").hasAnyRole(\"ADMIN\",\"USER\") .anyRequest() .authenticated() .and() .formLogin() .usernameParameter(\"username\") // customizable .passwordParameter(\"password\") // customizable .loginProcessingUrl(\"/login\") // customizable .loginPage(\"/auth\") .failureUrl(\"/auth?auth_error=1\") .defaultSuccessUrl(\"/home\") .permitAll() .and() .logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/\") .and() .csrf().disable(); } } To enable CSRF usage, the preceding configuration must also define a CSRF provider bean and use it in the configuration: ... import org.springframework.security.web.csrf.CsrfTokenRepository; import org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository; @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public CsrfTokenRepository repo() { HttpSessionCsrfTokenRepository repo = new HttpSessionCsrfTokenRepository(); repo.setParameterName(\"_csrf\"); repo.setHeaderName(\"X-CSRF-TOKEN\"); return repo; } @Override protected void configure(HttpSecurity http) throws Exception { http. ... .and() .csrf().csrfTokenRepository(repo()); } } 344 Chapter 7 ■ Spring Web FloW No web.xml Configuration Add the Security configuration class to the root context in the class taking care of loading all the MVC environment components: package com.pr.config; ... import com.pr.config.MvcConfig; import com.pr.config.SecurityConfig; import com.pr.config.WebFlowConfig; import org.springframework.web.filter.CharacterEncodingFilter; import org.springframework.web.filter.HiddenHttpMethodFilter; import org.springframework.web.servlet .support.AbstractAnnotationConfigDispatcherServletInitializer; import javax.servlet.Filter; public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?> getRootConfigClasses() { return new Class<?>{ SecurityConfig.class }; } @Override protected Class<?> getServletConfigClasses() { return new Class<?>{ MvcConfig.class, WebFlowConfig.class }; } ... } ■ ! the SecurityConfig.class (and the Spring Security XMl config file) were added to the root context because they define beans that can be used by other servlets and services in the same application. the getServletConfigClasses() is used only to instantiate the servlet-related beans. 345 Chapter 7 ■ Spring Web FloW Spring Security Tag Library Security tags can be used in JSP directly to secure elements in the page and prevent their rendering if the authenticated user is not allowed to see them. To use them, the Spring Security Tag library must be declared in the JSP page: <%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %> In the examples attached to this chapter, two elements were secured in JSP:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The logout link must be visible only when a user is authenticated; the following is\nthe syntax to do this:\n<!-- layout.jsp, tiles main template file -->\n<sec:authorize access=\"isAuthenticated()\">\n<li>\n<!-- we are using Security for with CSRF enabled -->\n<spring:url value=\"/logout\" var=\"logoutUrl\" />\n<form action=\"${logoutUrl}\" id=\"logout\" method=\"post\">\n<input type=\"hidden\" name=\"${_csrf.parameterName}\"\nvalue=\"${_csrf.token}\"/>\n</form>\n<a href=\"#\" onclick=\"document.getElementById('logout').submit();\">\n<spring:message code=\"menu.logout\"/>\n</a>\n</li>\n</sec:authorize>\nSo basically, the same expressions used when configuring Spring Security are\nused for the access attribute.\n• The NewPerson link must be visible only to users with the ADMIN role:\n<!-- templates/layout.jsp -->\n<sec:authorize access=\"hasRole('ADMIN')\">\n<li>\n<!--menuTab is a tiles attribute -->\n<c:if test=\"${menuTab eq 'newPerson'}\">\n<strong>\n<a href=\"<c:url value=\"/persons/newPerson\"/>\">\n<spring:message code=\"menu.new.person\"/>\n</a>\n</strong>\n</c:if>\n<c:if test=\"${menuTab != 'newPersons'}\">\n<a href=\"<c:url value=\"/persons/newPerson\"/>\">\n<spring:message code=\"menu.new.person\"/>\n</a>\n</c:if>\n</li>\n</sec:authorize>\n346\nChapter 7 ■ Spring Web FloW\nAnd another tag was used to display information about the user being logged in:\n<!-- layout.jsp, tiles main template file -->\n<div class=\"footer\">\n<sec:authorize access=\"isAuthenticated()\">\n<p><spring:message code=\"user.loggedin\"/>:\n<sec:authentication property=\"principal.username\"/>\n</p>\n</sec:authorize>\n<p><spring:message code=\"footer.text\"/></p>\n</div>\nUsing the Spring Tag library and intercept-url definitions, access to resources can be centralized in\nthe Spring Security configuration file or class, because the access attribute can be replaced with the url\nattribute that is set with URLs that are intercepted by Spring Security.\n<!-- layout.jsp, tiles main template file -->\n<sec:authorize access=\"hasRole('ADMIN')\">\n//New Person link\n</sec:authorize>\n// can be written as\n<sec:authorize url=\"/persons/newPerson\">\n//New Person link\n</sec:authorize>\nSecuring Methods\nSpring Security uses AOP to secure method calls. The Spring Security namespace can be used to configure\nmethod security using XML. But the most commonly used and easy-to-understand way to secure methods\nis through annotations. Spring Security provides its own annotations, but JSR-250 annotations are supported\ntoo. Samples for all ways of securing methods are covered.\nAssuming you want to secure all action methods involved in the newPerson flow, this is how it is done\nusing XML:\n<!-- security-config.xml -->\n<security:global-method-security>\n<security:protect-pointcut\nexpression=\"execution(* com.pr..*Actions.*(..))?",
    "answer": "access=\"hasRole('ROLE_ADMIN')\" /> </security:global-method-security> Of course, method security must be enabled, which can be done by adding the following element in the security configuration file: <!-- security-config.xml --> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" 347 Chapter 7 ■ Spring Web FloW xsi:schemaLocation=\"http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <global-method-security secured-annotations=\"enabled\" /> .. </beans:beans> Securing an action method using annotations can be done using the @Secured Spring annotation, which is activated when the global-method-security element is present in the configuration. //AccountActions.java ... import org.springframework.security.access.annotation.Secured; @WebFlowAction public class AccountActions extends MultiAction { @Secured(\"ROLE_ADMIN\") public Event saveAccount(RequestContext context) { ... } } The equivalent of the global-method-security XML configuration is @EnableGlobalMethodSecurity( securedEnabled = true) , which can be placed on any configuration class annotated with @Configuration: //SpringConfig.java ... import org.springframework.security.config.annotation. method.configuration.EnableGlobalMethodSecurity; @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... } To enable JSR-250 annotations, and especially the @RolesAllowed annotation (that is an equivalent for Spring @Secured), the following configurations must be made: <!-- security-config.xml --> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/security 348 Chapter 7 ■ Spring Web FloW http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <global-method-security jsr250-annotations=\"enabled\" /> .. </beans:beans> //SpringConfig.java ... import org.springframework.security.config.annotation. method.configuration.EnableGlobalMethodSecurity; @Configuration @EnableGlobalMethodSecurity(jsr250Enabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... } Usage of @RolesAllowed is the same as @Secure, so the preceding code would become this: //AccountActions.java ... import javax.annotation.security.RolesAllowed; @WebFlowAction public class AccountActions extends MultiAction { @RolesAllowed(\"ROLE_ADMIN\") public Event saveAccount(RequestContext context) { ... } } Spring Security also provides the @PreAuthorize annotation, which is used to set an expression that is evaluated to decide if the method is invoked or not. (Basically, the equivalent of the <intercept /> XML configuration element.) Being a Spring Security annotation, it supports SpEL. This annotation can be used if it has been enabled using the @EnableGlobalMethodSecurity annotation. The code snippet depicts the configuration and usage for this specific case: //SpringConfig.java ... import org.springframework.security.config.annotation. method.configuration.EnableGlobalMethodSecurity; @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... 349 Chapter 7 ■ Spring Web FloW //AccountActions.java ... import org.springframework.security.access.prepost.PreAuthorize; @WebFlowAction public class AccountActions extends MultiAction { @PreAuthorize(\"hasAuthority('ROLE_ADMIN')\") public Event saveAccount(RequestContext context) { ... } } Securing Flow Definitions Any component of a flow definition—states, subflows, transitions—can be considered resources and thus secured. So far, we have secured the web-flow link by using a <sec:authorize /> element in the templates/ layout.jsp tiles template and setting up authentication and authorization. But flow components can be secured using a org.springframework.webflow.security.SecurityFlowExecutionListener and by adding <secured> elements in the flow definition. Considering that authentication and authorization rules have been set up as described earlier, the next step is to configure a SecurityFlowExecutionListener. This can be done using XML configuration by adding the bean definition in the configuration file setting up the web flow environment, webflow-config.xml. <!--webflow-config.xml--> <flow ...> <!-- Executes web flows --> <webflow:flow-executor id=\"flowExecutor\" > <webflow:flow-execution-listeners> <webflow:listener ref=\"auditExecutionListener\"/> <webflow:listener ref=\"securityFlowExecutionListener\"/> </webflow:flow-execution-listeners> </webflow:flow-executor> <bean id=\"auditExecutionListener\" class=\"com.pr.audit.AuditFlowExecutorListener\"/> <bean id=\"securityFlowExecutionListener\" class=\"org.springframework.webflow.security.SecurityFlowExecutionListener\"/> ... // other flow infrastrucure beans </flow> ■ ! the AuditFlowExecutorListener bean is a developer helper bean: that is it prints information when a web flow event is triggered, when states are entered, and when exceptions are thrown. the class is present in the sample project for this chapter, but its code is not relevant for this topic. 350 Chapter 7 ■ Spring Web FloW This bean can be configured using Java Configuration by declaring it in the web flows configuration class: //WebFlowConfig.java ... import org.springframework.webflow.security.SecurityFlowExecutionListener; @Configuration public class WebFlowConfig extends AbstractFlowConfiguration { @Bean public SecurityFlowExecutionListener securityFlowExecutionListener(){ return new SecurityFlowExecutionListener(); } @Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()) .addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\") .addFlowExecutionListener(securityFlowExecutionListener()) .setMaxFlowExecutions(5) .setMaxFlowExecutionSnapshots(30) .build(); } ... } Declaring this bean and setting it up as a flow execution listener ensures that any <secured /> elements in the flow definition are picked up and interpreted accordingly at flow execution time. This bean can define its own decision manager, which overrides the default AccessDecisionManager in the system, by setting up the desired bean reference to the accessDecisionManager property. <!--webflow-config.xml--> <bean id=\"securityFlowExecutionListener\" class= \"org.springframework.webflow.security.SecurityFlowExecutionListener\"> <property name=\"accessDecisionManager\" ref=\"customDecisionManager\" /> </bean> //WebFlowConfig.java org.springframework.security.access.vote.UnanimousBased; ... @Bean public SecurityFlowExecutionListener securityFlowExecutionListener(){ SecurityFlowExecutionListener sfel = new SecurityFlowExecutionListener(); sfel.setAccessDecisionManager(customDecisionManager()); return sfel; } @Bean AccessDecisionManager customDecisionManager(){ //assume List<AccessDecisionVoter<? extends Object>> voterList is initialized return new UnanimousBased(voterList); } 351 Chapter 7 ■ Spring Web FloW The UnanimousBased is a simple concrete implementation of the AccessDecisionManager provided by Spring Security; it requires all voters to abstain or grant access. The SecurityFlowExecutionListener bean throws AccessDeniedException when the user is not authorized to access a flow resource. The exception is caught by Spring Security servlet filter. Catching or suppressing this exception is not recommended. When extending SimpleMappingExceptionResolver, doResolveException should be implemented so that this exception is rethrown. import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver; public class CustomExceptionResolver extends SimpleMappingExceptionResolver { @Override protected ModelAndView doResolveException (HttpServletRequest req, HttpServletResponse res, Object handler, Exception ex) { return super.doResolveException(req, res, handler, ex); } } The following example depicts the specific points where the secured element can appear in a flow definition: <!--webflow-config.xml--> <!-- 1. Under the flow element, securing the whole flow definition --> <flow ...> <secured attributes=\"ROLE_ADMIN\" /> </flow> <!-- 2. Securing a view-state --> <flow ...> <view-state id=\"enterPersonInfo\" model=\"person\"> <secured attributes=\"ROLE_ADMIN\" /> </view-state> </flow> <!-- or a decision state --> <decision-state id=\"isNewPerson\"> <secured attributes=\"IS_AUTHENTICATED_FULLY\"/> <if test=\"personService.isNewPerson(person)\" then=\"enterIdentityCardInfo\" else=\"reviewExistingPerson\"/> </decision-state> 352 Chapter 7 ■ Spring Web FloW <!-- 3. Securing a transition --> <flow ...> <view-state id=\"enterPersonInfo\" model=\"person\"> ... <transition on=\"next\" to=\"isNewPerson\" > <secured attributes=\"ROLE_ADMIN\" /> </transition> </view-state> </flow> The attributes attribute is a comma-separated list of Spring Security authorization attributes. Often, these are specific security roles. But, when using a custom access decision manager, the syntax can vary; for example, SpEL can be used when the custom access manager is a Spring bean that supports them. Spring Security is a wide subject; if you intend to use it in your projects, there is a lot of good documentation available online. Often, complete code samples are provided to help the curious developer understand how it works and how to use it. And, of course, the starting point is the Spring Security Reference at http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/. All that is covered in this book should suffice in helping a developer understand the basic concepts that might be in the certification exam. Spring Security with OAuth OAuth15 is an open standard for authorization. It is an open protocol to allow secure authorization in a simple and standard method for web, mobile, and desktop applications. It is designed to work with HTTP and basically allows access tokens to be generated by a server, which can then be used by the client to access resources on another server. It’s like there is an authentication provider that guarantees that you are who you say you are (it vouches for you) to a different service provider. When talking about OAuth2 (because it is the most commonly used at the moment), the following components need to be mentioned:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "It requires a mandatory FlowBuilderServices bean as an argument so it can be\ninstantiated.\n• It is a container of flow definitions.\nQuestion 6: What can you say about the following code snippet?",
    "answer": "<button id=\"newPersonButton\" name=\"_eventId_proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button>",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "two\n• three\n• none, because it uses session\nQuestion 8: What can be said about the following web flow configuration class?",
    "answer": "@Configuration public class WebFlowConfig { ... }",
    "source": "extracted",
    "confidence": 0.49
  },
  {
    "question": "Each view state has a corresponding view.\n• Decisions states are more complex view states.\n360\nChapter 7 ■ Spring Web FloW\nQuestion 15: Consider the following flow definition:\n<view-state id=\"enterIdentityCardInfo\" model=\"identityCard\">\n<binder>\n...\n</binder>\n<transition on=\"save\" to=\"confirmAdult\">\n<evaluate expression=\"personBuilder.savePersonEntity(person, identityCard)\"\nresult=\"flowScope.existingPerson\" />\n</transition>\n</view-state>\nWhich of the following is true?",
    "answer": "enterIdentityCardInfo in this case.",
    "source": "extracted",
    "confidence": 0.35
  },
  {
    "question": "on state entry\n• on view render\n• on transition execution\n• during transition execution\n• on state exit\n• on flow end\n• after flow end\nQuestion 26: Which of the following Spring expressions are valid?",
    "answer": "sessionMap.mostUsed)\"result=\"viewScope.hospitals\" />",
    "source": "extracted",
    "confidence": 0.52
  },
  {
    "question": "Boolean, always just “yes” or “no”\n• Any value that evaluates to “success”\n• Any String that can be matched to a trigger event name\n363\nChapter 7 ■ Spring Web FloW\nQuestion 28: Select the way in which a developer can define an action.\n• Extend the Action class\n• Extend the MultiAction class\n• Add call business methods directly in the web flow definition\nQuestion 29: What can be said about authentication and authorization?",
    "answer": "changes in the authorization configuration as well.",
    "source": "extracted",
    "confidence": 0.51
  },
  {
    "question": "They are fully decoupled; changing configuration for authentication will not affect\nauthorization.\n• They are both synonyms for application security.\nQuestion 30: What is needed to configure Spring Security with Spring MVC using Java Configuration?",
    "answer": "a class annotated with @Configuration.",
    "source": "extracted",
    "confidence": 0.38
  },
  {
    "question": "Create a class that extends AbstractSecurityWebApplicationInitializer to\nregister the springSecurityFilterChain.\n• Create a configuration class that extends WebSecurityConfigurerAdapter that is\nannotated with EnableWebSecurity.\n• Add the Security configuration class to the root context.\nPractical Exercise\nThe practical exercise for this chapter involves configuring Spring Security. The project you have to complete\nis named 14-pr-web-security-practice. The project contains a view named login.jsp, which is a custom\nlogin form designed to work with Spring Security 4. There are a few TODO tasks that you must be able to\ncomplete if you have been paying enough attention when reading the Security section.\nThe first one, (TODO 47) requests you to add a new filter of type org.springframework.web.filter.\nDelegatingFilterProxy with the filter name springSecurityFilterChain. The class that will do this is\nalready in place and is called com.pr.init.SecurityWebApplicationInitializer; you just have to modify\nit to register the filter. Afterward, you can start the application using the appStart Gradle task for this\nsubmodule project; for reference, see Figure 7-28.\n364\nChapter 7 ■ Spring Web FloW\nFigure 7-28. Reference for subproject\nYou are not done yet, though. When starting the application, you see in the console that there was some\ntrouble creating your security context and your login page is not visible. This is what you should see in the\nconsole:\n00:35:40 WARN Failed startup of context o.a.g.JettyWebAppContext@2da59753\n{/security,file:\n/.../personal-records/14-pr-web-security-practice/build/inplaceWebapp/,STARTING}\n...\nCaused by: java.lang.IllegalArgumentException: An AuthenticationManager is required\nat org.springframework.util.Assert.notNull(Assert.java:115) ~na:na\n...\nIf you remember, the security section well, you already suspect what is missing. The previous task just\ndefines the filter. Now you need to create a Spring Security configuration class to provide your users their\nroles and overall details such as the location of the login form, if a CSRF token is used. All this is marked\nas TODO 48. A part of the class is already set up for you, providing the bean that generates a CSRF token.\nYou can find the partial implementation in com.pr.config.SecurityConfig. The comments in the TODO\ntask instruct you on what is further needed. After all the configuration is in place, you can try to start the\napplication again. And unfortunately, it won’t start. This is what you see if you try to open\nhttp://localhost:8080/security/.\nHTTP ERROR 500\nProblem accessing /security/auth. Reason:\nServer Error\nCaused by:\norg.springframework.web.util.NestedServletException:\nRequest processing failed; nested exception is java.lang.IllegalStateException:\nNo WebApplicationContext found: no ContextLoaderListener registered?",
    "answer": "365 Chapter 7 ■ Spring Web FloW This is because there is still one little detail to take care of: adding the SecurityConfig class to the root context of the application. To do this, go to com.pr.init.WebInitializer and complete the getRootConfigClasses method body (TODO 49). After restarting the application, you should see something really similar to Figure 7-29. Figure 7-29. The login form displayed when Spring Security is properly configured If the previous task is resolved correctly, the login form should be visible. But wait, the New Person menu option is visible. You want only users with the ADMIN role to see that menu item. Something is clearly missing. So go to 14-pr-web-security-practice/src/main/webapp/WEB-INF/templates/layout.jsp and secure that menu item. Do not forget to reference the proper taglib! After solving the last TODO item, the New Person menu item should not be visible on the main page when a user is not logged in. Log in using john. If you see the New Person link, something is wrong in the configuration of the HttpSecurity, because john has a USER role, and only users with an ADMIN role can view and access that menu item. Log in with jane or admin. If you see that option, then your configuration is correct and you have completed this lab. As a bonus exercise, try playing with the security tag library and use the URL to configure access. Or remove the tag altogether and secure the flow. The proposed solution can be found in subproject 14-pr-web-security-solution. Try not to look before developing your own solution, and use it only for comparison. 366 Chapter 8 Spring Boot and WebSocket Although they are not yet part of the certification exam, Spring Boot and Spring WebSocket are included in this book because of the potential that these two projects have in the future development of Spring Web applications. What Is Spring Boot? Spring Boot is a promising Spring project that makes it really easy for developers to create Spring-powered, production-grade applications and services. It makes configuration less of a hassle, offering complete, but easy-to-use defaults bits and pieces that you can stack up together like LEGO bricks. (Yes, the LEGO analogy again.) Spring Boot can be used to create stand-alone Java applications or web applications and its primary goals are to do the following:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Provide a faster, practical, and more accessible way to start development with Spring\n• Provide a default set of customized infrastructure beans, which can be easily\noverridden if a specific configuration is required\n• Provide a large set of features common to large classes of projects (embedded\nservers, security, metrics, etc.)\n• Offer the option of dropping any XML configuration or the necessity of generating code\nWhen developing web applications, a container is necessary. Usually, an application server or a web\nserver is necessary to run a web application.\nA web server like Apache HTTP, for example, is dedicated to sending HTML to the client and forwarding\nrequests to application servers. It handles only static resources.\nAn application server, like Apache Tomcat is built around a web server and is dedicated to the efficient\nexecution of program and routines; it supports different types of applications, load balancing, transaction\ndemarcation, and so forth; and it is specifically designed to handle dynamic resources.\nApache TomEE is a full-blown Java EE container and an application server based on Apache Tomcat.\nThis type of application server is also called an enterprise server because it is designed to support complex\napplications like ERPs.1\n1Enterprise resource planning (ERP) is business-management software. It is typically a suite of integrated applications\n(see https://en.wikipedia.org/wiki/Enterprise_resource_planning).\n367\nChapter 8 ■ Spring Boot and WeBSoCket\nThe Jetty server was used in the examples in this book. Jetty is an embedded server. Application/web\nservers are separate applications that you install, start up, maybe customize the configuration, and deploy\nyour artifact on. An embedded server does not need all that. An embedded HTTP server is software that\nimplements the HTTP protocol; it can be embedded into the application that you are developing. It is limited\nto handling HTTP requests and can be plugged in with the default configuration, or it can be customized.\nUp until now, the Jetty embedded server was plugged in at runtime by using the Gradle Gretty plugin. Using\nSpring Boot, this is no longer needed. All that is needed is to configure the spring-boot-starter-jetty as a\ncompile-time dependency for the application.\nUsage and Configuration\nA simple sample for this case is the 08-chapter-01-solution project, a module of book-code. If you open\nthe project, you will notice the following:\n• A new version element was added in the ext element of the Gradle configuration of\nthe build.gradle file (the book-code parent project):\nspringBootVersion = '1.2.7.RELEASE'\n• In the same file, a new dependencies array named boot was added:\nboot = [\nspringBootPlugin: \"org.springframework.boot:spring-boot-gradle-plugin:\n$springBootVersion\",\nstarterWeb : \"org.springframework.boot:spring-boot-starter-web:\n$springBootVersion\",\nstarterJetty : \"org.springframework.boot:spring-boot-starter-jetty:\n$springBootVersion\",\nactuator : \"org.springframework.boot:spring-boot-starter-actuator:\n$springBootVersion\",\nyaml : \"org.yaml:snakeyaml:1.16\"\n]\n• The Gradle configuration file for 08-chapter-01-solution has the following contents:\napply plugin: 'spring-boot'\nbuildscript {\nrepositories {\nmavenCentral()\n}\ndependencies {\nclasspath boot.springBootPlugin\n}\n}\ndependencies {\ncompile (boot.starterWeb){\n(*)exclude module : \"spring-boot-starter-tomcat\"\n}\ncompile boot.starterJetty, boot.actuator, boot.yaml\ntestCompile misc.junit\n}\n368\nChapter 8 ■ Spring Boot and WeBSoCket\nAnd this is all. The Gradle Gretty plugin, was replaced by the Spring-Boot plugin that is needed for\nrunning Spring Boot applications. The default web runtime that Spring Boot uses (Tomcat) was excluded,\nand spring-boot-starter-jetty was added as a dependency using the variable assigned to the\nboot.starterJetty library. This is enough to develop and run a simple web application.\n■ ! the spring-boot-starter-actuator added using the boot.actuator variable is not really necessary in the\nexamples for the book, but you need to know that this library exists. it should be used when you want to add\nproduction-ready features like metrics and monitoring to your application. also, if you look in the log after the\napplication starts, you will see a few lines that look like this:\nMapped \"{[/]}\" onto public java.lang.String com.book.web.\nHelloWorldController.index()\nMapped \"{[/error],produces=[text/html]}\" onto public o.s.web.servlet.\nModelAndView\nMapped \"{[/beans],methods=[GET]}\" onto public java.lang.Object\nMapped \"{[/trace],methods=[GET]}\" onto public java.lang.Object\nMapped \"{[/metrics/{name:.*}],methods=[GET]}\" onto public java.lang.Object\no.s.boot.actuate.endpoint.mvc.MetricsMvcEndpoint.value(java.lang.String)\napped \"{[/health]}\" onto public java.lang.Object\no.s.boot.actuate.endpoint.mvc.HealthMvcEndpoin\nt.invoke(java.security.Principal)\nthese are a set of reStful endpoints added to the application to provide access to management services\nprovided by Spring Boot. try accessing http://localhost:8080/metrics or http://localhost:8080/health\nafter the application starts with the default configuration (otherwise, the port and the contextPath might be\ndifferent) and check out the data returned to you by Spring Boot.\nthe YaML dependency is covered later.\nThe core class of this application is the com.book.Application class:\n[commandchars=+\npackage com.book;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\n@SpringBootApplication\npublic class Application {\npublic static void main(String args) {\nApplicationContext ctx = SpringApplication.run(Application.class, args);\nassert(ctx!=null);\n}\n}\n369\nChapter 8 ■ Spring Boot and WeBSoCket\nIf you run this class, you get a web application run on Jetty that is available at http://localhost:8080/.\nThe most important element in this class is the @SpringBootApplication annotation. Spring Boot code is\navailable to the public, and if you look for the annotation code on GitHub, this is what you will find:\npackage org.springframework.boot.autoconfigure;\n...// import statements\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic @interface SpringBootApplication {\n/**\n* Exclude specific auto-configuration classes\nsuch that they will never be applied.\n* @return the classes to exclude\n*/\nClass<?",
    "answer": "> exclude() default {}; } When placed on a class, this annotation has the following effect:",
    "source": "extracted",
    "confidence": 0.91
  },
  {
    "question": "It indicates that this a configuration class that can be used to instantiate beans via\n@Bean annotated methods (because this annotation is itself annotated with\n@Configuration).\n• It triggers component scanning on the package in which the class is defined\n(because of the @ComponentScan annotation).\n• It automatically adds @EnableWebMvc when spring-webmvc is in the classpath. This\nis ensured by the spring-boot-starter-web being a dependency of this project.\nThis marks the application as a web application, so Spring Boot knows to set up a\nDispatcherServlet.\n• The @EnableAutoConfiguration annotation does exactly what the name of the\nannotation says: it enables the autoconfiguration of a Spring context. So Spring Boot\nwraps up a configuration by basically guessing which beans are necessary, given the\nlittle configuration there is. Autoconfiguration is quite intelligent and if some custom\nconfiguration is provided, the provided beans override the default ones that Spring\nBoot comes with.\nThe scope of this annotation is enriched, starting with Spring Boot 1.3.0, which wasn’t yet released\nwhen this book was written, but the code is available on GitHub.2\nThe preceding main method uses the SpringApplication.run convenient method to launch an\napplication. Thus, no XML was needed anywhere to create this web application. This method returns the\ncreated ApplicationContext instance. The created context is autowired into the HelloWorldController,\n2View the code at https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/\nsrc/main/java/org/springframework/boot/autoconfigure/SpringBootApplication.java\n370\nChapter 8 ■ Spring Boot and WeBSoCket\nwhich is a simple REST controller used to display all the beans in the context. In the spirit of keeping things\nsimple, a complex configuration involving a view resolver was avoided, because the scope of this module is\nto show the power of Spring Boot and what exactly it does in the background. The autowired context is used\nto create an HTML string that is rendered when accessing http://localhost:8080/ and shows the name of\nall the beans created by Spring Boot or defined in the application; thus, you can analyze what Spring Boot is\ndoing in the background. The simple controller looks like this:\n@RestController\npublic class HelloWorldController {\n@Autowired\nApplicationContext ctx;\n@RequestMapping(\"/\")\npublic String index() {\nStringBuilder sb = new StringBuilder(\"<html><body>\");\nsb.append(\"Hello there dear developer,\nhere are the beans you were looking for: </br>\");\nString beanNames = ctx.getBeanDefinitionNames();\nArrays.sort(beanNames);\nfor (String beanName : beanNames) {\nsb.append(\"</br>\").append(beanName);\n}\nsb.append(\"</body></htm>\");\nreturn sb.toString();\n}\n}\nThis is roughly what you see in the browser:\nHello there dear developer, here are the beans you were looking for:\nactuatorMetricRepository\napplication\napplicationContextIdFilter\nauditEventRepository\nauditListener\nautoConfigurationAuditEndpoint\nbasicErrorController\nbeanNameHandlerMapping\nbeanNameViewResolver\nbeansEndpoint\ncharacterEncodingFilter\nconfigurationPropertiesReportEndpoint\ncounterService\n...\nhealthEndpoint\nhealthMvcEndpoint\nhelloWorldController\n...\n371\nChapter 8 ■ Spring Boot and WeBSoCket\nOf course, the list is incomplete here—just a small snippet is depicted. You have to run the application\nyourself to see the complete list.\n■ ! and you can view the same list of beans in JSon format if you access the actuator service available at\nhttp://localhost:8080/beans.\nAlso, if you want to know where the implementation for these beans comes from, just look at the\ndependencies for your project in Gradle view in Intellij IDEA. You should see something similar to what is\ndepicted in Figure 8-1, but the list will be way bigger.\nFigure 8-1. Transitive dependencies added by Spring Boot to a web application project\nSo far, only the default configuration inferred by Spring Boot has been presented. This application is\nroughly similar to the one in the official tutorial at https://spring.io/guides/gs/spring-boot/; but in this\nbook, things are spiced up a little.\n372\nChapter 8 ■ Spring Boot and WeBSoCket\nCustomizing Spring Boot\nThere are a few ways that Spring Boot configuration can be externalized”\n• use properties files\n• use YAML files\n• use environment variables\n• use command-line variables (when a Spring Boot command-line interface is\ninstalled)\nIn the previous example, the controller and the configuration class were in the same package, and by\ndefault, the configuration class annotated with SpringBootApplication scans only the current package and\nits subpackages. This can be changed by annotating the same class with @ComponentScan and specifying\ndifferent package groups.\nIn the 08-chapter-02-solution module, the Application was moved to the com.book.init package,\nand HelloWorldController was moved to com.book.web, as depicted in Figure 8-2.\nFigure 8-2. Spring Boot with beans and configuration in different packages\nThe new configuration class code looks like this:\npackage com.book.init;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n373\nChapter 8 ■ Spring Boot and WeBSoCket\n@SpringBootApplication\n@ComponentScan(basePackages = {\"com.book.*\"})\n//or @ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"})\npublic class Application {\npublic static void main(String args) {\nSpringApplication.run(Application.class, args);\n}\n}\nBut what if you want the application to be available on a different port and in a different context path?",
    "answer": "There are a few ways to do this. The simplest way is to create a customized bean class that implements the org.springframework. boot.context.embedded.EmbeddedServletContainerCustomizer interface and provides a concrete implementation for the customize method: package com.book.init; import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer; import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer; import org.springframework.stereotype.Component; /** * Created by iuliana.cosmina on 9/23/15. */ @Component public class CustomizationBean implements EmbeddedServletContainerCustomizer { @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); container.setContextPath(\"/boot\"); } } By adding this bean to the configuration, the application can now be accessed at http://localhost:8083/boot. Another way to do this is by using a customized factory bean for JettyEmbeddedServletContainerFactory. Aside from port and contextPath, some settings for the optimization of the embedded Jetty server used to run the application can be provided. The @Bean annotated method that declares this bean can be added to any configuration class that is taken into consideration by Spring Boot. package com.book.init; import org.eclipse.jetty.server.Server; import org.eclipse.jetty.util.thread.QueuedThreadPool; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.embedded.jetty. JettyEmbeddedServletContainerFactory; import org.springframework.boot.context.embedded.jetty. JettyServerCustomizer; 374 Chapter 8 ■ Spring Boot and WeBSoCket import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Created by iuliana.cosmina on 9/27/15. */ @Configuration public class JettyFactoryConfig { @Bean public JettyEmbeddedServletContainerFactory jettyServletContainerFactory(@Value(\"${server.port:8085}\") final String port, @Value(\"${jetty.threadPool.maxThreads:200}\") final String maxThreads, @Value(\"${jetty.threadPool.minThreads:8}\") final String minThreads, @Value(\"${jetty.threadPool.idleTimeout:60000}\") final String idleTimeout) { final JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory(Integer.valueOf(port)); factory.setContextPath(\"/boot\"); factory.addServerCustomizers(new JettyServerCustomizer() { @Override public void customize(final Server server) { // Customize the connection pool used by Jetty to handle //incoming HTTP connections final QueuedThreadPool threadPool = server.getBean(QueuedThreadPool.class); threadPool.setMaxThreads(Integer.valueOf(maxThreads)); threadPool.setMinThreads(Integer.valueOf(minThreads)); threadPool.setIdleTimeout(Integer.valueOf(idleTimeout)); } }); return factory; } } By adding this bean to the configuration, the application can now be accessed at http://localhost:8085/boot. Values for the customizations can be provided, directly as done before, but they also can be provided using properties files or YAML files. In order to provide the configuration via a properties file, a file named application.properties has to be created and applied to the application from the outside, or it can be packaged in the jar. If multiple profiles are used, multiple files can be added. Their naming matches the application-{profile}.properties template. SpringApplication looks for an application.properties file in the following locations, and adds them to the Spring environment:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "a /config directory under the current directory\n• the current directory\n• a classpath /config package\n• the classpath root\n375\nChapter 8 ■ Spring Boot and WeBSoCket\nBeing a resource file, application.properties must be located during development under\nsrc/main/resources.\nThe preceding list is ordered by precedence, so Spring Boot looks for property files by traversing the list\nfrom top to bottom. The first properties file found is taken into consideration, and it does not matter if the\nsubsequent locations have a properties file defined.\nThe default name of the properties file is application.properties. Spring Boot looks for it, unless it\nwas changed by setting the environment variable named spring.config.name.\nThe location of the file can also be provided as the value for the environment variable named\nspring.config.location.\nSo if the 08-chapter-02-solution application is packaged into a runnable jar called boot.jar, the\napplication could be run from the command line with the following arguments:\n#Spring Boot will search in the classpath for a file named boot.properties\n$ java -jar boot.jar --spring.config.name=boot\n#Spring Boot will read the properties the specified file\n$ java -jar boot.jar --spring.config.location=/Users/myuser/config/default.properties\nIn the preceding example, the file is saved under book-code/08-chapter-02-solution/src/main/\nresources and has the following contents:\n#application.properties\napp.port=8084\napp.context=/boot\nThese property values are injected using the @Value annotation into a customization bean that is picked\nup and used by Spring Boot. The application is then accessed at http://localhost:8084/boot.\npackage com.book.init;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n@Component\npublic class PropertiesConfBean implements EmbeddedServletContainerCustomizer {\n@Value(\"${app.port}\")\nprivate Integer value;\n@Value(\"${app.context}\")\nprivate String contextPath;\n@Override\npublic void customize(ConfigurableEmbeddedServletContainer container) {\ncontainer.setPort(value);\ncontainer.setContextPath(contextPath);\n}\n}\n376\nChapter 8 ■ Spring Boot and WeBSoCket\nThe EmbeddedServletContainerCustomizer interface is used for customizing autoconfigured\nembedded servlet containers. Any beans of this type are instantiated and used to initialize the configuration\nof the embedded server before the container itself is started.\nWithout an EmbeddedServletContainerCustomizer bean, the contents of application.properties\nlook different, because they must match the standard property names3 that Spring Boot looks for, as follows:\n#application.properties\nserver.port=8084\nserver.context-path=/boot\nWhen the snakeyaml library is in the classpath, YAML files can be used instead of properties files.\nYAML is a well-known format within the Ruby community. It is a superset of JSON, and as such, it is\na very convenient format for specifying hierarchical configuration data. In the previous example, if\nthe application.properties file is replaced by application.yml, with the following contents, the\nbehavior will be exactly the same, because the internal org.springframework.beans.factory.config.\nYamlPropertiesFactoryBean converts the contents of the YAML file into the properties in the initial\napplication.properties file.\n#application.yml\napp:\nport:8082\ncontext:/boot\n■ ! Both application.properties and application.yml can be used in the same project, because for\nbigger projects, the configuration list could be quite large and migration could be a long duration process; it is\nconvenient to be able to do the migration gradually. Be careful not to have the same properties defined in both\nfiles, because if this happens, properties defined in application.properties take precedence.\nYAML properties can be used in a different way. A class can be designed to have its fields initialized\nfrom a YAML file. The following AppSettings class is such a class.\npackage com.book.init;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport javax.annotation.PostConstruct;\nimport javax.validation.constraints.NotNull;\n@ConfigurationProperties(prefix=\"app\")\npublic class AppSettings {\nprivate static Logger logger = LoggerFactory.getLogger(AppSettings.class);\n@NotNull\nprivate Integer port;\n3The property names standard list for application.properties or application.yml is at http://docs.spring.io/\nspring-boot/docs/current/reference/htmlsingle/#common-application-properties.\n377\nChapter 8 ■ Spring Boot and WeBSoCket\n@NotNull\nprivate String context;\npublic Integer getPort() {\nreturn port;\n}\npublic void setPort(Integer port) {\nthis.port = port;\n}\npublic String getContext() {\nreturn context;\n}\npublic void setContext(String context) {\nthis.context = context;\n}\npublic AppSettings() {\n}\n@PostConstruct\npublic void check() {\nlogger.info(\"Initialized {} {}\", port, context);\n}\n}\nThe annotation that allows this is @ConfigurationProperties, which marks a class to be used for\ninitialization with property values by the Spring DataBinder utilities. The advantage here is that usage of\nthe @Value annotation and hard-coding the property names is avoided. Validators can also be added on\nthe fields (notice the @NotNull annotations).\nThe prefix attribute is used to refer to the parent element in the YAML file. This bean is then autowired\ninto the YamlConfBean, which uses its properties as needed.\npackage com.book.init;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n@Component\npublic class YamlConfBean implements EmbeddedServletContainerCustomizer {\n@Autowired\nprivate AppSettings appSettings;\n378\nChapter 8 ■ Spring Boot and WeBSoCket\n@Override\npublic void customize(ConfigurableEmbeddedServletContainer container) {\ncontainer.setPort(appSettings.getPort());\ncontainer.setContextPath(appSettings.getContext());\n}\n}\nFor Spring Boot to know to create and initialize a bean of type AppSettings, a modification must be\nmade to the Application class. The @EnableConfigurationProperties (AppSettings.class) annotation\nmust be added to the class definition at the same level as @SpringBootApplication. If the class name\n(AppSettings in this case) is not specified in the annotation, Spring Boot will scan, create, and initialize\nbeans of all classes annotated with ConfigurationProperties.\npackage com.book.init;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.ComponentScan;\n@SpringBootApplication\n@ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"})\n@EnableConfigurationProperties(AppSettings.class)\npublic class Application {\npublic static void main(String args) {\nSpringApplication.run(Application.class, args);\n}\n}\nWhen using Spring Boot, a Spring ASCII banner is printed in the console at application startup, like the\none shown in Figure 8-3.\nFigure 8-3. Spring Boot console banner\n379\nChapter 8 ■ Spring Boot and WeBSoCket\nThis too can be customized. The instructions can be found in the official documentation at\nhttp://docs.spring.io/spring-boot/docs/1.2.6.RELEASE/reference/htmlsingle/#boot-features-banner.\nA banner.txt file needs to be created under the resources directory; a text-to-ASCII generator should be\nused to create the desired banner. The one presented in module 08-chapter-03-solution is shown\nin Figure 8-4.\nFigure 8-4. Apress Spring Boot console banner\nImporting Additional Configuration Elements\nIf an application is migrated to Spring Boot, a lot of the configuration classes and even XML configuration\nelements can be imported into the Spring Boot configuration class. Additional configuration classes\ncan be imported using the @Import annotation or by adding a @ComponentScan to the Spring Boot core\ninitialization class (the one with the main method in it) and setting the basePackages attribute value with\nthe package name where the class can be found, which ensures that Spring automatically picks up all Spring\ncomponents, including @Configuration classes.\nXML configuration can be imported using the @ImportResource annotation, as the Spring Boot\ninitialization class is nothing more than a more complex @Configuration class.\nif you are using a Unix system, you can also test the examples attached to the chapter using the curl\ncommand. Just open a console and execute:\ncurl localhost:8080/boot\n#modify port or contextPath accordingly\nin the console, you should see an output similar to what you see in the browser.\n380\nChapter 8 ■ Spring Boot and WeBSoCket\nRunning Spring Boot Applications\nThe main difference between using Spring Boot and developing web applications in the typical way is that\nwhen the Gradle spring-boot plugin is used, a web archive (*.war) is no longer created, because there is no\nneed for it. The war file is strictly a deployable file that needs to be run using a web server or an application\nserver. Spring Boot can be used to have an embedded server in the application. So when the Gradle\nspring-boot plugin is used instead of a war, an executable Java archive (*.jar) is created.\nThe created archive can be found under the [project_root]/build/libs and can be executed just\nlike any jar. In the 08-chapter-03-solution.gradle configuration file, there is the line jar.archiveName =\n\"boot.jar\", which is used to specify the name of the final archive. Without it, the name of the resulting jar\nwould be 08-chapter-03-solution.jar, which is long and unpractical.\nTo build the project, create the jar and then execute the application. The following lines can be executed\nin the console (shell or command prompt):\n#this will work only if you have Gradle installed on the system\n$ gradle clean build\n$ java -jar build/libs/boot.jar\nBut what if we want the result to be a web archive that should be deployed on an application server or a\nweb server?",
    "answer": "That can be done too, in three simple steps: 1. Modify the application to provide a Servlet initializer for the servlet environment. This is done by making the class annotated with @SpringBootApplication to extend the Spring Boot convenient class org.springframework.boot.context. web.SpringBootServletInitializer and overriding its configure method: @SpringBootApplication @ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"}) @EnableConfigurationProperties(AppSettings.class) public class Application extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(Application.class); } public static void main(String args) { SpringApplication.run(Application.class, args); } } 2. Leave all the Spring Boot components as dependencies, but use the Gradle war plugin. (Basically, replace apply plugin: 'spring-boot' with apply plugin: 'war'.) 381 Chapter 8 ■ Spring Boot and WeBSoCket 3. Set the embedded server dependency as provided: apply plugin: 'war' war.archiveName = \"boot.war\" buildscript { repositories { mavenCentral() } dependencies { classpath boot.springBootPlugin } } dependencies { compile (boot.starterWeb){ exclude module : \"spring-boot-starter-tomcat\" } compile boot.actuator, boot.yaml providedCompile boot.starterJetty //previous 2 lines replaced: //compile boot.starterJetty, boot.actuator, boot.yaml testCompile misc.junit, misc.hamcrestCore, misc.hamcrestLib, boot.starterTest } After these changes, if the project is built under the build/libs directory, a boot.war should be created that can be deployed on any web or application server. ■ ! try to modify the configurations for the 08-chapter-03-solution to create a deployable war, as described before. You can use Jetty to run the war on by adding the gretty plugin that was used in the examples for this book until Spring Boot was introduced, by adding apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin' in the 08-chapter-03-solution.gradle file, and then running the appStart gradle task. When deploying the war to an application server or a web server, keep in mind that the relevant embedded server settings read from the application.yml file are ignored (because they are relevant only to Spring Boot) when a class annotated with @SpringBootApplication is used to run the application; so the application is available on the port and location that you set for that server. When using gretty, the location that your application can be accessed is printed in the console log. ... INFO Jetty 9.2.10.v20150310 started and listening on port 8080 INFO 08-chapter-03-solution runs at: INFO http://localhost:8080/08-chapter-03-solution ... 382 Chapter 8 ■ Spring Boot and WeBSoCket Testing Spring Boot Applications Applications built with Spring Boot can be tested using unit tests. Spring Boot provides a library to do just that in the most practical manner possible. It is called spring-boot-starter-test. It must be added as a dependency of the project to use it. As for common Spring Web applications, the servlet context must be mocked, and only the controller behavior is tested. The HelloWorldController is too simple to test, so a proper one is needed. @RestController public class MessageController { @Value(\"${app.message:Hello World}\") private String message = \"Hello World\"; @RequestMapping(\"/message\") public String message(){ return message; } } The default value for the message property is set to Hello World, if it is not present in the application.yml file: app: port: 8084 context: /boot message: Testing, is this thing on? The class to instantiate and test this controller in a mock environment looks like this: import static org.hamcrest.Matchers.equalTo; import static org.springframework.test.web.servlet.result. MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result. MockMvcResultMatchers.status; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.SpringApplicationConfiguration; import org.springframework.http.MediaType; import org.springframework.mock.web.MockServletContext; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.web.WebAppConfiguration; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.setup.MockMvcBuilders; @RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = MockServletContext.class) @WebAppConfiguration public class MessageControllerTest { 383 Chapter 8 ■ Spring Boot and WeBSoCket private MockMvc mvc; @Before public void setUp() throws Exception { mvc = MockMvcBuilders.standaloneSetup(new MessageController()).build(); } @Test public void getMessage() throws Exception { mvc.perform(MockMvcRequestBuilders.get(\"/message\") .accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"Hello World\"))); // testing the default value for this field } } The MockServletContext is used as argument for the @SpringApplicationConfiguration annotation, which provides a mock context where the MessageController can be instantiated. The MockMvcBuilders utility class is used to instantiate the controller instance that is to be tested. In Chapter 3, MockitoJUnitRunner.class was used to test a controller, but the Spring Test library offers more appropriate and intuitive methods, especially for REST controllers. The MockMvc should be familiar from Chapter 3. It is used here for the same purpose: to send HTTP request to the DispatcherServlet, and the status and content methods come into place to help test the results. ■ ! notice that the value returned by the content method is expected to be HelloWorld, and this is because the mock context does not include the application.yml. to include the YaML file in the context and test the value configured there, integration testing is needed. Applications built with Spring Boot can be tested using integration tests. These can be written easily for REST controllers because of a class provided by Spring Boot named org.springframework.boot.test. TestRestTemplate that extends the classical RestTemplate. The extra feature of this class is that secured resources can be tested too. import com.book.init.AppSettings; import com.book.init.Application; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.IntegrationTest; import org.springframework.boot.test.SpringApplicationConfiguration; import org.springframework.boot.test.TestRestTemplate; import org.springframework.http.ResponseEntity; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.web.WebAppConfiguration; import org.springframework.web.client.RestTemplate; 384 Chapter 8 ■ Spring Boot and WeBSoCket import java.net.URL; import static org.hamcrest.Matchers.equalTo; import static org.junit.Assert.assertThat; @RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = Application.class) @WebAppConfiguration @IntegrationTest public class MessageControllerIT { @Autowired AppSettings appSettings; private URL base; private RestTemplate template; @Before public void setUp() throws Exception { this.base = new URL(\"http://localhost:\" + appSettings.getPort() +\"/\" + appSettings.getContext() + \"/message\"); template = new TestRestTemplate(); } @Test public void getMessage() throws Exception { ResponseEntity<String> response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo(\"Testing, is this thing on?\")); } } Because real configuration classes are used to create the context in integration tests, beans can be injected and used inside the test class. In the previous example, the AppSettings bean is used to load the configuration details from the application.yml file, so the resulting endpoint for the MessageController is exactly the same as when the application is run with Spring Boot, and so is the content returned by the message method. The @IntegrationTest annotation is another convenient feature provided by Spring Boot to start the embedded server on which the test will be run. It is designed to be used in conjunction with @SpringApplicationConfiguration. The server is started on the port value and it is injected using the AppSetting.port property value. WebSocket Introduction Interaction between a user and a software service implies some type of communication. In the Web 2.0 era, software services are provided via web or mobile application, and communication is done over different protocols, the most common being HTTP. HTTP is a request-response model, with the client making the request (initiating a transaction) and the application providing the request service sending a response. But more and more is needed from web applications, and the HTTP request-response model is becoming insufficient because information can be transmitted from the server to the client only after a request is received; the server cannot send data in between requests or without being asked for it by the client first. 385 Chapter 8 ■ Spring Boot and WeBSoCket Think about a shopping application. Users need to insert personal data into a form to place an order. But while a user fills the form, the service that receives and processes orders might become inaccessible because of an internal issue. Wouldn’t it be nice if the server could send a message to the browser to inform the user that his order cannot be processed, saving him from wasting time inserting data into the form? There are workarounds that can be implemented to implement this type of behavior, such as HTTP long polling, which is a technique involving the client to poll the server for new information and the server to keep that request open until new data is available. But this technique might cause trouble when the connection between the client and the server gets interrupted frequently (like when switching between Wi-Fi and cellular networks); messages get lost and the server might keep requests open that no longer need to be. To overcome these situations, a communication management system must be implemented—so things get even more complicated. To provide a proper and practical solution, the WebSocket protocol was standardized in 2011 as RFC 6455.4 Most web browsers now implement a client API that supports it. As the official documentation says: “The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections.” Spring WebSocket Implementation Oracle has released JSR 356 as part of the JEE7 standard. It is the Java API for WebSocket that should be implemented to integrate WebSocket into web applications on the Java client and server sides. Client applications can be developed in any technology, and as long as they are compliant with the RFC 6455, they will be able to communicate with the server. The situation and the possibilities are depicted in Figure 8-5. Figure 8-5. A client-server application leveraging WebSocket schema In Spring 4.1, a module named spring-websocket was introduced to provide support for WebSocket- based, two-way communication between the client and the server in web applications. The implementation is a JSR-356-compatible Java WebSocket API and it also includes SockJS-based fallback options. The SockJS is a JavaScript library that provides a WebSocket-like object (WebSocket behavior is emulated). It is most suitable when the application needs to be supported in older browsers that do not support the WebSocket protocol. The Spring Framework WebSocket infrastructure is based on the Spring Messaging Foundation. Infrastructure beans like MessageChannel and MessageHandler are used as building blocks for the WebSocket environment. 4https://tools.ietf.org/html/rfc6455 386 Chapter 8 ■ Spring Boot and WeBSoCket In the spring-messaging module, support for STOMP5 was added, providing an annotation programming model for routing and processing messages from WebSocket clients. This means that controller methods can be used to process HTTP requests (when methods are annotated with @RequestMapping) and can also be used to process WebSocket messages when methods are annotated with @MessageMapping, an annotation that was introduced in Spring 4.0. The complementary operation, sending the result of the method back to the client, is implemented using the @SendTo annotation, which is used to mark a subscription endpoint to which all the potential clients are registered; this way, they are identified as receivers of messages from the server. The communication between clients and the server application using the WebSocket protocol is asynchronous, and when the server is overloaded, it can have delays in sending the messages. The WebSocket protocol is streaming, and messages can be sent to/received from a WebSocket at the same time, so a connection and a WebSocketSession implementation is needed to provide the infrastructure through which the messages will be exchanged. The following are the steps to create a WebSocket-compliant application using Spring WebSocket: 1. Define the format for the STOMP message and the POJO to model it. 2. Define the format for the server reply message and the POJO to model it. 3. Create a message-handling controller. 4. Configure Spring for WebSocket communication handling. 5. Create a client application. 6. Create an executable server application. To get familiarized with WebSocket Spring components, you’ll follow steps to create a mIRC6-like application that uses the WebSocket protocol. The application will be quite simple: it will require a username to allow connection to the server, but no authentication will be implemented. The server will receive messages from users and redistribute them to all connected clients. The server will communicate the time every 60 seconds and it will censor bad words, like bomb and murder. The source code to do this is explained later in the section. [STEP 1] The STOMP message is a JSON representation containing the username and a message that the sends to the server: { 'name' : 'jules', 'content' : 'Hello World!' } The POJO is quite simple and contains two properties (the JSON key names from the previous snippet) and getters. package com.book.ws; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.annotation.JsonPropertyOrder; @JsonPropertyOrder({ \"name\", \"content\"}) public class ChatMessage { 5STOMP is an acronym for Simple Text-Orientated Messaging Protocol. It defines a message format that any available STOMP clients can use to communicate with any STOMP server application. Basically, it represents a standard communication unit independent of languages and platforms. 6A popular Internet Relay Chat (IRC) used extensively in the 1990s (see http://www.mirc.com). 387 Chapter 8 ■ Spring Boot and WeBSoCket @JsonProperty(\"content\") private String content; @JsonProperty(\"name\") private String name; public String getName() { return name; } public String getContent() { return content; } } JSON-specific annotations can be used, so POJO fields can be named differently than the key names in the JSON message and can also be used to customize the serialization. For example, the @JsonPropertyOrder is used here to define ordering of properties at serialization time. In the previous code, the annotation ensures that the resulting JSON object will always have “name” as the first property and “content” as the second. ■ ! the JSon annotations are used abusively in the previous example, simply for demonstration purposes. as the field names of the class are one and the same with the JSon property names, the @JsonProperty can be removed because it doesn’t have any effect on the code. the same goes for the @JsonPropertyOrder, which can be removed because the order of the properties in the resulting JSon object is not really important in this case. [STEP 2] Upon receiving a ChatMessage and extracting the information, the server application processes it and responds with a ServerMessage instance that is sent to a separate queue that the client is subscribed to. The response is serialized to a JSON representation. Defining a format for the server is easy in a mIRC application; all that is needed is a JSON representation with one property: { 'content' : 'It is 18:13' } The POJO class that will be serialized could look like this: package com.book.ws; public class ServerMessage { private String content; public ServerMessage(String content) { this.content = content; } public String getContent() { return content; } } 388 Chapter 8 ■ Spring Boot and WeBSoCket Spring uses the Jackson JSON library to serialize and deserialize instances used for WebSocket communication. [STEP 3] Creating a message-handling controller is also quite easy when using the @MessageMapping @SendTo annotations. package com.book.ws; import org.springframework.stereotype.Controller; import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.messaging.handler.annotation.SendTo; import java.util.Random; @Controller public class ChatController { @MessageMapping(\"/mirc\") @SendTo(\"/topic/chat\") public ServerMessage process(ChatMessage message) throws Exception { //generate random lag Random rn = new Random(); Thread.sleep((rn.nextInt(5) + 1) * 1000); return MessageProcessor.build(message); } } The MessageProcessor is a utility class used to build the ServerMessage instances, which is serialized and sent to the client. The implementation is not really relevant for this section, as it only contains a static method used to build a ServerMessage instance based on a ChatMessage instance. package com.book.ws; public class MessageProcessor { public static ServerMessage build(ChatMessage message) { if (message.getContent() != null && !message.getContent().isEmpty()) { if (message.getContent().contains(\"bomb\")) { //censoring using string.replace(...) return new ServerMessage (\"[\" + message.getName() + \"]: \" + message.getContent().replace(\"bomb\", \"****\")); } else if (message.getContent().contains(\"murder\")) { //censoring using string.replace(...) return new ServerMessage (\"[\" + message.getName() + \"]: \" + message.getContent().replace(\"murder\", \"****\")); } return new ServerMessage (\"[\" + message.getName() + \"]: \" + message.getContent()); } return new ServerMessage(\"[server]: Welcome \" +message.getName()); } } 389 Chapter 8 ■ Spring Boot and WeBSoCket In the preceding code snippet, the process method is mapped to the destination \"mirc\", so if a message is sent to this destination, the method is called. This behavior is provided by annotating the method with @MessageMapping(\"/mirc\") . Any message received from the client application(s) is deserialized, resulting in a ChatMessage instance that is used as an argument for the process method call. The Thread.sleep call is used to simulate a delay. The Random instance is used to generate a random duration for the delay with a maximum of 5 seconds. This artifice was added to demonstrate that communication between the client application and the server is indeed asynchronous. Spring WebSocket Configuration [STEP 4] To configure Spring for WebSocket communication handling with STOMP messages, a configuration class needs to be created. package com.book.init; import org.springframework.context.annotation.Configuration; import org.springframework.messaging.simp.config.MessageBrokerRegistry; import org.springframework.web.socket.config.annotation. AbstractWebSocketMessageBrokerConfigurer; import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation.StompEndpointRegistry; @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker(\"/topic\"); config.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/mirc\").withSockJS() .setStreamBytesLimit(512 * 1024) .setHttpMessageCacheSize(1000) .setDisconnectDelay(30 * 1000); } } Each of the elements in the previous class declaration has a specific responsibility. The following describes each of them.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "@EnableWebSocketMessageBroker enables WebSocket message handling using a\nmessage broker.\nAbstractWebSocketMessageBrokerConfigurer is a Spring convenient class\nimplementing the WebSocketMessageBrokerConfigurer interface to provide\nempty method bodies for optional methods that are now needed for a minimal\nconfiguration of a WebSocket application.\n390\nChapter 8 ■ Spring Boot and WeBSoCket\n• The configureMessageBroker() method implementation is used to configure a\nmessage broker. The config.enableSimpleBroker(\"/topic\") enables a simple\nmemory-based message broker used to filter destinations prefixed with \"/topic\"\ntargeting the broker. The config.setApplicationDestinationPrefixes(\"/app\")\nmethod designates the prefix for messages that need to be handled by methods\nannotated with @MessageMapping.\n• The registerStompEndpoints() registers the \"/mirc\" STOMP endpoint, and\nenables and configures the SockJS fallback options. The subsequent chained method\ncalls are used to configure streaming details.\nStreaming transports save responses on the client side and do not free the\nmemory occupied by delivered messages, so the connection needs to be recycled\nfrom time to time. WebSocket communication is based on HTTP Streaming,\nwhich works by pushing content continuously to browser. The memory usage\nis kept accumulated in browser. Basically, the browser needs to close and\nreconnect the streaming channel to release memory. So there are a limited\nnumber of bytes that can be sent before the HTTP streaming connection is closed.\nThe default value set by SockJS is 128K; the .setStreamBytesLimit(512 * 1024)\ncall sets it to 512K.\nThe number of server-to-client messages that can be cached in a session waiting\nfor the next HTTP request polling is also limited. The default is 100 and it is set by\nthe web server; the .setHttpMessageCacheSize(1000) call sets it to 1000.\nThe number of milliseconds after an inactive client is disconnected is 5 seconds\nand it is set by the web server, but the .setDisconnectDelay(30 * 1000) call\nsets it to 30.\nTo use all of these elements, the spring-websocket and spring-messaging libraries must be added\nas dependencies. When using Spring Boot, only the spring-boot-starter-websocket dependency is\nnecessary. Spring Boot adds all the necessary dependencies.\nAside from this, the entry point of the application is the com.init.Application class, which is a typical\nboot-up Spring Boot class.\npackage com.book.init;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n@SpringBootApplication\n@ComponentScan(basePackages = {\"com.book.init, com.book.ws\"})\npublic class Application {\npublic static void main(String args) {\nSpringApplication.run(Application.class, args);\n}\n}\n391\nChapter 8 ■ Spring Boot and WeBSoCket\nWebSocket Client Application\nAs depicted in Figure 8-5, client applications for a Spring WebSocket server application can be written in\nany programming language for which a WebSocket implementation or Socket-compatible implementation\nexists. For the example in this section, the simplest way to create a client application is the plain old HTML\nand JavaScript pair.\n[STEP 5] Creating a browser client application is easy, and for the scope of this book, it is part of the\nsame application and deployed on the same embedded container. The application is a JavaScript client that\nsends and receives messages from the server.\nThe module project for this section can be found under the book-code project and it is called\n08-chapter-04-solution. The module is a Spring Boot WebSocket project organized as follows:\n• The sources for the WebSocket server-application can be found under src/main/java.\nThe configuration classes are placed in the com.book.init package. All classes\ninvolved in WebSocket communication are placed under the com.book.ws package.\n• The sources for the JavaScript client application can be found under src/main/\nresources/static. The client application can be accessed at index.html. The\nfunctions that get called on specific HTML events are all gathered in the index.js\nfile. The JavaScript external libraries used in the project are under the static/ext\ndirectory.\n• jQuery is used to simplify the development of the JavaScript code used to handle\nHTML user events.\n• SockJS is used to emulate WebSocket and provides a WebSocket-like API.\n• The STOMP library is used to help create STOMP messages.\nThe structure of the full Spring Boot WebSocket project is depicted in Figure 8-6.\n392\nChapter 8 ■ Spring Boot and WeBSoCket\nFigure 8-6. The 08-chapter-04-solution project structure\nThe client application when no client is connected is depicted in Figure 8-7.\nFigure 8-7. The client application before connection\n393\nChapter 8 ■ Spring Boot and WeBSoCket\nHere is the static front-end that is written in HTML and represented by the index.html file:\n<!DOCTYPE html>\n<html>\n<head>\n<title>WebSocket mIRC-like sample application</title>\n<script src=\"ext/sockjs-0.3.4.js\"></script>\n<script src=\"ext/stomp.js\"></script>\n<script src=\"ext/jquery-2.1.4.js\"></script>\n<script src=\"index.js\"></script>\n<link rel=\"stylesheet\" href=\"css/general.css\">\n</head>\n<body>\n<noscript><h2 style=\"color: #ff0000\">Seems your browser doesn’t support\nJavaScript! Websocket relies on Javascript being enabled.\nPlease enableJavascript and reload this page!</h2></noscript>\nThis is a simple mirc-like web chat application,\nno authentication is necessary, just provide a name and start chatting!</h4>\n<div class=\"header\">\nName : <input id=\"name\" type=\"text\"/>\n<input id=\"connection\" type=\"button\"/>\n</div>\n<div class=\"chatDiv\">\n<textarea class=\"chat\"></textarea>\n</div>\n<div class=\"footer\">\n<input id=\"content\" type=\"text\"/>\n<input id=\"send\" type=\"button\" value=\"Send\"/>\n</div>\n</body>\n</html>\nThe following describes the four JavaScript functions in index.js:\n• setConnected(boolVal): The argument is a boolean value. The method is called\nwith true when connecting to the server application and with false when\ndisconnecting. The same button is used for connecting and disconnecting. The label\non the button changes depending on the current state of the application. When\nthe application is accessed for the first time, a name is required to connect to the\napplication.\nfunction setConnected(connected) {\n\\\\ set label for the connect/disconnect button\nconnected ?",
    "answer": "$(\"#connection\").attr(\"value\", \"Disconnect\") : $(\"#connection\").attr(\"value\", \"Connect\"); \\\\ disable name textfield so the name cannot be modified \\\\ after connecting $(\"#name\").prop(\"disabled\", connected); 394 Chapter 8 ■ Spring Boot and WeBSoCket \\\\hide the chat window connected ? $(\".chatDiv\").show() : $(\".chatDiv\").hide(); \\\\hide the insert message textfield connected ? $(\".footer\").show() : $(\".footer\").hide(); \\\\empty the chat window $(\".chat\").html(\"\"); }",
    "source": "extracted",
    "confidence": 1.0
  }
]