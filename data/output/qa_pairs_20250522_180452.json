[
  {
    "question": "S In this chapter, we'll talk about why it's important to introduce yourself in an interview. When you introduce yourself, you can give the interviewer a quick overview of your work experience and technical skills. When you introduce yourself, it's crucial to only talk about things you're very sure about, things you know 100 percent. For example, if you're not familiar with a technology like JavaScript, it's best not to mention it because the interviewer might ask you about it. Remember, you can influence the interview by choosing what topics to talk about. Try to focus on the things you're really good at and be ready to answer questions about them. Let’s dive into the interview questions. Tell me about yourself, tell me about your skills. \"Tell me about yourself\" and \"Tell me about your skills\" are common interview questions that can be challenging to answer. Here are some tips on how to tackle these questions: Prepare ahead of time: Spend some time thinking about your strengths, experiences, and achievements that are relevant to the position you are applying for. Write them down and practice talking about them out loud. Keep it relevant: When answering the question \"Tell me about yourself,\" focus on your professional experiences and achievements that are relevant to the position you are applying for. You can also mention your personal interests if they relate to the job. Be concise: Keep your answers brief and to the point. Don't ramble on or share irrelevant information. Stick to the main points and be clear and concise. Highlight your skills: When asked about your skills, provide specific examples of how you have used them in the past to achieve success. Talk about your strengths and how they will benefit the company. Be sure to include both technical and soft skills, such as problem-solving, communication, and teamwork. Be honest: It's important to be truthful when answering these questions. Don't exaggerate or make up skills or experiences that you don't possess. Practice: It's a good idea to practice answering these questions with a friend or family member to help you feel more comfortable and confident during the actual interview. Please tell me about your project and its architecture. Please explain it and draw the architecture, framework, and technology used. When answering the question \"Tell me about your project and architecture,\" it's important to provide a clear and concise overview of the project and the underlying architecture. Here are some tips to help you tackle this question: Start with an overview: Begin by giving a brief overview of the project and the business problem it was designed to solve. This will help provide context for the architecture you will describe. Discuss the architecture: Explain the underlying architecture that was used in the project. This should include a high-level overview of the components and how they interact with each other. You can also discuss the rationale for choosing this architecture and any trade- offs that were made. Describe the design decisions: Talk about the design decisions that were made during the project. This could include how the architecture was designed to meet specific performance requirements, how the system was designed to be scalable, or how it was designed to be maintainable. Discuss the implementation: Describe how the architecture was implemented and any challenges that were encountered during implementation. This could include any optimizations that were made or any trade-offs that were made to meet specific requirements. Highlight your role: Be sure to discuss your role in the project and how you contributed to the architecture design and implementation. This could include any specific tasks you performed or any technical challenges you helped overcome. Use visual aids: If possible, use diagrams or other visual aids to help illustrate the architecture and design decisions. This can help the interviewer better understand your explanation and provide a more comprehensive answer. Remember to stay focused on the most relevant aspects of the project and architecture, and be sure to highlight your role and contributions to the project. Be clear and concise in your explanation, and use examples and visual aids where possible to help support your answer. What are the best practices to follow while developing an application?",
    "answer": "There are several best practices to follow during software development to ensure a high-quality product and efficient development process. Here are some of the most important ones: Plan and prioritize: Before starting development, make sure to plan the project thoroughly and prioritize tasks based on their importance and urgency. Follow a consistent process: Use a consistent development process, such as agile or waterfall, to ensure a structured and predictable development process. Use version control: Use a version control system, such as Git, to manage and track changes to the codebase. Test early and often: Test the software early and often to catch bugs and errors before they become more difficult to fix. Use automation: Use automation tools, such as continuous integration and deployment (CI/CD) pipelines, to automate repetitive tasks and ensure consistency. Write clean and modular code: Write clean, modular, and maintainable code to make it easier to maintain and extend the software over time. Document the code: Document the code thoroughly, including comments and documentation, to make it easier for other developers to understand and work with the code. Use appropriate tools and technologies: Use appropriate tools and technologies that are well-suited for the project requirements and team's skills. Collaborate effectively: Foster effective collaboration within the team, including communication, code reviews, and regular meetings to ensure everyone is aligned and working towards the same goals. Continuously improve: Continuously evaluate and improve the development process and incorporate feedback from users to improve the software over time. By following these best practices, software development teams can create high-quality software that is maintainable, scalable, and efficient to develop. What challenging tasks have you accomplished so far? Could you provide examples? Interviewers are usually interested in hearing about the most challenging technical tasks you've tackled. They'll likely ask in-depth",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Allowed: only as a local variable * Not allowed: anywhere else (class field, method param, etc.) * User var responsibly! * * Use: * - when it's clear what the type is (string, int) * - to shorten very long ugly types * * Don't use: * - returned value is unclear (var data = service.getData();) */ public static void main(String[] args) { // allowed, but brings little benefit var b = \"b\"; var c = 5; // int var d = 5.0; // double var httpClient = HttpClient.newHttpClient(); // one hell of an inference :) var list = List.of(1, 2.0, \"3\"); // the benefit becomes more evident with types with long names var reader = new BufferedReader(null); // vs. BufferedReader reader2 = new BufferedReader(null); } } Optional API — new methods introduced public class OptionalApi { /** * new .orElseThrow() */ public static void main(String[] args) { Optional<Flight> earliestFlight = FlightSchedule.getFlights() .stream() .filter(f -> \"Boston\".equals(f.from())) .filter(f -> \"San Francisco\".equals(f.to())) .min(comparing(Flight::date)); earliestFlight.orElseThrow(FlightNotFoundException::new); } } Java 11 Features 1.HTTP client Here is the program to explain the HTTP client changes, public class HttpClientBasicExample { /** * Create a client, send a GET Request, print Response info */ public static void main(String... args) throws Exception { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder(URI.create(\"https://github.com/ \")) .GET() // default, may be omitted .build(); HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString()); print(\"Status code was: \" + response.statusCode()); print(response.headers().map()); } } 2.New File Methods: Java 11 introduced several new methods in the java.nio.file package, providing additional functionality for working with files and directories. Some of the notable methods include: Files.readString(Path path) and Files.writeString(Path path, CharSequence content, OpenOption... options): These methods simplify reading and writing the contents of a file as a string. The readString method reads the entire content of a file into a string, and the writeString method writes a string to a file. 2. Files.readAllLines(Path path) and Files.write(Path path, Iterable<?",
    "answer": "extends CharSequence> lines, OpenOption... options): These methods simplify reading and writing the contents of a file as a list of strings. The readAllLines method reads all lines from a file into a list, and the write method writes a collection of strings to a file. 3. Files.newBufferedReader(Path path) and Files.newBufferedWriter(Path path, OpenOption... options): These methods create buffered readers and writers for efficient reading and writing of files. They simplify the process of working with character streams. 4.files.mismatch(Path path1, Path path2): This method compares the content of two files and returns the position of the first mismatched byte. If the files are identical, it returns -1. Here is the example, public class NewFilesMethods { static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\"; static String file_1 = filePath + \"file_1.txt\"; /**",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Files.readString() and .writeString() */ public static void main(String[] args) throws IOException { // reading files is much easier now // not to be used with huge files Path path = Paths.get(file_1); String content = Files.readString(path); print(content); Path newFile = Paths.get(filePath + \"newFile.txt\"); if(!Files.exists(newFile)) { Files.writeString(newFile, \"some str\", StandardOpenOption.CREATE); } else { Files.writeString(newFile, \"some str\", StandardOpenOption.TRUNCATE_EXISTING); } } } Java 12 Features 1.Compact Number Formatting: Java 12 introduced a new feature called “Compact Number Formatting” as part of JEP 357. This enhancement provides a more concise way to format large numbers in a locale-specific manner. The NumberFormat class in the java.text package was enhanced to support the new Style enum, including the Style.SHORT and Style.LONG constants. These styles can be used to format large numbers in a compact form based on the specified locale. public class CompactNumberFormattingExample { public static void main(String[] args) { // Creating a number formatter with compact style NumberFormat compactFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT); // Formatting large numbers System.out.println(\"Short Format: \" + compactFormatter.format(1000)); // Output: 1K System.out.println(\"Short Format: \" + compactFormatter.format(1000000)); // Output: 1M // Creating a number formatter with compact style (long) NumberFormat compactLongFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG); // Formatting large numbers in long style System.out.println(\"Long Format: \" + compactLongFormatter.format(10000000)); // Output: 10 million System.out.println(\"Long Format: \" + compactLongFormatter.format(1000000000)); // Output: 1 billion } } 2.String::indent (JEP 326): The String class in Java 12 introduced a new method called indent(int n). This method is used to adjust the indentation of each line in a string by a specified number of spaces. String indentedString = \"Hello\\nWorld\".indent(3); // indentedString is now \" Hello\\n World\" 3.New Methods in java.util.Arrays (JEP 326): Java 12 added several new methods to the java.util.Arrays class, including copyOfRange and equals variants that take a Comparator. 4.Improvements in java.util.stream.Collectors (JEP 325): The Collectors utility class in Java 12 introduced new collectors like teeing, which allows combining two collectors into a single collector. 5.New File Methods: public class NewFilesMethod { static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\"; static String file_1 = filePath + \"file_1.txt\"; static String file_2 = filePath + \"file_2.txt\"; public static void main(String[] args) throws IOException { // Finds and returns the position of the first mismatched byte in the content of two files, // or -1L if there is no mismatch long result = Files.mismatch(Paths.get(file_1), Paths.get(file_2)); print(result); // -1 } } Java-13 Features Nothing much interesting happend: — API update to ByteBuffer — Update to localization (support for new chars and emojis) — GC updates Java-14 Features 1.“Switch Expressions” (SE) instead of “Switch Statements” (SS): Enhanced Switch Expressions: Switch expressions, introduced as a preview feature in Java 12 and finalized in Java 13, allow developers to use switch statements as expressions, providing a more concise and expressive syntax. int dayOfWeek = 2; String dayType = switch (dayOfWeek) { case 1, 2, 3, 4, 5 -> \"Weekday\"; case 6, 7 -> \"Weekend\"; default -> throw new IllegalArgumentException(\"Invalid day of the week: \" + dayOfWeek); }; “Yield” Statement: The “yield” statement was introduced in Java 14 to complement switch expressions. It allows you to specify a value to be returned from a switch arm, providing more flexibility in combining both imperative and functional styles. String dayType = switch (dayOfWeek) { case 1, 2, 3, 4, 5 -> { System.out.println(\"Working day\"); yield \"Weekday\"; } case 6, 7 -> { System.out.println(\"Weekend\"); yield \"Weekend\"; } default -> throw new IllegalArgumentException(\"Invalid day of the week: \" + dayOfWeek); }; One More example, /** * \"Switch Expressions\" (SE) instead of \"Switch Statements\" (SS) * (Both can be used, but SE is better than SS) */ public class SwitchExpressions { public static void main(String[] args) { oldStyleWithBreak(FruitType.APPLE); withSwitchExpression(FruitType.PEAR); switchExpressionWithReturn(FruitType.KIWI); switchWithYield(FruitType.PINEAPPLE); } // Old style is more verbose and error-prone (forgotten \"break;\" causes the switch to fall through) private static void oldStyleWithBreak(FruitType fruit) { print(\"==== Old style with break ====\"); switch (fruit) { case APPLE, PEAR: print(\"Common fruit\"); break; case PINEAPPLE, KIWI: print(\"Exotic fruit\"); break; default: print(\"Undefined fruit\"); } } private static void withSwitchExpression(FruitType fruit) { print(\"==== With switch expression ====\"); switch (fruit) { case APPLE, PEAR -> print(\"Common fruit\"); case PINEAPPLE -> print(\"Exotic fruit\"); default -> print(\"Undefined fruit\"); } } private static void switchExpressionWithReturn(FruitType fruit) { print(\"==== With return value ====\"); // or just \"return switch\" right away String text = switch (fruit) { case APPLE, PEAR -> \"Common fruit\"; case PINEAPPLE -> \"Exotic fruit\"; default -> \"Undefined fruit\"; }; print(text); } /** * \"Yield\" is like \"return\" but with an important difference: * \"yield\" returns a value and exits the switch statement. Execution stays within the enclosing method * \"return\" exits the switch and the enclosing method */ // https://stackoverflow.com/questions/58049131/what-does-the- new-keyword-yield-mean-in-java-13 private static void switchWithYield(FruitType fruit) { print(\"==== With yield ====\"); String text = switch (fruit) { case APPLE, PEAR -> { print(\"the given fruit was: \" + fruit); yield \"Common fruit\"; } case PINEAPPLE -> \"Exotic fruit\"; default -> \"Undefined fruit\"; }; print(text); } public enum FruitType {APPLE, PEAR, PINEAPPLE, KIWI} } Java 15 Features: 1.Text-block: Text blocks are a new kind of string literals that span multiple lines. They aim to simplify the task of writing and maintaining strings that span several lines of source code while avoiding escape sequences. Example without text blocks: String html = \"<html>\\n\" + \" <body>\\n\" + \" <p>Hello, world</p>\\n\" + \" </body>\\n\" + \"</html>\"; Example with text blocks: String html = \"\"\" <html> <body> <p>Hello, world</p> </body> </html> \"\"\"; Key features of text blocks include: Multiline Strings: Text blocks allow you to represent multiline strings more naturally, improving code readability. Whitespace Control: Leading and trailing whitespaces on each line are removed, providing better control over the indentation. Escape Sequences: Escape sequences are still valid within text blocks, allowing the inclusion of special characters. Text blocks were designed to make it easier to express strings that include multiple lines of content, such as HTML, XML, JSON, or SQL queries. If there have been any updates or new features related to text blocks in Java 15 or subsequent releases, it’s advisable to check the official documentation or release notes for the specific version. /** * Use cases for TextBlocks (What's New in Java 15 > Text Blocks in Practice) * - Blocks of text using markdown * - Testing, defining hard-coded JSON strings * - Simple templating */ public class TextBlocks { public static void main(String[] args) { oldStyle(); emptyBlock(); jsonBlock(); jsonMovedEndQuoteBlock(); jsonMovedBracketsBlock(); } private static void oldStyle() { print(\"******** Old style ********\"); String text = \"{\\n\" + \" \\\"name\\\": \\\"John Doe\\\",\\n\" + \" \\\"age\\\": 45,\\n\" + \" \\\"address\\\": \\\"Doe Street, 23, Java Town\\\"\\n\" + \"}\"; print(text); } private static void emptyBlock() { print(\"******** Empty Block ********\"); String text = \"\"\" \"\"\"; print(\"|\" + text + \"|\"); } private static void jsonBlock() { print(\"******** JSON Block ********\"); String text = \"\"\" { \"name\": \"John Doe\", \"age\": 45, \"address\": \"Doe Street, 23, Java Town\" } \"\"\"; // <-- no indentation if char is aligned with first \" print(text); } private static void jsonMovedEndQuoteBlock() { print(\"******** Json Moved End Quote Block ********\"); String text = \"\"\" { \"name\": \"John Doe\", \"age\": 45, \"address\": \"Doe Street, 23, Java Town\" } \"\"\"; print(text); } private static void jsonMovedBracketsBlock() { print(\"******** Json Moved Brackets Block ********\"); String text = \"\"\" { \"name\": \"John Doe\", \"age\": 45, \"address\": \"Doe Street, 23, Java Town\" } \"\"\"; // <-- indented by 2 spaces as it is aligned with third \" print(text); } } Java 16 Features 1.Pattern matching for instanceof: Java 16’s pattern matching for instanceof is a nifty feature that improves type checking and extraction. Here's a rundown of its key aspects: What it does: Introduces type patterns instead of just checking against a single type. Allows declaring a variable within the instanceof check to hold the extracted object. Combines type checking and casting into a single, more concise and readable expression. Benefits: Reduced boilerplate: Eliminates the need for separate instanceof checks, casts, and variable declarations. Improved readability: Makes code clearer and easier to understand, especially for complex type hierarchies. Reduced errors: Less chance of casting exceptions due to mistaken types. Syntax: if (obj instanceof String s) { // Use \"s\" directly as a String here } else if (obj instanceof List<Integer> list) { // Use \"list\" directly as a List<Integer> here } else { // Handle other cases } Example public class PatternMatchingForInstanceof { public static void main(String[] args) { Object o = new Book(\"Harry Potter\", Set.of(\"Jon Doe\")); // old way if (o instanceof Book) { Book book = (Book) o; print(\"The book's author(s) are \" + book.getAuthors()); } // new way if (o instanceof Book book) { print(\"The book's author(s) are \" + book.getAuthors()); } } } Record: Records in Java are a special type of class specifically designed for holding immutable data. They help reduce boilerplate code and improve readability and maintainability when dealing with simple data structures. Here’s a breakdown of their key characteristics: 1. Conciseness: Unlike traditional classes, records require minimal code to define. You just specify the data fields (components) in the record declaration, and the compiler automatically generates essential methods like: Constructor with parameters for each component. Getters for each component. equals and hashCode methods based on component values. toString method representing the record's state. 2. Immutability: Record fields are declared as final, making the data stored within them unmodifiable after the record is created. This ensures data consistency and simplifies thread safety concerns. 3. Readability: The auto-generated methods and predictable behavior of records enhance code clarity and make it easier to understand what the record represents and how it interacts with other parts of your program. 4. Reduced Errors: By minimizing boilerplate, records reduce the risk of common mistakes like forgetting getters or implementing equals incorrectly. This leads to more robust and reliable code. Overall, records are a valuable tool for Java developers to create concise, immutable, and readable data structures, leading to cleaner, more maintainable code. /** * Record are data-only immutable classes (thus have specific use cases) * They are a restricted (specialized) form of a class (like enums) * Not suitable for objects that are meant to change state, etc. * <p> * Records are NOT: * - Boilerplate reduction mechanism * <p> * Records generate constructors, getters, fields; equals, hashCode, toString * <p> * Use cases: * - to model immutable data * - to hold read-only data in memory * - DTOs - Data Transfer Objects */ public class RecordsDemo { public static void main(String[] args) { Product p1 = new Product(\"milk\", 50); Product p2 = new Product(\"milk\", 50); print(p1.price()); // without \"get\" prefix print(p1); // auto-generated toString() - Product[name=milk, price=50] print(p1 == p2); // false - different objects print(p1.equals(p2)); // true - values of fields (milk, 50) are compared by the auto-generated equals()/hashCode() } } /** * params are called \"Components\" * want more fields - must add into the signature * Extending not allowed, implementing interfaces IS allowed */ public record Product(String name, int price) { // static fields allowed, but not non-static static String country = \"US\"; // constructor with all fields is generated // can add validation public Product { if(price < 0) { throw new IllegalArgumentException(); } } // possible to override auto-generated methods like toString() } 2.Date Time Formatter API: General usage and features of the DateTimeFormatter API in Java 16: This includes understanding format patterns, creating custom formats, parsing dates and times, and available formatting options. New features introduced in Java 16 for date formatting: Specifically, the day period support using the \"B\" symbol and its various styles. Comparison of DateTimeFormatter with older formatters like SimpleDateFormat: Exploring the advantages and disadvantages of each approach. Examples of using DateTimeFormatter for specific formatting tasks: Like formatting dates in different locales, handling time zones, or generating human-readable representations. public class DateTimeFormatterApi { static Map<TextStyle, Locale> map = Map.of( TextStyle.FULL, Locale.US, TextStyle.SHORT, Locale.FRENCH, TextStyle.NARROW, Locale.GERMAN ); public static void main(String[] args) { for (var entry : map.entrySet()) { LocalDateTime now = LocalDateTime.now(); DateTimeFormatter formatter = new DateTimeFormatterBuilder() .appendPattern(\"yyyy-MM-dd hh:mm \") .appendDayPeriodText(entry.getKey()) // at night, du soir, abends, etc. .toFormatter(entry.getValue()); String formattedDateTime = now.format(formatter); print(formattedDateTime); } } } 3.Changes in Stream API: Java 16 brought some exciting changes to the Stream API, making it even more powerful and convenient to use. Here are the key highlights: 1. Stream.toList() method: This new method provides a concise way to collect the elements of a stream into a List. Previously, you had to use collect(Collectors.toList()), which is now slightly redundant. 2. Stream.mapMulti() method: This method allows you to map each element of a stream to zero or more elements, creating a new stream of the resulting elements. It's handy for splitting or flattening complex data structures. 3. Enhanced line terminator handling: Java 16 clarifies the definition of line terminators in the java.io.LineNumberReader class. This eliminates inconsistencies and ensures consistent behavior when reading line-based data. 4. Other minor changes: String streams now support the limit and skip methods directly, removing the need for intermediate operations. The peek method can now be used with parallel streams, allowing side effects without impacting parallelism. public class StreamApi { public static void main(String[] args) { List<Integer> ints = Stream.of(1, 2, 3) .filter(n -> n < 3) .toList(); // new, instead of the verbose .collect(Collectors.toList()) ints.forEach(System.out::println); } } Java 17 Features 1.Sealed classes(Subclassing): Sealed classes are a brand-new feature introduced in Java 17 (JEP 409) that gives you more control over inheritance hierarchies. They essentially let you restrict which classes can extend or implement your class or interface. This can be incredibly useful for a variety of reasons, including: 1. Enhanced Type Safety: By specifying allowed subclasses, you prevent unexpected or unwanted extensions that could break your code or introduce security vulnerabilities. 2. Improved Library Design: You can create closed ecosystems within your libraries, ensuring users only work with approved extensions and don’t create incompatible implementations. 3. Easier Code Maintenance: Knowing the exact set of possible subclasses simplifies reasoning about your code and makes it easier to understand and maintain. How do sealed classes work?",
    "answer": "You declare a class or interface as sealed using the sealed keyword. Then, you use the permits clause to specify a list of classes that are allowed to extend or implement it. Only these permitted classes can directly inherit, while all other classes are prohibited. sealed class Shape { permits Circle, Square, Triangle; // ... implementation details } class Circle extends Shape { // ... } // This will cause a compile-time error because Rectangle isn't permitted class Rectangle extends Shape { // ... } A sealed class or interface can be extended or implemented only by those classes and interfaces permitted to do so. Benefits: 1) help enforce a well-defined and limited set of possible implementations — communicates INTENTION 2) Better security — help prevent unexpected or unauthorized subclassing and behavior from third-party code Rules: 1. A sealed class uses “permits” to allow other classes to subclass it. 2. A child class MUST either be final, sealed or non-sealed. (or code won’t compile) 3. A permitted child class MUST extend the parent sealed class. Permitting without using the permit is now allowed. 4. The classes specified by permits must be located near the superclass: either in the same module (if the superclass is in a named module) (see Java 9 modularity) or in the same package (if the superclass is in the unnamed module). More on point 4: The motivation is that a sealed class and its (direct) subclasses are tightly coupled since they must be compiled and maintained together. In a modular world, this means “same module”; in a non-modular world, the best approximation for this is “same package”. If you use modules, you get some additional flexibility, because of the safety boundaries modules give you. Java 18 Features 1.UTF-8 by Default: Java 18 makes UTF-8 the default character encoding for the platform, aligning with modern standards and simplifying character handling. public class Utf8ByDefault { // https://openjdk.org/jeps/400 - Platform Default Encoding public static void main(String[] args) throws IOException { // Problem: // 1) On Windows, use the below FileWriter to write characters outside the ASCII table, e.g. some exotic Unicode chars, without explicitly specifying a char set // 2) Copy or transfer the file to a UNIX-based OS, like a Mac, and read the file using the default char encoding of the system // 3) Likely result - garbled output // Hence the problem - unpredictable behavior. FileWriter writer = new FileWriter(\"out.txt\"); // Solution before Java 18: always specify the charset, (and good luck not forgetting it!) FileWriter writer2 = new FileWriter(\"out.txt\", StandardCharsets.UTF_8); // Solution since Java 18: UTF-8 is now default, so no need to specify the Char set } } 2.Simple Web Server: This new API provides a basic web server for serving static files, ideal for quick prototyping and embedded applications. Ensure you have Java 18 or later installed on your system. Have your static files (HTML, CSS, JavaScript, images, etc.) ready in a specific directory. public class SimpleWebServer { public static void main(String[] args) throws Exception { String documentRoot = \"/path/to/your/static/files\"; // Replace with your actual directory int port = 8080; // You can change the port if needed HttpServer server = HttpServer.create(new InetSocketAddress(port), 0); SimpleFileServer fileServer = new SimpleFileServer(documentRoot); server.setExecutor(null); // Use single-threaded executor server.createContext(\"/\", fileServer); server.start(); System.out.println(\"Server started on port \" + port); } } <!DOCTYPE html> <html> <head> <title>Title of the document</title> </head> <body> This page can be served with Java's Simple Web Server using the \"jwebserver\" command </body> </html> . Compile and run: Compile the Java file: javac SimpleWebServer.java Run the compiled class: java SimpleWebServer 4. Access the page: Open your web browser and navigate to http://localhost:8080 (or the specified port). You should see the default file (usually index.html) from your static files directory being served. 5. Stopping the server: To stop the server, press Ctrl+C in the terminal where it’s running. The simplest way to get started: 1) open the terminal in this package (java18) 2) run “java -version” and make sure it is at least java 18 3) run the “jwebserver” command It should output: Binding to loopback by default. For all interfaces use “-b 0.0.0.0” or “-b ::”. Serving path/to/your/subdirectory and subdirectories on 127.0.0.1 port 8000 URL http://127.0.0.1:8000/ The HTML page is now served at: http://127.0.0.1:8000/java18/doc.html IP address, port and other parameters may be changed 3.HEAD() convenience method added: public class HttpHeadDemo { /**",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "How to use the Spring Framework to develop Web applications • How to use Spring Web Flow to implement stateful interactions • How to secure Web applications with Spring Security Developer Exam • How to test Web applications for correctness and performance • How to create rich Web user interfaces with Ajax and JQuery • How to use Spring Roo to create a Spring Web application in minutes A Study Guide — Iuliana Cosmina ISBN 978-1-4842-0809-0 Shelve in: 54999 Programming Languages/Java User level: Intermediate–Advanced 9781484208090 SOURCE CODE ONLINE Pivotal Certified Spring Web Application Developer Exam A Study Guide Iuliana Cosmina Pivotal Certified Spring Web Application Developer Exam Copyright © 2015 by Iuliana Cosmina This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher’s location, in its current version, and permission for use must always be obtained from Springer. Permissions for use may be obtained through RightsLink at the Copyright Clearance Center. Violations are liable to prosecution under the respective Copyright Law. ISBN-13 (pbk): 978-1-4842-0809-0 ISBN-13 (electronic): 978-1-4842-0808-3 Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark. The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights. While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material contained herein. Managing Director: Welmoed Spahr Lead Editor: Steve Anglin Technical Reviewer: Manuel Jordan Elera Editorial Board: Steve Anglin, Louise Corrigan, James T. DeWolf, Jonathan Gennick, Robert Hutchinson, Michelle Lowman, James Markham, Susan McDermott, Matthew Moodie, Jeffrey Pepper, Douglas Pundick, Ben Renow-Clarke, Gwenan Spearing Coordinating Editor: Mark Powers Copy Editor: Kimberly Burton Compositor: SPi Global Indexer: SPi Global Artist: SPi Global Distributed to the book trade worldwide by Springer Science+Business Media New York, 233 Spring Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail orders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC and the sole member (owner) is Springer Science + Business Media Finance Inc (SSBM Finance Inc). SSBM Finance Inc is a Delaware corporation. For information on translations, please e-mail rights@apress.com, or visit www.apress.com. Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use. eBook versions and licenses are also available for most titles. For more information, reference our Special Bulk Sales–eBook Licensing web page at www.apress.com/bulk-sales. Any source code or other supplementary material referenced by the author in this text is available to readers at www.apress.com/9781484208090. For detailed information about how to locate your book’s source code, go to www.apress.com/source-code/. Readers can also access source code at SpringerLink in the Supplementary Material section for each chapter. To all passionate Java developers, never stop learning and never stop improving your skills. To all my friends for supporting me to make this book happen; you have no idea how dear you are to me. Contents at a Glance About the Author ���������������������������������������������������������������������������������������������������xiii About the Technical Reviewer ���������������������������������������������������������������������������������xv Acknowledgments �������������������������������������������������������������������������������������������������xvii Introduction ������������������������������������������������������������������������������������������������������������xix ■ Chapter 1: Introduction �����������������������������������������������������������������������������������������1 ■ Chapter 2: Spring Fundamentals �������������������������������������������������������������������������17 ■ Chapter 3: Spring MVC ����������������������������������������������������������������������������������������53 ■ Chapter 4: Spring Portlets ���������������������������������������������������������������������������������151 ■ Chapter 5: Spring RESTful Services �������������������������������������������������������������������189 ■ Chapter 6: Spring Web with AJAX ���������������������������������������������������������������������229 ■ Chapter 7: Spring Web Flow ������������������������������������������������������������������������������257 ■ Chapter 8: Spring Boot and WebSocket �������������������������������������������������������������367 ■ Appendix: Resources and Quiz Answers �����������������������������������������������������������401 Index ���������������������������������������������������������������������������������������������������������������������417 v Contents About the Author ���������������������������������������������������������������������������������������������������xiii About the Technical Reviewer ���������������������������������������������������������������������������������xv Acknowledgments �������������������������������������������������������������������������������������������������xvii Introduction ������������������������������������������������������������������������������������������������������������xix ■ Chapter 1: Introduction �����������������������������������������������������������������������������������������1 Spring and What It Does ���������������������������������������������������������������������������������������������������1 The Focus of this Study Guide ������������������������������������������������������������������������������������������4 Who Should Use this Study Guide ������������������������������������������������������������������������������������5 About the Spring Web Certification Exam�������������������������������������������������������������������������5 How to Use this Study Guide ��������������������������������������������������������������������������������������������6 How this Book Is Structured �������������������������������������������������������������������������������������������������������������������7 How Each Chapter Is Structured �������������������������������������������������������������������������������������������������������������7 Conventions ��������������������������������������������������������������������������������������������������������������������������������������������8 Downloading the Code ����������������������������������������������������������������������������������������������������������������������������8 Contacting the Author �����������������������������������������������������������������������������������������������������������������������������8 Recommended Development Environment ����������������������������������������������������������������������8 Recommended Build Tools ���������������������������������������������������������������������������������������������������������������������9 Recommended IDE �������������������������������������������������������������������������������������������������������������������������������10 The Project Sample ������������������������������������������������������������������������������������������������������������������������������11 vii ■ Contents ■ Chapter 2: Spring Fundamentals �������������������������������������������������������������������������17 The Basics ����������������������������������������������������������������������������������������������������������������������17 The Spring Core Container ���������������������������������������������������������������������������������������������19 Spring Configuration ������������������������������������������������������������������������������������������������������21 XML �������������������������������������������������������������������������������������������������������������������������������������������������������21 Annotations �������������������������������������������������������������������������������������������������������������������������������������������25 Mixed Approach ������������������������������������������������������������������������������������������������������������������������������������26 The Beans ����������������������������������������������������������������������������������������������������������������������27 Lifecycle and Instantiation ��������������������������������������������������������������������������������������������������������������������27 Bean Scopes �����������������������������������������������������������������������������������������������������������������������������������������35 Accessing Beans ����������������������������������������������������������������������������������������������������������������������������������38 Spring AOP ���������������������������������������������������������������������������������������������������������������������41 Testing Spring Applications ��������������������������������������������������������������������������������������������44 Summary ������������������������������������������������������������������������������������������������������������������������45 Quick Quiz ����������������������������������������������������������������������������������������������������������������������46 Practical Exercise �����������������������������������������������������������������������������������������������������������46 ■ Chapter 3: Spring MVC ����������������������������������������������������������������������������������������53 MVC Basics ���������������������������������������������������������������������������������������������������������������������53 Configuring MVC �������������������������������������������������������������������������������������������������������������55 XML Configuration ��������������������������������������������������������������������������������������������������������������������������������56 Configuration Using Annotations ����������������������������������������������������������������������������������������������������������61 Configuration Without Using web�xml ���������������������������������������������������������������������������������������������������64 MVC Components �����������������������������������������������������������������������������������������������������������67 Infrastructure Beans �����������������������������������������������������������������������������������������������������������������������������68 User-Provided Components ������������������������������������������������������������������������������������������������������������������94 View Technologies ��������������������������������������������������������������������������������������������������������109 Tiles Layouts ���������������������������������������������������������������������������������������������������������������������������������������110 Thymeleaf �������������������������������������������������������������������������������������������������������������������������������������������115 viii ■ Contents Forms ���������������������������������������������������������������������������������������������������������������������������119 Data Formatting ����������������������������������������������������������������������������������������������������������������������������������125 Data Binding ���������������������������������������������������������������������������������������������������������������������������������������129 Data Validation ������������������������������������������������������������������������������������������������������������������������������������132 Managing the Form Object �����������������������������������������������������������������������������������������������������������������137 Summary ����������������������������������������������������������������������������������������������������������������������138 Quick Quiz ��������������������������������������������������������������������������������������������������������������������139 Practical Exercise ���������������������������������������������������������������������������������������������������������144 ■ Chapter 4: Spring Portlets ���������������������������������������������������������������������������������151 Portlet Basics ���������������������������������������������������������������������������������������������������������������154 Configuration ����������������������������������������������������������������������������������������������������������������156 The XML Part of the Configuration �������������������������������������������������������������������������������157 The Annotation Part of the Configuration ���������������������������������������������������������������������164 Configuration Details and Recommendations ��������������������������������������������������������������168 The Development and Deployment of a Portlet Application �����������������������������������������169 Download, Install, Start, and Configure Liferay �����������������������������������������������������������������������������������170 Summary ����������������������������������������������������������������������������������������������������������������������188 ■ Chapter 5: Spring RESTful Services �������������������������������������������������������������������189 Core REST Concepts �����������������������������������������������������������������������������������������������������189 HATEOAS ����������������������������������������������������������������������������������������������������������������������195 Advantages of REST �����������������������������������������������������������������������������������������������������197 RESTful Applications Using Spring MVC �����������������������������������������������������������������������199 RESTful Clients with Spring ����������������������������������������������������������������������������������������������������������������199 Asynchronous REST Calls �������������������������������������������������������������������������������������������������������������������203 Implementing REST with Spring MVC �������������������������������������������������������������������������������������������������204 Asynchronous REST Services Using @Async Annotated Methods �����������������������������������������������������213 Using Spring HATEOAS �����������������������������������������������������������������������������������������������������������������������216 ix ■ Contents Summary ����������������������������������������������������������������������������������������������������������������������220 Quick Quiz ��������������������������������������������������������������������������������������������������������������������221 Practical Exercise ���������������������������������������������������������������������������������������������������������222 ■ Chapter 6: Spring Web with AJAX ���������������������������������������������������������������������229 What Is AJAX?",
    "answer": "��������������������������������������������������������������������������������������������������������������229 Making AJAX Requests�������������������������������������������������������������������������������������������������233 Introducing jQuery ��������������������������������������������������������������������������������������������������������236 jQuery HTML DOM Manipulation ���������������������������������������������������������������������������������������������������������240 jQuery AJAX Calls �������������������������������������������������������������������������������������������������������������������������������243 Spring MVC, AJAX, and jQuery ��������������������������������������������������������������������������������������245 Using REST-Style Remoting with JSON ����������������������������������������������������������������������������������������������246 Custom Tags �����������������������������������������������������������������������������������������������������������������250 Summary ����������������������������������������������������������������������������������������������������������������������253 Quick Quiz ��������������������������������������������������������������������������������������������������������������������253 Practical Exercise ���������������������������������������������������������������������������������������������������������254 ■ Chapter 7: Spring Web Flow ������������������������������������������������������������������������������257 What Is a Flow? ������������������������������������������������������������������������������������������������������������257 Web Flow Architecture �������������������������������������������������������������������������������������������������259 Web Flow Internal Logic �����������������������������������������������������������������������������������������������261 Configuration and Infrastructure Beans �����������������������������������������������������������������������262 Configuration Using XML ��������������������������������������������������������������������������������������������������������������������263 Configuration Using Annotations ��������������������������������������������������������������������������������������������������������267 Create a Flow ���������������������������������������������������������������������������������������������������������������272 Flow Definition ������������������������������������������������������������������������������������������������������������������������������������273 Action States ��������������������������������������������������������������������������������������������������������������������������������������304 Decision States ������������������������������������������������������������������������������������������������������������311 Exception Handling �������������������������������������������������������������������������������������������������������312 x ■ Contents Subflows ����������������������������������������������������������������������������������������������������������������������322 Flow Definition Inheritance ������������������������������������������������������������������������������������������326 Securing Web Flows �����������������������������������������������������������������������������������������������������327 Introduction to Spring Security �����������������������������������������������������������������������������������������������������������327 Why Spring Security Is Awesome �������������������������������������������������������������������������������������������������������328 Spring Security XML Configuration �����������������������������������������������������������������������������������������������������330 Spring Security Java Configuration ����������������������������������������������������������������������������������������������������343 Securing Flow Definitions �������������������������������������������������������������������������������������������������������������������350 Summary ����������������������������������������������������������������������������������������������������������������������357 Quick Quiz ��������������������������������������������������������������������������������������������������������������������358 Practical Exercise ���������������������������������������������������������������������������������������������������������364 ■ Chapter 8: Spring Boot and WebSocket �������������������������������������������������������������367 What Is Spring Boot? ����������������������������������������������������������������������������������������������������367 Usage and Configuration ����������������������������������������������������������������������������������������������368 Customizing Spring Boot ��������������������������������������������������������������������������������������������������������������������373 Importing Additional Configuration Elements �������������������������������������������������������������������������������������380 Running Spring Boot Applications ������������������������������������������������������������������������������������������������������381 Testing Spring Boot Applications ��������������������������������������������������������������������������������������������������������383 WebSocket Introduction �����������������������������������������������������������������������������������������������385 Spring WebSocket Implementation ������������������������������������������������������������������������������386 Spring WebSocket Configuration ����������������������������������������������������������������������������������390 WebSocket Client Application ���������������������������������������������������������������������������������������392 Configure the Server Application to Send Scheduled Messages ��������������������������������������������������������397 Monitoring and Debugging �����������������������������������������������������������������������������������������������������������������398 xi ■ Contents ■ A ppendix: Resources and Quiz Answers �����������������������������������������������������������403 Study Guide Projects ����������������������������������������������������������������������������������������������������401 Gradle Configuration Explained ����������������������������������������������������������������������������������������������������������403 Building and Troubleshooting �������������������������������������������������������������������������������������������������������������403 Deploy on Apache Tomcat �������������������������������������������������������������������������������������������������������������������407 Quiz Answers ����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 2 �����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 3 �����������������������������������������������������������������������������������������������������������������412 Quiz Solution for Chapter 5 �����������������������������������������������������������������������������������������������������������������413 Quiz Solution for Chapter 6 �����������������������������������������������������������������������������������������������������������������414 Quiz Solution for Chapter 7 �����������������������������������������������������������������������������������������������������������������414 Index ���������������������������������������������������������������������������������������������������������������������417 xii About the Author Iuliana Cosmina is a software engineer and professional developer. She has been programming in Java for more than 10 years. She also taught Java at the Gheorge Asachi Technical University in Iasi, Romania. She has a Bachelor’s degree in computer science and a Master’s degree in distributed systems from the same university. She discovered Spring in June 2012 and loved it so much she trained for and passed the exam to become a Certified Spring Professional in November 2012. She trained for and passed the exam to become a Certified Web Application Developer in May 2014. Her plan is to become a Spring Enterprise Integration Specialist in the near future. She has contributed to the development of different types of enterprise applications such as search engines, ERPs, track and trace, and banking. During her career in outsourcing she has been a team leader, acting software architect and a DevOps professional. She likes to share her knowledge and expertise via tutoring, teaching, and mentoring, but in the summer of 2014 everything changed because of Steve Anglin, who approached her and gave her a chance to do it by writing this guide. She lives in Sibiu, Romania and works as a software engineer for BearingPoint, a multinational management and technology consulting company. When she is not programming, she spends her time reading, travelling, hiking, or biking.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "You can find some of her personal work on her GitHub account: https://github.com/iuliana. • You can find her complete CV on her LinkedIn account: https://ro.linkedin.com/in/iulianacosmina. • You can contact her at: Iuliana.Cosmina@gmail.com. xiii About the Technical Reviewer Manuel Jordan Elera is an autodidactic developer and researcher who enjoys learning new technologies for his own experiments and creating new integrations. Manuel won the 2010 Springy Award – Community Champion and Spring Champion 2013. In his little free time, he reads the Bible and composes music on his guitar. Manuel is known as dr_pompeii. He has tech reviewed numerous books for Apress, including Pro Spring, 4th Edition (2014), Practical Spring LDAP (2013), Pro JPA 2, Second Edition (2013), and Pro Spring Security (2013). Read his thirteen detailed tutorials about many Spring technologies and contact him through his blog at http://www.manueljordanelera.blogspot.com and follow him on his Twitter account, @dr_pompeii. xv Acknowledgments Creating this guide involved a lot of teamwork. It is the first time I’ve written a technical book and I wouldn’t have made it without all the help and advice I received from Mark Powers, Matthew Moodie, and Manuel Jordan. Mark has been very supportive and shared with me his experience on book writing in order to help me and kept encouraging me when I was ready to give up on writing because I thought my work was not good enough. Matthew and Manuel have been great collaborators; I loved our exchanges of technical ideas and I am very thankful because working with them has helped me grow professionally. Many thanks to Kimberly Burton for her help turning my technical literature into human readable literature. Most of all I want to thank Steve Anglin for finding me and for trusting me to get this done. Apress has published many of the books I read and used to improve myself professionally during my studies and even after that. It is a great honor for me to write a book and publish it with Apress. It is great to contribute to the education of the next generation of developers. I am grateful to all my friends that had the patience to listen to me complain about sleep loss, having too much work to do, and writer’s block. Thank you all for being supportive and making sure I still had some fun while writing this book. And I would also like to add a very special thank you to Levi9 Romania, the company that introduced me to Spring and its country manager Nicu Lazar that supported me to become a Spring Professional. xvii Introduction Three years have passed since I wrote my first Spring project and I regret that this framework grew for ten years without me knowing about it. Four major versions of Spring have been released so far and except for the official study guide required to pass the certification exam, until the conception of this book there was no additional resource such as this. This study guide provides a complete overview of all the technologies involved in creating a Spring web application from scratch. It guides you step by step into the Spring web world covering Spring 3 and Spring 4. It also covers topics not required for the certification exam, such as Portlets and Thymeleaf, which most developers encounter while in the field. There are two multi-module projects associated with this book, covering every example presented in the book. As the book was written, new versions of Spring were released, a new version of Intellij IDEA was released, and new versions of Gradle were released. I upgraded to the new versions in order to provide the most recent information and keep this book synchronized with the official documentation. A group of reviewers has gone over the book, but if you notice any inconsistency, please send an email to editorial@apress.com and errata will be created. The example source code for this book can be found on GitHub and will be maintained, synchronized with new versions of the technologies, and enriched based on the recommendation of the developers using it to learn Spring. http://github.com/iuliana/personal-records https://github.com/iuliana/book-code I truly hope you will enjoy using this book to learn Spring as much as I enjoyed writing it. xix Chapter 1 Introduction So here you are: you want to learn how to develop web applications using Spring, and you chose this study guide to help you. This might be one of the best decisions that you could make, as this book was written not only to help you to understand Spring Web, but to love it as well. This study guide may even help you pass the certification exam—if you follow all the instructions properly and do all the exercises. This study guide explores more Spring Web topics than those required by the exam; for example, it gives you a short overview of what Spring Web is all about, which you can skip reading, of course; but if you really want to learn Spring to develop web applications like a professional, then it would be wise not to skip this. Spring and What It Does When building a project using Java, a lot of functionality needs to be built from scratch. But a lot of useful functionalities are already built and are free to use because of the open source world we live in. A long time ago, when the Java world was still quite small, you would say that you were using a library when you used open source code developed by somebody else, shipped as a *.jar file. But as time passed, the software development world evolved and the libraries grew too. They became frameworks. Because they were no longer one *.jar file that you could import, they became a collection of more-or-less decoupled libraries with different responsibilities, and you had the option to import only what you needed. Released in October 2002 as an open source framework and an inversion of control container developed using Java, Spring was built for the Java platform. It was conceived with the dependency injection software design pattern in mind, and its main purpose is to make dependency handling easier. A Java application is basically a group of objects exchanging data and influencing each other’s behavior. The Spring Framework simplified the way in which objects talk to each other and the way they depend on each other. This is why Spring evangelists claim that the reason Java was invented was so that Spring would come into existence one day. The development of Java applications became easier when Spring emerged, providing comprehensive infrastructure support. Spring makes it easier to compose disparate components into a fully working application. Spring comes with a lot of default behaviors already implemented (components called infrastructure beans are a default configuration; they can be used to create functional basic applications without extra customization), because the Spring Framework was also built with the convention over configuration paradigm as a principle, which seeks to decrease the number of decisions a developer has to make when writing code, but also makes it easier for the developer to customize the behavior of objects, offering increased flexibility. 1 Chapter 1 ■ IntroduCtIon Spring is currently the VIP of Java frameworks and it has been growing exponentially, especially since 2009, when VMware acquired SpringSource, the company behind Spring. The merger of VMware and the EMC Corporation in April 2013, now known as Pivotal, was also advantageous for Spring, as it became one of Pivotal’s central elements in its strategy to provide innovative and modern software-driven experiences to its customers. Spring is now a full-blown technology that can be used to build enterprise-ready applications in a very short time, and it comes in 25 flavors.1 Figure 1-1 shows a diagram of all Spring-released projects. The following list describes these projects. Figure 1-1. Official Spring projects. The projects drawn with dotted lines are only partially covered in this book or are featured in the source code • Spring Framework provides core support for dependency injection, transaction management, web applications, data access, messaging, and more. • Spring IO provides a cohesive, versioned platform for building modern applications. It is a modular, enterprise-grade distribution that delivers a curated set of dependencies. • Spring Boot provides compact setups for different types of applications, helping you to focus on your code instead of infrastructure configuration. • Spring XD simplifies the development of Big Data applications. 1You can read about these projects, as well as other projects that have not been released officially (Spring Session, for example) in detail at http://spring.io/projects. 2 Chapter 1 ■ IntroduCtIon • Spring Cloud provides a set of tools for distributed applications. • Spring Data provides a consistent approach to data access. (This study guide uses a subproject called Spring Data JPA to help us manage data easily.) • Spring Integration supports the well-known Enterprise Integration Patterns via lightweight messaging and declarative adapters. • Spring Batch simplifies and optimizes the work of processing high-volume batch operations. • Spring Security provides tools for authentication and authorization. (Because web security is one of the subjects of the certification exam, there is a section about web security in this study guide that you will have to pay close attention to.) • Spring HATEOAS provides some APIs to help the development of REST representations that follow the HATEOAS principle (Hypermedia as the Engine of Application State, which means that a client interacts with a network application entirely through hypermedia provided dynamically by application servers). • Spring Social provides an API to connect Spring applications to the third-party APIs of social networks like Facebook and Twitter, as well as others. • Spring AMQP provides an API for AMQP-based messaging solutions. • Spring Mobile simplifies the development of mobile applications. • Spring for Android provides key spring components to use in the development of Android applications. • Spring Web Flow supports the building of web application with controlled navigation (Spring Web Flow is another subject in the certification exam.) • Spring Web Services facilitates the development of SOAP-based applications. • Spring LDAP provides tools to develop LDAP applications. • Grails2 is a powerful open source web framework based on Groovy and inspired by Ruby on Rails. It is used to create web applications that run on the Java Virtual Machine(JVM). • Groovy3 started as a dynamic language for the Java platform. It brings high-productivity development features to the JVM, and resembles Python, Ruby, Perl, and Smalltalk in regards to syntax and features. SpringSource has taken over its development and maintenance. • Spring Scala mixed up Spring with Scala language features. • Spring Roo helps define application templates that can be built into a full Java application within minutes. • Spring BlazeDS Integration tools integrate Spring with Adobe BlazeDS. • Spring Loaded reloads classes as files change, boosting productivity (similar project to JRebel). 2Pivotal decided to stop funding this project in March 2015. 3Funding for this project also ended in March 2015. 3 Chapter 1 ■ IntroduCtIon • Spring Shell provides the capability to build command-line apps. • REST Shell makes the writing and testing of RESTful application easier with CLI-based resource discovery and interaction. The Focus of this Study Guide As this study guide is being written, the Spring Framework consists of features organized into about 20 modules grouped into the following: Core Container, Data Access/Integration, Web, AOP (aspect-oriented programming), Instrumentation, Messaging, and Test. The topics covered in this study guide are Spring Framework’s support components for the presentation tier (and specifically web-based presentation tiers). A bonus in this book is the Spring WebSocket chapter, which was added to the Spring Framework in version 4 and is also an optional part of the official Spring Web course not featured in the certification exam. In the Figure 1-2 you can see the Spring MVC stack, a tiered representation of the modules commonly used to create Spring web applications. Figure 1-2. The Spring Web Stack (those with dotted lines will not be covered in this study guide) This study guide focuses on helping developers understand how Spring’s web infrastructure is designed, and how to write Spring web applications in a few easy steps by maximizing Spring’s potential. The study guide’s objectives are as follows: • Use Spring to develop web applications • Use Spring Web Flow to implement stateful interactions • Use Spring Security to secure web applications • Use Spring Test and other test frameworks (JUnit, JMock) to test web applications • Create Spring web applications using Gradle4 4Gradle is an automated build tool that is easy to configure and use on any type of application. Its build files are written using JSON and Groovy. Gradle combines the power and flexibility of Ant with the dependency management and conventions of Maven into a more effective way to build. Read more about it at https://www.gradle.org. 4 Chapter 1 ■ IntroduCtIon Who Should Use this Study Guide This study guide is designed to help any Spring developer become familiar and comfortable with Spring-associated technologies for web development. It can also be a big help to a developer who wants to become a Certified Spring Web Application Developer.5 That is why every topic in the official VMware Spring Web study guide is given the attention that it deserves. You do not have to be a Certified Spring Professional to use this study guide; you just need minimal knowledge of Spring. Because this study guide has a full chapter dedicated to the Spring core components, it might be possible for a non-Spring developer to use this study guide too, but the Spring Framework Reference6 official documentation should be consulted to retrieve any missing pieces of information. In a nutshell, this study guide was written to be used by the following audiences: • Spring Core developers who want a taste of Spring Web • Spring developers (Certified Spring Professionals or not) who are looking forward to becoming Certified Spring Web Application Developers • Java developers who are curious about working with Spring technologies and want to start fast About the Spring Web Certification Exam If you are interested in becoming a Certified Spring Web Application Developer, the first step is to go to the VMware official learning site (http://pivotal.io/training) and search for the Spring Certification section. There you will find all the details you need regarding the official trainings, including where and when they take place. The training is four days long. There is online training available as well. After creating an account on the VMware site, you can select your desired training. After you make the payment, if you choose an online training, after about a month you will receive (through the mail) an official training kit that consists of the following: • A pair of conference headphones (usually Logitech) to be used during training to hear your trainer talk and to ask questions.7 • A professional webcam (usually Logitech) to be used during training so that your trainer and colleagues can see you, thus simulating a classroom experience.8 • A Spring study guide book containing the printed version of the slides your tutor will use during training. • A Spring study lab book containing explanations and instructions for the practical exercises you will do during training. • A SpringSource official flash drive containing the following: • A JDK installer. 5Keep in mind that attending a Spring Web training course by Pivotal or at a VMware Authorized Training Center is a prerequisite to becoming a Certified Spring Web Application Developer, as stated on the official site at http://mylearn.vmware.com/mgrReg/plan.cfm?",
    "answer": "plan=31111 ui=www_cert. 6The Spring Framework Reference is at http://docs.spring.io/spring/docs/current/ spring-framework-reference/htmlsingle/. 7Depending on the area and the training center, this item is optional. 8Depending on the area and the training center, this item is also optional. 5",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Sources necessary for your training. Each study lab has a small Spring web application with missing configuration and code; the student’s task is to complete it to become a working application. The same model is used in the code associated with this book. • An installer for the most recent stable version of the Spring Tool Suite (STS). The version on the flash drive is mandatory for the course because the installer sets up a local Maven repository with all the needed dependencies, and a full eclipse project configuration with the lab sources. The STS also has an internal tc Server to run the lab applications. • An HTML or PDF version of the Spring Study Lab. If you do not choose to do online training, you will not receive the headphones nor the webcam. The training kit and the rest of the materials are given to you when you arrive at the location where the training is taking place. After your training, you receive a free voucher that is required to schedule the certification exam at an approved exam center near you. Basically, this voucher or voucher code is proof that you have attended official Spring Web training. ! The exam duration is 90 minutes and consists of 50 questions. There are both single-answer and multiple-choice questions. The questions cover (roughly) the following topics: • Spring overview (Spring core notions) • MVC essentials (configurations, beans to use, conventions) • MVC forms and views • Webflow • Web security • REST The passing score for the exam is 76%. This means that 38 correct answers are needed to pass. Most of the questions present you with a piece of Java code or configuration and then ask you what it does, so make sure that you understand the code attached to this book and write your own beans and configurations in order to understand the framework better. The good news is that all the code in the exam can be found in the sources that you are given while attending the official training. Other questions present you with affirmations about Spring Web and require you to select the correct or the invalid ones. If you read this book, understand all the examples, solve the practice exercises, and then attend the official training, the recommendation is to take the certification exam as soon as possible afterward. Do not allow too much time to pass between finishing the training and taking the exam, because we are all human after all, and information can be forgotten. Also, the certification voucher is only valid for a year. You can retake the exam if you fail the first time, but it will cost you ~$150. How to Use this Study Guide This study guide follows the same path as the official Spring Web training, and focuses on the topics that are found in the certification exam; but there are a few differences, which are mentioned from now on. This Spring study guide covers the Spring MVC Portlets. This topic is not in the exam, but you never know when you may need them in your development career, so it is better to have an overview. The other differences are related to the tools used for the practical examples, which are mentioned in the next section. 6 Chapter 1 ■ IntroduCtIon How this Book Is Structured This study guide has eight chapters. You might think: How is this possible—the official Spring study guide has sixteen chapters, right?",
    "answer": "It is better to wrap related things together, so in this study guide you have two big",
    "source": "extracted",
    "confidence": 0.85
  },
  {
    "question": "Basics • Configuration • Components • Summary • Quick quiz • Practical exercise 7 Chapter 1 ■ IntroduCtIon Conventions ! This symbol appears in front of paragraphs that you should pay particular attention to. ** This symbol appears in front of a paragraph that is an observation or an execution step that you can skip. ?",
    "answer": "This symbol appears in front of a question for the user. ... This symbol replaces missing code that is not relevant in the example. CC This symbol appears in front of a paragraph that describes a convention over configuration practice in Spring, a default behavior that helps a developer reduce his or her work. [random text here] Text surrounded by square brackets means that the text within the brackets should be replaced by a context-related notion. Downloading the Code This study guide comes with code examples and practical exercises. There will be missing pieces of code that you will have to fill in to make applications work and to test your understanding of Spring Web. It is recommended that you go over the code samples and do the exercises, as similar pieces of code and configurations will appear in the certification exam. The following downloads are available:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Source code for the programming examples in the book chapters • Source code for the programming examples in the practice section You can download these items from the Source Code area of the Apress web site (www.apress.com). Contacting the Author More information on Iuliana Cosmina can be found at http://ro.linkedin.com/in/iulianacosmina. She can be reached at iuliana.cosmina@gmail.com. Follow her personal coding activity at https://github.com/iuliana. Recommended Development Environment If you decide to attend the official course, you will notice that the development environment recommended in this book differs quite a lot from the one used for the course—a different editor is recommended, and a different application server, and even a different build tool. The reason for this is to improve and expand your experience as a developer and to offer a practical development infrastructure. Motivation for each choice is mentioned in the corresponding sections. 8 Chapter 1 ■ IntroduCtIon Recommended Build Tools The recommended development environment should be composed of the following technologies: Java 8. Download and install the JDK matching your operating system from http://www.oracle.com. ! It is recommended to set the JAVA_HOME environment variable to point to the directory where Java 8 is installed (the directory in which the JDK was unpacked) and add $JAVA_HOME/bin to the general path of the system. The reason behind this is to ensure that any other development application written in Java will use this version of Java, and prevent strange incompatibility errors during development. ! Verify that the version of Java that your operating system sees is the one you just installed. Open a terminal (Command+Prompt in Windows, or any type of terminal you have installed on Mac OS or Linux) and type the following: java -version You should see something similar to this: java version \"1.8.0_40\" Java(TM) SE Runtime Environment (build 1.8.0_40) Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode) Grade 2.x ** The sources attached to this book can be compiled and executed using the Gradle Wrapper, which is a batch script on Windows, or by using a shell script on other operating systems. When you start a Gradle build via the wrapper, Gradle is automatically downloaded and used to run the build, thus you do to need to install Gradle as stated previously. Instructions on how to do this can be found on the public documentation at www.gradle.org/docs/current/userguide/gradle_wrapper.html. It is a good practice to keep code and build tools separate, but this study guide uses the Wrapper to easily set up the practice environment by skipping the Gradle installation step, and also because the recommended source code editor uses the Wrapper internally. If you decide to use Gradle outside the editor, you can download the binaries only (or, if you are more curious, you can download the full package, which contains binaries, sources, and documentation) from the official site (https://www.gradle.org), unpack it and copy the contents somewhere on the hard drive. Create a GRADLE_HOME environment variable and point it to the location where you have unpacked Gradle. Also add $GRADLE_HOME/bin to the general path of the system. Gradle was chosen as a build tool for the sources of this book because of the easy setup, small configuration files, flexibility in defining execution tasks, and the fact that the SpringSource team currently uses it to build all Spring projects. 9 Chapter 1 ■ IntroduCtIon ! Verify that the version of Gradle that your operating system sees is the one that you just installed. Open a terminal (Command+Prompt in Windows, any type of terminal you have installed on Mac OS or Linux) and type gradle –version. You should see something similar to this: ------------------------------------------------------------ Gradle 2.3 ------------------------------------------------------------ Build time: 2014-11-24 09:45:35 UTC Build number: none Revision: 6fcb59c06f43a4e6b1bcb401f7686a8601a1fb4a Groovy: 2.3.9 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 JVM: 1.8.0_40 (Oracle Corporation 25.25-b02) OS: -- whatever operating system you have -- The preceding text shows a confirmation that any Gradle command can be executed in your terminal; Gradle was installed successfully. Jetty 9 is an open source web server that is free to use and easy to install; that’s why it was chosen to be used in this study guide instead of the SpringSource tc Server. No need to download and install this web server, though, because there is no need to. There is a Gradle plugin called Getty that will be used to download the Jetty web server and deploy your *.war artifact on it. If you want to read more about Jetty, you can do so at http://eclipse.org/jetty/. Recommended IDE The recommended IDE to use in this study guide is Intellij IDEA. The reason for this is that it is the most intelligent Java IDE. IntelliJ IDEA offers outstanding framework-specific coding assistance and productivity-boosting features for Java EE. Spring also includes support for Maven and Gradle. It is the perfect choice to help you focus on learning Spring, rather than how to use an IDE. It can be downloaded from the JetBrains official site (https://www.jetbrains.com/idea/). It is also quite light on your operating system and quite easy to use. 10 Chapter 1 ■ IntroduCtIon Because the web applications developed as practice in this study guide are deployed on Jetty, the community edition of Intellij IDEA can be used because we do not need the server plugin. The main disadvantage of the community edition, though, is that it does not come with the Spring plugin, which is very useful in creating Spring configuration files because it adds the bean namespace by default. But solving the exercises in this book won’t require that, so you can still consider IDEA an option. If you are curious about the full power of this IDE, you can download the Ultimate Edition, which has a trial period of 30 days. And you can even try to deploy the code samples on a Tomcat instance from within IDEA. You will find an example of how to do this in the appendix. If you are already familiar with a different Java editor, you can use it—as long as it supports Gradle. The Project Sample Most of the code used in this study guide, except the book code modules, makes up a project named Personal Records Manager. This is a proof of concept application that aspires to manage the personal information of a group of people. The application is multimodular and each module is duplicated. The projects suffixed with practice are missing pieces of code and configuration, and are the ones that need to be solved by you to test your understanding of Spring Web. The projects suffixed with solution are proposal resolutions for the tasks. You can see the project structure and the modules in Figure 1-3. 11 Chapter 1 ■ IntroduCtIon Figure 1-3. The Personal Records Manager Application diagram 12 Chapter 1 ■ IntroduCtIon The foundation module is the 00-pr-dao, which handles all database operations by using Hibernate and Spring Data JPA. All other modules are client web applications, which will help the end user introduce new data, modify existing data, and perform searches. Each module is specific to a part of a chapter. Each module name is prefixed with a number, so no matter what IDE you use, you will always have the modules in the exact order that they were intended to be used. The general functionality of each web application is described in Figure 1-4. Figure 1-4. The Personal Records Manager Application structure The foundation of this application is its DAO (data access objects) module, which contains entities classes that are mapped on database tables, and classes used to handle entities, called repositories. The web projects use the DAO project to manipulate data according to user requests. The UML diagram in Figure 1-5 describes the general behavior of our application. In some chapters, however, diagrams that describe a more detailed behavior are presented. 13 Chapter 1 ■ IntroduCtIon Figure 1-5. UML diagram describing the general behavior of the application The entities have common fields used by Hibernate to uniquely identify each entity instance (id) and the fields used to audit each entity instance (createdAt and modifiedAt) and keep track of how many times an entity was modified (version). These fields have been grouped in the AbstractEntity class to avoid having duplicated code. The class hierarchy can be analyzed in Figure 1-6. 14 Chapter 1 ■ IntroduCtIon Figure 1-6. This diagram shows the relationships between entity classes and the relationships between tables in the database. (The pnc is a personal numerical code that uniquely identifies a person and will be used to test some Spring validations on it. The iban is an alphanumeric code that uniquely identifies a bank account.) This chapter does not have any practice and sample code attached to it, so more information regarding the setup of the project, and how it is built and executed, is provided in upcoming chapters. 15 Chapter 2 Spring Fundamentals This chapter is necessary for building a Spring background, which will be very helpful in the upcoming chapters. This chapter will help you get familiar with the Spring container, context, beans, and most Spring core modules and how they work together to allow developers to focus on solving problems instead of building up support. The Basics Any application system is made of components that work together to solve a problem. In object- oriented design they are called classes. Figure 2-1 depicts the sequence of operations necessary to create a Person instance. Because this chapter is about Spring Core, a web application is not needed, so requests to manipulate Person instances will be directed to implementations of the PersonManager interface. Implementations of this interface will provide access to the database using an implementation of PersonRepository interface. The operation is pretty simple and the setup to write and execute the code should be too. This is where Spring comes in—providing a way to build an application using plain old Java objects (POJOs)1 and applying enterprise services (transaction execution, remote execution) noninvasively. 1A software term introduced by Martin Fowler, Rebecca Parsons, and Josh MacKenzie in September 2000 to refer to ordinary Java objects not bound by any restriction. 17 Chapter 2 ■ Spring FundamentalS Figure 2-1. UML sequence of operations necessary to create a Person instance The components making up an application interact and depend on one another. Defining how these objects are composed is quite difficult using plain Java. Even with the help of all the design patterns defined by experts in the software industry, the work is still cumbersome, as the pattern components still have to be implemented before being used. The Spring inversion of control (IoC) container was designed to help developers compose objects into fully working applications, ready to use.2 The Spring container is responsible for the creation of components, resolving their dependencies and providing them to other components. It does this by reading the configuration of an application from *.xml files or annotated configuration classes, and internally constructs a graph of dependencies between the objects. It then proceeds to traverse the graph, and creates and injects dependencies according to the configuration. The result of this initialization is an ApplicationContext, which provides access to application components, resource loading, internationalization support, and other features that won’t be mentioned in this guide because it is out of scope.3 Figure 2-2 depicts the process of creating an ApplicationContext using the Spring IoC container. 2The process through which an object is provided its dependencies, whether it is using a constructor or properties which are set using setter methods, is called dependency injection. inversion of control is the concept through which an external component has control over what is provided as a dependency to an object. 3For more information, see the public reference documentation at http://docs.spring.io/spring/docs/current/ spring-framework-reference. 18 Chapter 2 ■ Spring FundamentalS Figure 2-2. How Spring works The Spring Core Container The Spring core container is made of the following modules: • spring-beans • spring-core • spring-context and spring-context-support (provides support classes that help integration of third-party libraries for caching, mailing, scheduling, and template engines) • spring-expression The spring-core and spring-beans modules provide the fundamental part of the framework: the IoC and dependency injection features, which the container needs to solve and inject dependencies as specified in the configuration. The spring-context module extends the previous two modules, adding support for internationalization, resource loading, event propagation, and transparent creation of contexts. The core component of this module is the ApplicationContext interface. The spring-expression module provides a powerful Expression Language for querying and manipulating an object graph at runtime, and for operations like setting and getting property values, property assignment, and others. 19 Chapter 2 ■ Spring FundamentalS Considering the diagram in Figure 2-1, the classes needed to support implementing the operation to save a Person instance look like this: public class PlainPersonManagerImpl implements PersonManager { PersonRepository repo; //injecting a dependency using the constructor public PlainPersonManagerImpl(PersonRepository repo) { this.repo = repo; } ... } public class PlainPersonRepository implements PersonRepository { private DataSource dataSource; @Override public int save(Person person) { .. } //injecting a dependency using a setter method public void setDataSource(DataSource dataSource) { this.dataSource = dataSource; } } ■ ! the PlainPersonRepository class is a simple pOJO persistence handler. its sole responsibility is to ensure Person instances are saved and retrieved from the database. its behavior is built on a javax.sql.DataSource implementation. this is different from the Spring data Jpa repositories used in the personal records manager project, which will be presented later. the approach specific to this chapter is Spring Core–based, which is more “old-style,” before Spring data Jpa existed; this is to best introduce the Spring core modules and possibilities. To implement that functionality in plain Java language, you have to write something like this: PersonRepository repo = new PlainPersonRepository(); DataSource dataSource = new com.oracle.jdbc.pool.OracleDataSource(); dataSource.setUrl(\"jdbc:oracle:thin:@localhost:1521:orcl\"); //set other dataSource properties ... repo.setDataSource(dataSource); PersonManager personManager = new PlainPersonManagerImpl(repo); Person person = new Person(\"John\", \"Smith\",\"1980-04-13\"); // Use the manager personManager.save(person); As you can easily see, except the last line, everything else is setup code—the preparation before the execution of the method. It is a lot of code. What would happen if you decided to change method signatures or to use a different DataSource implementation?",
    "answer": "A big part of this code would have to be changed too. In the next section, let’s see how Spring does the same thing. 20",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Special XML configuration files that allow usage of elements described in the associated namespaces • Java-based configuration classes (classes annotated with @Configuration can be used by Spring IoC as a source for bean definitions) • Mixed configuration: XML and annotations All three types of configurations are covered in the following sections. The code sources attached to this chapter will help you test your understanding of each. XML The following code is the XML content of a file named app-simple-config.xml, which is the configuration file for a simple Spring application: <beans> <bean id=\"personManager\" class=\"com.book.plain.PlainPersonManagerImpl\"> <constructor-arg ref=\"personRepository\" /> </bean> <bean id=\"personRepository\" class=\"com.book.plain.PlainPersonRepository\"> <property name=\"dataSource\" ref=\"dataSource\" /> </bean> <bean id=\"dataSource\" class=\"com.oracle.jdbc.pool.OracleDataSource\"> <property name=\"URL\" value=\"jdbc:oracle:thin:@localhost:1521:orcl\" /> ... </bean> </beans> And here is how the code to save a Person instance looks with Spring: // Create the application from the configuration ApplicationContext context = new ClassPathXmlApplicationContext(\"app-simple-config.xml\"); // Look up the application manager interface PersonManager manager = (PersonManager) context.getBean(\"personManager\"); // Use the manager manager.save(new Person(\"John\", \"Smith\",\"1980-04-13\")); As you can see, the code is a lot smaller, because all the preparation of the environment was moved into the XML configuration file. And the configuration file can be manipulated more easily. If an external property file is used as entry for some of the values in it, in some simple cases, the application doesn’t even have to be recompiled to change behavior. The DataSource configuration can be separated from the general configuration file, which can later allow you to easily switch between DataSource implementations—depending on the context in which a code should run. 21 Chapter 2 ■ Spring FundamentalS <util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/> <bean id=\"dataSource\" class= \"org.springframework.jdbc.datasource.DriverManagerDataSource\"> <property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/> <property name=\"url\" value=\"#{dbProp.url}\"/> <property name=\"username\" value=\"#{dbProp.username}\"/> <property name=\"password\" value=\"#{dbProp.password}\"/> </bean> In the previous example, the property values that look like #{value} are loaded from the db.properties file, which contains the following: driverClassName=org.h2.Driver url=jdbc:h2: ~/prod username=prod password=prod The values for the properties are loaded into a java.util.Properties instance with an id of dbProp using a functionality offered by the util namespace in the first line of the configuration, and then their values are accessed using the SpEL (Spring Expression Language) syntax and injected into the dataSource bean. (There is another way to do this using a component named PropertyPlaceholderConfigurer, which is covered in the “How Bean Factory Post Processors Work” section.) Spring knows how to do this because configuration files are constructed using XML namespaces. <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> ... </beans> The underlined values in the previous example show how a prefix is assigned to a namespace and how a namespace is associated with an XSD schema that contains the XML elements that can be used in the configuration file. Usually, each namespace contains definitions for all XML tags for a specific spring module, or a group of tags with related responsibilities. As everything in Spring is a bean, most commonly used configuration styles use the bean’s root element, and the namespace for it is declared using the xmlns attribute. When additional namespaces are used, the elements defined by them need to be used inside the current element (beans). They need to have a prefix associated so that the Spring IoC knows in which namespace to look for those element definitions; notations such as xmlns:[prefix]=\"[namespace URL]\" are used. 22 Chapter 2 ■ Spring FundamentalS ■ ! the running code in this example can be found in 02-chapter-solution project. this is a module of the book-code project, which was designed to gradually test your knowledge acquired while reading this book. the book-code contains one or more modules for each chapter. Some module names are postfixed with -practice and contain a series of TODO tasks that the developer should be able to complete after reading a chapter. the modules prefixed with -solution contain the completed tasks and are meant to be used for comparison with the developer’s own solution. Sometimes a solution module might contain extra code that is meant simply to show the developer other situations that he might encounter in Spring projects. For example, by splitting up the configuration file to isolate the DataSource configuration, you could have the following configuration for a production environment: ApplicationContext context = new ClassPathXmlApplicationContext(\"application-config.xml\",\"db-config.xml\"); And this configuration could be for a test environment: ApplicationContext context = new ClassPathXmlApplicationContext(\"application-config.xml\",\"test-db-config.xml\"); The two environments are completely decoupled, and the tests are very easy to write. Figure 2-3 displays a typical structure for a Spring Maven project with a split configuration for production and a test environment. Figure 2-3. Typical Maven structure for a project 23 Chapter 2 ■ Spring FundamentalS ■ ! in this example, the configuration files were created under a directory named spring to emphasize that these are Spring configuration files, because in a more complex project there could be Xml configuration files for other purposes (for example, logging or caching stored outside of the spring directory). the code in this book intentionally skips the spring directory from the path to reduce the size of the quotes and to make the list of configuration files more readable. In the configuration files, and when instantiating contexts, resources are usually prefixed with a word that tells the Spring container where they are located. These prefixes can be used for any type of resources needed in an application. Consider a standard Maven setup for a project like the one in Figure 2-3; Table 2-1 shows the paths where a Spring container would look for resource files depending on the prefix. Table 2-1. Prefixes and Corresponding Paths Prefix Location Comment no prefix In root directory where the class In the main or test directory. The type of the resource creating the context is executed. being loaded depends on the ApplicationContext instance being used. (A detailed example is presented after this table.) classpath: The resource should be obtained In the resources directory; the resource is of type from the classpath. ClassPathResource. file: In the absolute location following The resource is loaded as a URL from the filesystem the prefix. and is of type UrlResource. http: In the web location following The resource is loaded as a URL and is of type the prefix. UrlResource. The following is an example of resource loading without using a prefix: Resource template = ctx.getResource(\"application-config.xml\"); Depending on the context class used, the resource loaded can have one of the following types: • If ctx is a ClassPathXmlApplicationContext instance, the resource type is ClassPathResource • If ctx is a FileSystemXmlApplicationContext instance, the resource type is FileSystemResource • If ctx is a WebApplicationContext instance, the resource type is ServletContextResource 24 Chapter 2 ■ Spring FundamentalS Annotations Spring also supports configuration via annotations. The previous XML configuration can be replaced by a class annotated with @Configuration, and looks like this: @Configuration @PropertySource(value = \"classpath:datasource/db.properties\") public class AppConfig { @Autowired Environment env; @Bean(name=\"personManager\") public PersonManager getPersonManager(){ return new PlainPersonManagerImpl(getPersonRepository()); } @Bean(name=\"personRepository\") public PersonRepository getPersonRepository(){ PersonRepository repo = new PlainPersonRepository(); repo.setDataSource(getDataSource()); return repo; } @Bean(name=\"dataSource\") public DataSource getDataSource(){ DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(env.getProperty(\"driverClassName\")); dataSource.setUrl(env.getProperty(\"url\")); dataSource.setUsername(env.getProperty(\"username\")); dataSource.setPassword(env.getProperty(\"password\")); return dataSource; } } All the code to save a Person instance looks like this: @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {AppConfig.class}) public class SecondAnnotationPersonSaveTest { @Autowired PersonManager personManager; @Test public void savePerson() { personManager.save(new Person(\"John\", \"Smith\", \"1980-04-13\")); } } 25 Chapter 2 ■ Spring FundamentalS When annotations are used, XML configuration files are no longer needed, nor namespaces. Specific annotations are used to mark configuration classes (@Configuration) and to mark methods as bean definitions (@Bean); this is not covered because it is outside the scope of this book. What you need to remember is that the @Bean annotation makes sure that every time the annotated method is called the same bean is returned. Without it, the method will return a newly created instance each time. ■ CC in the previous code example, each @Bean annotation has the attribute name populated with a value to name the bean created by the method. this attribute is neither mandatory nor necessary. When it is not specified, the Spring ioC determines a name for the bean based on the method name by removing the get and lowercasing the first letter of the remaining string. Mixed Approach XML and annotations can be mixed. You could have the bean classes annotated with @Component (or any annotation extending @Repository for DAO repository classes, @Service for service classes, or @Controller for MVC handler classes) and one or more XML files, which define just the DataSource configuration and specifies where the beans are located. In the following code sample, the DataSource configuration is separated in another file (as shown in the “How Bean Factory Post Processors Work” section) to decouple configurations for production and test environments. <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\" <context:component-scan base-package=\"com.book.beans\"/> ... </beans> In XML configuration files, bean definitions describe the way a dependency should be provided to them: using either constructors or setters. This is called autowiring. When using annotations, the way a dependency should be provided is described using the @Autowire annotation on a constructor or setter.4 But you need to tell the Spring IoC container to look for that type of annotation, and the declaration <context:component-scan ...> does exactly that. When using annotations, <bean> declarations are no longer needed because each bean type is annotated with @Component, or an extension of it, and the <context:component-scan..> declaration tell the Spring IoC container to look for those types of annotations in the specific file. The process of identifying annotated bean types is called autodiscovery. 4The @Autowiring annotation can also be used on the field directly, called field injection; but this approach is discouraged because it makes testing difficult. As the field is usually private, to test the containing bean, a full Spring context must be set up or reflection must be used to access the field. 26 Chapter 2 ■ Spring FundamentalS Thus what the following configuration element does is enable bean autowiring and autodiscovery anywhere in the classpath in packages (and subpackages) named as the value of the attribute base-package. <context:component-scan base-package=\"com.book.beans\"/> The <context: ..> declarations are Spring’s way of compacting the declaration of infrastructure beans named *PostProcessor, which take care of interpreting annotations into beans definitions. • <context:annotation-config/> registers the following: – AutowiredAnnotationBeanPostProcessor (supports @Autowired, @Value, @Inject) – CommonAnnotationBeanPostProcessor (supports @Resource, @PostConstruct, @PreDestroy) – PersistenceAnnotationBeanPostProcessor (supports @PersistenceUnit, @PersistenceContext) – RequiredAnnotationBeanPostProcessor (supports @Required) • <context:component-scan base-package=\"com.book.beans\"/> implicitly enables the functionality of <context:annotation-config> and adds support for more annotations (@Repository, @Service, @Controller, which are specializations of @Component, @Configuration, etc.) If you want to extend your knowledge about this, you can always read the Spring Reference Documentation.5 More detailed information is outside the scope of this book. The Beans The beans are the objects handled by the Spring IoC container. The following section will cover all you need to know about how beans are created, how the beans are categorized, how they are accessed, and how they are destroyed when they are no longer needed. Lifecycle and Instantiation The beans are created in order of dependency. If a bean of type B, needs a bean of type A for its creation, the Spring container will know to first create bean A and then inject it into bean B. If an application has multiple configuration files, the Spring container first reads all of them, internally creates a dependency tree of bean definitions, and then starts traversing the tree, starting with its lowest level where the simplest bean definitions are. In the cases mentioned in previous sections, the order for bean creation (instantiation) is dataSource, personRepository, and personManager. The steps are described in Figure 2-4. 5The Spring Reference Documentation can be accessed at http://docs.spring.io/spring/docs/current/ spring-framework-reference/htmlsingle/. 27 Chapter 2 ■ Spring FundamentalS Figure 2-4. Order of bean instantiation A bean cannot be created if its required dependencies do not exist; an exception is thrown in case of missing dependencies. But how does the Spring container know which dependencies are required?",
    "answer": "There are a few ways. One is the type of injection. Spring supports two types of injection: via constructor and via setter. The constructor injection is when the constructor of a bean is defined as having an argument of type another bean. In the previous example, the PersonManagerImpl constructor definition requires a PersonRepository instance as an argument, and thus the PersonManagerImpl requires a bean of type PersonRepository to be created before its creation. <!– Constructor injection –> <bean id=\"personManager\" class=\"com.book.PersonManagerImpl\"> <constructor-arg ref=\"personRepository\" /> </bean> <!– Setter injection–> <bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\"> <property name=\"dataSource\" ref=\"dataSource\" /> </bean> 28",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "By annotating the setter method with @Required. If the property is not set, a BeanInitializationException is thrown. • By annotating the setter method with @Autowire the Spring IoC container tries to inject a bean with the specific type. If such a bean is not found, a BeanCreationException is thrown. One of the advantages of using the setter injection is that you can create hierarchical beans, and setters will be inherited. In a setter injection, bean creation and dependency injection are two separate steps; for constructor injection there is only one step. So basically, setter injection makes your configuration more flexible. For a bean to “come to life” and become available to be used for a purpose, it has to go through the steps shown in Figure 2-5. Figure 2-5. The steps for a bean creation 29 Chapter 2 ■ Spring FundamentalS How Bean Factory Post Processors Work A bean definition can be modified before instantiating the bean, and this is done by beans called bean factory post processors. They are defined as classes implementing the BeanFactoryPostProcessor interface and are recognized by an application context and instantiated before any other beans in the container. The most used and known in the Spring world is the PropertyPlaceholderConfigurer. <bean id=\"dataSource\" class= \"o.s.jdbc.datasource.DriverManagerDataSource\"> <property name=\"driverClassName\" value=\"${driverClassName}\"/> <property name=\"url\" value=\"${url}\"/> <property name=\"username\" value=\"${username}\"/> <property name=\"password\" value=\"${password}\"/> </bean> <context:property-placeholder location=\"classpath:datasource/db.properties\"/> The last line in this example is a simplified version of defining a PropertyPlaceholderConfigurer using the Spring context namespace; it is equivalent to the following: <bean class= \"o.s.beans.factory.config.PropertyPlaceholderConfigurer\"> <property name=\"location\" value=\"classpath:datasource/db.properties\"/> </bean> This bean reads those properties from the db.properties file and then populates the dataSource source bean with their values. Of course, the easier way to do this is to use SpEL expressions and the util namespace: <util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/> <bean id=\"dataSource\" class= \"o.s.jdbc.datasource.DriverManagerDataSource\"> <property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/> <property name=\"url\" value=\"#{dbProp.url}\"/> <property name=\"username\" value=\"#{dbProp.username}\"/> <property name=\"password\" value=\"#{dbProp.password}\"/> </bean> Bean Initialization and Destruction An ApplicationContext instantiates all singleton (bean scopes are covered in detail in the “Bean Scopes” section) beans by default and also destroys them at the end of their lives. After a bean has been created and its dependencies injected, it can be initialized automatically by telling the context to execute a specified method. Before a bean ends its life, a different method might be called to do some resource cleanup. The context can be told to automatically do that too. These methods must have a void no-argument signature. There is no restriction on the accessor used for them. In the official documentation, the lifecycle methods given as example are all public. But there are opinions that state they should be protected or private (obviously, it does not apply to InitializingBean’s afterPropertiesSet and DisposableBean’s destroy) to prevent direct calls of these methods from the application code, as these methods should be called only once and only by the Spring IoC container. 30 Chapter 2 ■ Spring FundamentalS There are multiple options for bean initialization: • Using @PostConstruct from JSR 250 • Using @Bean’s initMethod attribute • Implementing InitializingBean and providing implementation for the afterPropertiesSet method (not recommended because it couples the application code with Spring infrastructure code) • Using the init-method attribute on a <bean/> XML definition When a bean ends its life, some cleanup operations might be necessary; to implement this kind of behavior, there are also multiple options: • Using @PreDestroy from JSR 250 • Using @Bean’s destroyMethod attribute • Implementing DisposableBean and providing implementation for the destroy method (not recommended, as it couples the application code with Spring infrastructure code) • Using the destroy-method attribute on a <bean/> XML definition In the code sample there is a bean in the com.book.spring.components package that was implemented in such a way to clarify the Spring bean lifecycle. The bean is called CompleteLivingBean and has @PostConstruct and @PreDestroy annotated methods, implements InitializingBean and DisposableBean, and has methods in which names are used as values for attributes init-method and destroy-method. This bean was implemented using a combined lifecycle strategy to clearly show when each initializer/destruction method is called by the Spring IoC and to clearly display the bean creation steps in Figure 2-5. This is the configuration: <context:component-scan base-package=\"com.book.beans\"/> <bean id=\"livingBean\" class=\"com.book.beans.CompleteLivingBean\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"> <property name=\"internal\" value=\"testValue\"/> </bean> This is the definition of the bean class: public class CompleteLivingBean implements InitializingBean, DisposableBean { public String internal; public CompleteLivingBean() { logger.info(\"1. Constructor.\"); } public void setInternal(String internal) { logger.info(\"2. Setter.\"); this.internal = internal; } 31 Chapter 2 ■ Spring FundamentalS @PostConstruct public void postConstruct(){ logger.info(\"3. @PostConstruct.\"); } @Override public void afterPropertiesSet() throws Exception { logger.info(\"4. afterPropertiesSet.\"); } public void initMethod(){ logger.info(\"5. init-method.\"); } @PreDestroy public void preDestroy(){ logger.info(\"6. PreDestroy.\"); } @Override public void destroy() throws Exception { logger.info(\"7. destroy.\"); } public void destroyMethod() throws Exception { logger.info(\"8. destroy-method.\"); } } Also, there is no restriction on method names used as values for init-method and destroy-method attributes; initMethod and destroyMethod were used in this example to make their purpose really obvious. ■ ! in the certification exam, you might be asked which method is executed first—the one annotated with @PostConstruct or the one mentioned by the init-method; so the CompleteLivingBean helps clear up when methods are executed and why. When executing the test for the com.book.beans.BeanLifecycleTest bean, you will see the following output: INFO c.b.b.CompleteLivingBean - 1. Constructor. INFO c.b.b.CompleteLivingBean - 2. Setter. INFO c.b.b.CompleteLivingBean - 3. @PostConstruct. INFO c.b.b.CompleteLivingBean - 4. afterPropertiesSet. 32 Chapter 2 ■ Spring FundamentalS INFO c.b.b.CompleteLivingBean - 5. init-method. ... INFO c.b.b.CompleteLivingBean - 6. @PreDestroy. INFO c.b.b.CompleteLivingBean - 7. destroy. INFO c.b.b.CompleteLivingBean - 8. destroy-method. As represented in Figure 2-5, when a bean is created, the following succession of actions happens: 1. The constructor is called first to create the bean. 2. The dependencies are injected (setters are called). 3. The pre-initialization BeanPostProcessors are consulted to see if they want to call anything from this bean. The @PostConstruct annotation is registered by the CommonAnnotationBeanPostProcessor, so this bean will call this annotated method. This method is executed right after the bean has been constructed and before the class is put into service,6 before the actual initialization of the bean (before afterPropertiesSet and init-method). 4. The InitializingBean’s afterPropertiesSet is executed right after the dependencies were injected. 5. The init-method attribute value method is executed last, as this is the actual initialization method of the bean. When a bean is destroyed: 1. The @PreDestroy method is executed, as this has to be executed before a destroy method, if one exists. The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container.7 2. The DisposableBean’s destroy method is executed next, as the Spring standard order defines it so. 3. The destroy-method attribute value method is executed last, as this is the actual destroy method of the bean, and the Spring standard order defines it so. This is the simplified and more natural explanation of the bean lifecycle; in most cases, this is all you will need. If you want to view the full picture with full plumbing details and other things the context does, you can read the official JEE and Spring documentation.8 ■ ! the main reason for init-method and destroy-method creation was to give the developer a little control over beans definitions from third-party libraries, which have classes that cannot be modified or extended. this way, the developer can decide what gets executed after creation and what executes before destruction by using Xml configuration. 6A snippet from the JEE official Java doc at http://docs.oracle.com/javaee/7/api/javax/annotation/ PostConstruct.html. 7A snippet from the JEE official Java doc at http://docs.oracle.com/javaee/7/api/javax/annotation/ PreDestroy.html. 8http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/ BeanFactory.html. 33 Chapter 2 ■ Spring FundamentalS How Bean Post Processors Work A BeanPostProcessor allows the developer to process a bean instance created by the IoC container after its instantiation, and then again after the initialization lifecycle event has occurred on it. BeanPostProcessors are defined as classes implementing the BeanPostProcessor interface, and are recognized by an application context and instantiated before any other beans in the container, because after their instantiation, they are used to manipulate other beans instantiated by the IoC container. The @PostConstruct and @PreDestroy annotations are processed by a bean called CommonAnnotationBeanPostProcessor. This is not a default infrastructure bean for the Spring IoC container, so to use it you have to specify it in the configuration of the application. You would expect to need something like this in the mvc-config.xml file: <bean class=\"o.s.c.a.CommonAnnotationBeanPostProcessor\"/> And this could work, but there will be some issues because configuring the bean like that overrides the Spring defaults, which might lead to unexpected behavior. Fortunately, this bean configuration is one of those included in the following line, a Spring shortcut based on the context namespace: <context:component-scan base-package=\"com.book.beans\"/> Or in this one: <context:annotation-config/> The BeanPostProcessor beans wrap other beans into AOP proxies that add extra behavior (more details on AOP in the “Spring AOP” section). The Spring Framework has different types of BeanPostProcessors that can be used for caching, transactions, security, and so forth. The CommonAnnotationBeanPostProcessor scans for methods annotated with @PostConstruct and @PreDestroy, and calls those methods at the appropriate time. The code samples use logback to display logs. By increasing the granularity of the log for the Spring Framework to DEBUG, you can see what is happening “behind the scenes,” and what CommonAnnotationBeanPostProcessor is actually doing. In the following configuration snippet, you are shown how to modify the granularity of the log by editing the logger element for the Spring Framework in the logback.xml file: <logger name=\"org.springframework\" level=\"DEBUG\" additivity=\"false\"> <appender-ref ref=\"STDOUT\" /> </logger> After modifying the log file when running the BeanLifecycleTest, you can see the behavior of the CommonAnnotationBeanPostProcessor9: INFO CompleteLivingBean - 1. Constructor. DEBUG CABPP - Found init method on class CompleteLivingBean: private void CompleteLivingBean.postConstruct() DEBUG CABPP Found destroy method on class CompleteLivingBean: protected void CompleteLivingBean.preDestroy() 9CABPP is the acronym for CommonAnnotationBeanPostProcessor. It is used to fit a log quote nicely on a page. 34 Chapter 2 ■ Spring FundamentalS DEBUG CABPP Registered init method on class CompleteLivingBean: InitDestroyAnnotationBeanPostProcessor$LifecycleElement@64e17f36 DEBUG CABPP Registered destroy method on class CompleteLivingBean: DestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 INFO c.b.b.CompleteLivingBean - 2. Setter. DEBUG CABPP - Invoking init method on bean ’livingBean’: private void CompleteLivingBean.postConstruct() INFO c.b.b.CompleteLivingBean - 3. @PostConstruct. INFO c.b.b.CompleteLivingBean - 4. afterPropertiesSet. ... DEBUG CABPP - Invoking destroy method on bean ’livingBean’: protected void CompleteLivingBean.preDestroy() INFO c.b.b.CompleteLivingBean - 1. @PreDestroy. The previous section mentioned that there are annotation attributes equivalents for the init-method and destroy-method. If you were to define CompleteLivingBean using a class annotated with @Configuration, it would look like this: @Bean(initMethod = \"initMethod\", destroyMethod = \"destroyMethod\") public CompleteLivingBean getCompleteLivingBean() { return new CompleteLivingBean(); } And would be equivalent to this XML definition: <bean id=\"livingBean\" class=\"com.book.beans.CompleteLivingBean\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"/> Bean Scopes When the Spring IoC instantiates beans, it creates a single instance for each bean—unless a property is set on the bean definition specifying otherwise. The property in question is called scope and the default scope for a bean is singleton. The scopes are defined in Table 2-2. Table 2-2. Bean Scopes Scope Description singleton The Spring IoC creates a single instance of this bean and any request for beans with an id or ids matching this bean definition results in this instance being returned. prototype Every time a request is made for this specific bean, the Spring IoC creates a new instance. request The Spring IoC creates a bean instance for each HTTP request. Only valid in the context of a web-aware Spring ApplicationContext. session The Spring IoC creates a bean instance for each HTTP session. Only valid in the context of a web-aware Spring ApplicationContext. global-session The Spring IoC creates a bean instance for each global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext. 35 Chapter 2 ■ Spring FundamentalS So when a bean is created without a scope attribute, the scope of the bean is singleton: <bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\"> <property name=\"dataSource\" ref=\"dataSource\"/> </bean> Otherwise, the scope of the bean is the one specified by the value of the scope attribute: <bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\" scope=\"prototype\"> <property name=\"dataSource\" ref=\"dataSource\"/> </bean> There is an annotation equivalent to this that can be used on @Component (and other stereotype annotations) annotated beans: @Component @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class PrototypeBean { private Logger logger = LoggerFactory.getLogger(PrototypeBean.class); private static int instanceCounter = 0; public PrototypeBean() { logger.info(\"-> Constructing instance no: \" + (++instanceCounter)); } } ■ ! @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) is equivalent to @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) and @Scope(\"prototype\") because constant SCOPE_PROTOTYPE is of type string and has the \"prototype\" value. using Spring constants eliminates the risk of misspelling the scope value. The @Scope annotation can also be used on a bean definition annotated with @Bean to specify the scope of the resulting bean. @Bean(name=\"personManager\") @Scope(\"prototype\") //or @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public PrototypeBean getPrototypeBean(){ return new PrototypeBean(); } 36 Chapter 2 ■ Spring FundamentalS If you were to execute the following test, the test would pass: @Test public void testPrototype() { // Create the application from the configuration ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:test-app-config.xml\"); PrototypeBean pb1 = (PrototypeBean)context.getBean(\"prototypeBean\"); assertNotNull(pb1); //the bean is requested by type PrototypeBean pb2 = context.getBean(PrototypeBean.class); assertNotNull(pb2); assertNotEquals(pb1,pb2); } And this is what would be seen in the log file: DEBUG - Creating instance of bean 'prototypeBean' INFO -> Constructing instance no: 1 DEBUG - Finished creating instance of bean 'prototypeBean' DEBUG - Creating instance of bean 'prototypeBean' INFO -> Constructing instance no: 2 DEBUG - Finished creating instance of bean 'prototypeBean' A special case of bean scope is the scope of an inner bean. An inner bean is defined within the scope of another bean. The reason for doing this is because the bean does not need to be shared with other beans, but is needed only for the creation of the enclosing bean. The scope attribute has no meaning for an inner bean and is ignored; so are the attributes id and name, as the bean is anonymous. When using Java Configuration, the inner bean is just a local variable in a method. The following code snipped declares the DataSource bean as an inner bean: <util:properties id=\"dbProp\" location=\"classpath:datasource/db.properties\"/> <bean id=\"personRepository\" class=\"com.book.JdbcPersonRepository\"> <property name=\"dataSource\"> <bean id=\"dataSource\" class= \"org.springframework.jdbc.datasource.DriverManagerDataSource\"> <property name=\"driverClassName\" value=\"#{dbProp.driverClassName}\"/> <property name=\"url\" value=\"#{dbProp.url}\"/> <property name=\"username\" value=\"#{dbProp.username}\"/> <property name=\"password\" value=\"#{dbProp.password}\"/> </bean> </property> </bean> 37 Chapter 2 ■ Spring FundamentalS Accessing Beans Beans can be identified in three ways: by type, by name, and by id. The following subsections explain these in detail; examples are provided for each case. How to access beans configured with annotates is covered too. Bean Identification by Type A bean can be identified by its type if there is only one definition of a bean with that type in the Spring configuration file. The BeanPostPrecessor classes registered by <context:annotation-config/> that scan for annotations are singleton infrastructure beans instantiated by the Spring IoC container, when that configuration line is present in a Spring configuration file. At any time during the life of an application only one instance of each of those beans will exist. Basically, this configuration file: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <context:annotation-config/> </beans> Is equivalent to this: <?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <!--the org.springframework. package was shortened to o.s. for this code to fit the page better --> <bean class=\"o.s.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/> <bean class=\"o.s.context.annotation.CommonAnnotationBeanPostProcessor\"/> <bean class=\"o.s.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/> <bean class=\"o.s.beans.factory.annotation.RequiredAnnotationBeanPostProcessor\"/> </beans> Considering the following bean definition: <bean class=\"com.book.sandbox.SimpleBean\" /> 38",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Unit testing is used to test small units of code, thus its naming. Unit testing is easy to do—not much setup is necessary, and since JUnit10 has introduced @Test annotation writing, unit tests have become a breeze. 10The most commonly used Java testing framework (see http://junit.org). 44 Chapter 2 ■ Spring FundamentalS • Integration testing is used to test bigger chunks of code made up of objects interacting together in a given context, and the focus is set on business logic and object integration with each other. The context is usually made up of mocks or stubs that replace the objects, which are not the focus of the tests. You can imagine that creating a testing context is not a simple job. The Spring Framework includes a testing module called spring-test that makes integration testing really practical to implement. The tests that have been used throughout this chapter use the spring-test module. • The SpringJUnit4ClassRunner, as the names says, is a Spring class used to tell JUnit that the tests in this class are executed in a Spring test context. • The @ContextConfiguration receives one or more configuration files as parameters that are used to initialize the test context. • The @TransactionConfiguration is the annotation that injects the transactionManager instance used to run tests in a transactional environment. As mentioned earlier, this can be skipped, and @Transactional can be used when the TransactionManager bean has the default name. ■ CC When using @ContextConfiguration to annotate a test class, the configuration file path can be skipped, and then Spring ioC container will look for a file named [TestClassName]-context.xml in the same location where the test class is defined. When the project has a maven structure, the configuration is placed in the resources directory, and the directories matching the package name for the test class are created so the file will have the same relative path as the test class. So if you have test class com.book.simple.SimpleTest annotated with @ContextConfiguration, then resources will have com/books/simple/SimpleTest-context.xml to provide the test context configuration, which is automatically discovered and used by the Spring ioC container. Summary After reading this chapter, you should have a basic knowledge of how Spring does its magic and understand the following: • Two flavors of configuration can be mixed: XML-based (decoupled from classes code) and Java annotation–based (bean definitions are mixed in the class code) • The lifecycle of a bean • How to access a bean • What AOP is and how and where Spring can apply it • How to test Spring applications 45 Chapter 2 ■ Spring FundamentalS Quick Quiz Question 1: What is a bean?",
    "answer": "A. a plain old Java object B. an instance of a class C. an object that is instantiated, assembled, and managed by a Spring IoC container",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the default scope of a bean?",
    "answer": "A. default B. singleton C. protected D. prototype",
    "source": "extracted",
    "confidence": 0.49
  },
  {
    "question": "What types of dependency injection are supported by Spring IoC container?",
    "answer": "A. setter injection B. constructor injection C. interface-based injection D. field-based injection",
    "source": "extracted",
    "confidence": 0.98
  },
  {
    "question": "What is true about @PostConstruct and @PreDestroy ?",
    "answer": "A. they are JSR-250 annotations B. they are supported by AutowiredAnnotationBeanPostProcessor C. they are registered by the <context:component-scan/> element Detailed answers are in the Appendix. Practical Exercise The practice module for this chapter is in the book-code project; it is named 02-chapter-practice. The solution is in the 02-chapter-solution module. You are given the code for a few related beans. Your task is to complete the existing configuration files, to create test contexts, and to make sure that the tests pass. The book-code project is a gradle multimodule project. It can be built from the command line by running gradle build under the book-code directory. This will build all modules of the project. The build will fail when run for the first time because of the unresolved tasks in the -practice projects. If you do it this way, you will have something similar to the following output in your console: $ gradle build .. :02-chapter-practice:compileJava UP-TO-DATE :02-chapter-practice:processResources UP-TO-DATE :02-chapter-practice:classes UP-TO-DATE :02-chapter-practice:jar UP-TO-DATE :02-chapter-practice:assemble UP-TO-DATE :02-chapter-practice:compileTestJava UP-TO-DATE :02-chapter-practice:processTestResources UP-TO-DATE 46",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "spring-web.jar • spring-webmvc.jar These libraries are the core of all Spring-related modules. At the center of the Spring Web MVC framework sits the DispatcherServlet class, which is the entry point for any Spring web application. Before any HTTP request reaches the specific controller, it has to go through DispatcherServlet for that controller to be identified.2 In a nutshell, the DispatcherServlet coordinates all request-handling operations using other infrastructure components defined in Spring and user-defined components. And it acts as a front controller, an entry point for the web application. The Spring components mentioned earlier can be categorized as follows: • Spring MVC infrastructure components • handler mappings • handler adapters • view resolvers • personalization beans • exception resolvers • User-provided web components • handler interceptors • controllers Thus, the Spring MVC functional flow can be sketched somewhat like in Figure 3-2. 2If it looks as if Spring MVC resembles Struts, you are definitely not imagining things. The Spring Web MVC was inspired by Struts, which was one of the first MVC-based frameworks. The DispatcherServlet in Spring has the same responsi- bilities as the ActionServlet in Struts, as both are implementations of the Front Controller Pattern. You can read more about this software design pattern at http://www.martinfowler.com/eaaCatalog/frontController.html. 54 Chapter 3 ■ Spring MVC Figure 3-2. Spring MVC functional flow Briefly put, to configure a Spring web application, you need to do the following: • Define the DispatcherServlet as the main servlet handling all requests to the application in web.xml and link it to the Spring configuration, or configure this servlet programmatically by using a class implementing WebApplicationInitializer (only possible in a Servlet 3.0+ environment) • Define the application configuration (usually in a Spring configuration file named mvc-config.xml or a Java configuration class), which should do the following: • Define the MVC context used (handler adapter, handler mapping, and other infrastructure beans) • Define a view resolver (or more) Configuring MVC Spring Web MVC can be configured just like any other Spring application, via XML (using mostly the <mvc/> namespace), Java configuration annotations, or by mixing these. A Spring web application can be configured in two ways: • All-in-one configuration: web.xml (part of JEE specification) or a WebApplicationInitializer implementation and Spring application configuration files. Back-end and front-end configurations are coupled and the DispatcherServlet is the only entry point to the application. • Separate configuration: Used for more complex applications when the DispatcherServlet is not the only entry point (usually applications that require the back end to be accessed via REST or SOAP requests/web services, and in this case, the back end needs a separate listener). 55 Chapter 3 ■ Spring MVC Typical Java web applications that can be built with Gradle have the internal structure consecrated by Maven. The folder containing web-specific files, configuration files, and static resources is named webapp. The projects used in this chapter all have this structure (in Intellij IDEA), as shown in Figure 3-3. Figure 3-3. Typical Java web application structure with web.xml configuration file XML Configuration Spring XML configuration for core applications was covered in the previous chapter. But XML namespaces can be used for declaring web-specific infrastructure beans too. There are multiple ways to configure a web application; multiple files can be used for web-specific beans to be grouped together based on their purpose. In this chapter, multiple ways to create a configuration are presented, and after getting familiar with all of them, you will be able to “mix and match” to create configurations for the types of applications that you will develop. All-in-One Configuration This is the simplest way to configure a web application. The Spring configuration files are all referred to in the web.xml file as a value for the contextConfigLocation parameter. <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/mvc-config.xml /WEB-INF/spring/app-config.xml </param-value> </init-param> </servlet> 56 Chapter 3 ■ Spring MVC <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> In the preceding case, the mvc-config.xml contains the Spring configuration for the front-end (controllers and MVC infrastructure beans) of the application, and the app-config.xml contains the back-end configuration (service beans). In this case, all Spring configuration files are loaded by the DispatcherServlet and a web context is created. Separate Configuration The proper way to configure a more complex web application to make it more extensible and flexible is to decouple the front-end configuration the back-end configuration. Such an implementation provides web services access to the back end. This can be done by having a separate listener for the back-end configuration. This complicates the content of web.xml a bit, and the configuration looks similar to the next one: <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/app-config.xml</param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/mvc-config.xml</param-value> </init-param> </servlet> <servlet-mapping>...</servlet-mapping> ■ CC When the back-end Spring configuration file is named applicationContext.xml, there is no need to specify the <context-param> element in your configuration. the Spring ioC container accepts the previously mentioned file name as a default name for the backed configuration file and it will load it automatically. 57 Chapter 3 ■ Spring MVC The web.xml file is transformed to this: <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <!-- The backend configuration file is named applicationContext.xml --> <!-- The <context-param> is no longer needed.--> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/mvc-config.xml</param-value> </init-param> </servlet> <servlet-mapping>...</servlet-mapping> ■ ! throughout this book, package names may not be presented fully: or.springframework. usually becomes o.s. the reason for this is to fit the configuration and code samples better in the page to make them more readable. ■ CC if the Spring MVC configuration file is named [servletName]-servlet.xml, there is no need to specify the <init-param> element either. the Spring ioC container accepts the previously mentioned file name template (replace servletName with the name given to the servlet) as a default name for the front-end configuration file and it will load it automatically. The separate configuration can be simplified like this: <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/app-config.xml</param-value> </context-param> 58 Chapter 3 ■ Spring MVC <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>mvc-dispatcher</servlet-name> <!-- The frontend configuration file is named mvc-dispatcher-servlet.xml --> <!-- The <init-param> is no longer needed.--> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> Customizing the configuration is easy. All rules from Spring core configuration apply. Wildcards are supported. Different resource prefixes can be used. The DispatcherServlet can even be configured to a different url-pattern. In this case, the requests to the application must contain the value of the url-pattern value, otherwise they won’t be handled by the DispatcherServlet. This approach is suited when the application uses multiple DispatcherServlet instances. <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/*-beans.xml classpath:com/book/app-config.xml </param-value> </init-param> ... <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/admin/*</url-pattern> </servlet-mapping> In the previous example, the DispatcherServlet handles the request with the URL matching [server:port]\\[application-name]\\admin\\*. ■ ! throughout this book and in all code examples, the Spring MVC configuration file is named mvc-config.xml to emphasize that only Spring MVC components are defined in it; otherwise, this configuration file can be named in any other way. the contents of this file are used for view, locale, and time zone resolution and for customizing handler mappings and other Spring MVC infrastructure beans. 59 Chapter 3 ■ Spring MVC The controllers can be defined in the mvc-config.xml configuration file using the bean tag element, just like any other bean, but starting with Spring 3.0, the preferred way to define controllers is using the @Controller annotation, which is why the Spring MVC is often referred to as @MVC. The main component of an MVC XML configuration is the <mvc:annotation-driven/> element that registers all necessary default infrastructure beans for a web application to work: handler mapping, validation conversion beans, and many others. Another component that is important is the <mvc:default-servlet-handler/>. Usually in Spring web applications the default servlet mapping “/” is mapped to the DispatcherServlet. This means that static resources have to be served by it too, which might introduce a certain lag in providing a response as the DispatcherServlet has to find the resources that the request URL is mapped to. The <mvc:default- servlet-handler/> configures a DefaultServletHttpRequestHandler with a URL mapping of “/*” and the lowest priority relative to other URL mappings. Its sole responsibility is to serve static resources. You can see some user-defined beans needed for configuring a Spring MVC application in the following example. Configurations might differ, depending on the types of resources used. <!-- Defines basic MVC defaults (handler mapping, date formatting, etc) --> <mvc:annotation-driven/> <!-- Configures a handler for serving static resources by forwarding to the Servlet container's default Servlet.--> <mvc:default-servlet-handler/> <!-- ResourceBundle bean used for internationalization --> <bean name=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\" p:basename=\"classpath:messages/global\"/> <!-- View resolver bean used to render a *.jsp page --> <bean id=\"jspViewResolver\" class=\"o.s.web.servlet.view.InternalResourceViewResolver\"> <property name=\"prefix\" value=\"/WEB-INF/\"/> <property name=\"suffix\" value=\".jsp\"/> </bean> ■ ! Before continuing to the next section, take a look at the module project 03-chapter-01-practice under the book-code project. this is a simple project focusing on the XML-based configuration; it can be used to test your understanding of this section. it uses the minimum number of Spring infrastructure beans required to start a web application and display a simple JSp page. to run a project that is a web application from the command line, execute the gradle appRun task. to run a project in intellij iDea, use the appStart task to start the application and appStop to stop the application. Make sure to execute the tasks from under the specific module in the gradle task tree. Figure 3-4 can help you identify the task you need to run the application within intellij iDea. 60 Chapter 3 ■ Spring MVC Figure 3-4. Gretty plugin special tasks to start and stop web applications 2015-03-01 15:48:36.834 WARN - 03-chapter-01-practice runs at: 2015-03-01 15:48:36.834 WARN - http://localhost:8080/03-chapter-01-practice Open that location in your browser. if you see the page shown in Figure 3-5, the project is working properly. run gradle appStop to stop the server. Figure 3-5. Practice Spring MVC application welcome page Configuration Using Annotations An equivalent configuration using Java configuration can be created, but there are a few additional details needed for the configuration class to work properly. The configuration class has to also be annotated with the @EnableWebMvc annotation and has to either implement WebMvcConfigurer or extend an implementation of this interface, for example: WebMvcConfigurerAdapter, which gives the developer the option to override only the methods he or she is interested in. 61 Chapter 3 ■ Spring MVC Annotating a configuration class with @EnableWebMvc has the result of importing the Spring MVC configuration implemented in the WebMvcConfigurationSupport class; it is equivalent to <mvc:annotation- driven/>. This class registers a lot of Spring infrastructure components that are necessary for a web application (covered later in this chapter).3 To tell the DispatcherServlet that the configuration will be provided by a configuration class instead of a file, the following changes have to be made in web.xml: • Define an initialization parameter named contextClass with the full name of the Spring class used to create an annotation-based context as the value. • The initialization parameter named contextConfigLocation should have the full name of the configuration class written by the developer as the value. <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextClass</param-name> <param-value> o.s.web.context.support.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> </servlet> The configuration class for what was configured with XML in the previous chapter looks like this: @Configuration @EnableWebMvc // equivalent with <mvc:annotation-driven/> @ComponentScan(basePackages = {\"com.book.controllers\"}) // equivalent with <context:component-scan base-package=\"com.book.controllers\"/> //used to scan only web components public class WebConfig extends WebMvcConfigurerAdapter { ... @Bean(name = \"messageSource\") MessageSource getMessageSource() { ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); ... return messageSource; } 3If you want, you can look in the API documentation for detail information about this class, which is available at http://docs.spring.io/spring/docs/current/javadoc- api/. 62 Chapter 3 ■ Spring MVC // <=> <mvc:default-servlet-handler/> @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) { configurer.enable(); } @Bean InternalResourceViewResolver getViewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/\"); resolver.setSuffix(\".jsp\" ); return resolver; } } The @ComponentScan annotation is the equivalent of <context:component-scan />. It is used to find all the classes annotated with @Controller in the package com.book.controllers. ■ ! Before continuing to the next section, take a look at the module project 03-chapter-02-practice under book-code. this is a simple project focusing on the Java configuration–based configuration and can be used to test your understanding of this section. it uses the minimum number of Spring infrastructure beans required to start a web application and display a simple JSp page. the gradle running instructions are the same as the instructions for the previous section. Mixed Configuration ■ ! there are Spring-specific annotations like @Controller, @Service, @Component, and @Repository, which can be used to configure a Spring application without the need to use a Java configuration class; instead, an XML file is used, containing context or MVC namespace element definitions. this is called a mixed configuration, because it uses annotations to define the beans, and XML to define the context. In practice, most common and frequently used Spring configurations imply a combination of XML and annotations. The primary reason for this is legacy code, as XML configuration was the first and only way to configure a Spring application prior to Spring 2.5. Migration to a more recent version of Spring is usually a slow process, and projects remain stuck between worlds for some periods of time. And there are also developers that still prefer XML because it seems easier to separate configurations for the back end, front end, security, web services, and so on, in separate files (although this can just as easily be done with Java configuration classes). It is also intuitive and very readable when it comes to dependency injection. It is more practical to have the definition of the relationship between the beans decoupled from the bean implementation. Because it is more practical to implement transaction management using annotations, it is very visible which method is executed in a transaction. 63 Chapter 3 ■ Spring MVC Annotations should be applied when they provide functionality and/or visibly mark the annotated classes or methods for a specific purpose. Annotations should not tie the code down to some specific process, so the code should function normally without them. The most obvious case here is the @Controller annotated classes for the web side of an application. In the back end, @Repository and @Service annotations are used for the same purpose. When looking at the code of a controller class, you see the annotation and you can easily infer what the purpose of that class is. All annotation mentioned earlier are Spring stereotype annotations, which are used to denote the roles of types in the overall architecture. A typical Spring web application configuration uses an mvc-config.xml file to declare the infrastructure beans and @Controller annotated classes. Configuration Without Using web.xml Starting with Servlet 3.0+, the web.xml file is no longer needed to configure a web application. It can be replaced with a class implementing the WebApplicationInitializer (or a class extending any of the Spring classes that extend this interface). This class is detected automatically by SpringServletContainerInitializer (an internal Spring supported class, which is not meant to be used directly or extended). The SpringServletContainerInitializer class is bootstrapped automatically by any Servlet 3.0+ container. The SpringServletContainerInitializer4 extends javax.servlet.ServletContainerInitializer and provides a Spring-specific implementation for the onStartup method. This class is loaded and instantiated, and the onStartup is invoked by any Servlet 3.0–compliant container during container startup, assuming that the Spring-web module JAR is present on the classpath. Considering you have a web.xml file that looks like this: <servlet> <servlet-name>admin</servlet-name> <servlet-class>o.s.w.s.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/mvc-config.xml </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> 4The code for this class is at https://github.com/spring-projects/spring-framework/blob/master/spring- web/src/main/java/org/springframework/web/ SpringServletContainerInitializer.java. 64 Chapter 3 ■ Spring MVC The most obvious way to implement WebApplicationInitializer is this: public class WebInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); registration.setInitParameter(\"contextConfigLocation\", \"/WEB-INF/spring/mvc-config.xml\"); } } The class does not need to be annotated or linked to any other configuration file existing in the application. You can easily notice which lines from XML turned into which lines in the code, right?",
    "answer": "But there is another way, which involves constructing the application context first and then injecting it into the DispatcherServlet: XmlWebApplicationContext appContext = new XmlWebApplicationContext(); appContext.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(appContext)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); And there is an even simpler way—by extending AbstractDispatcherServletInitializer, an abstract implementation of the WebApplicationInitializer: public class WebInitializer extends AbstractDispatcherServletInitializer { @Override protected WebApplicationContext createRootApplicationContext() { //there is no root application context for the web application context to inherit return null; } @Override protected WebApplicationContext createServletApplicationContext() { XmlWebApplicationContext cxt = new XmlWebApplicationContext(); cxt.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); return cxt; } @Override protected String getServletMappings() { return new String { \"/\" }; } } 65",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "It is no longer possible to use SimpleUrlHandlerMapping or BeanNameUrlHandlerMapping to identify a controller and then identify the handler method by narrowing the method choice with @RequestMapping. • It is no longer possible to have a single method without explicit mapping to solve all requests mapped to a controller. The new support classes will throw a Not Found 404 error. • HandlerInterceptor and HandlerExceptionResolver (covered later in the chapter) can now expect the object-based handler to be a HandlerMethod. They can examine its parameters and annotations. • Custom argument and return types are supported for handler methods. • @PathVariable annotated parameters (covered later in the chapter) are automatically added to the model, so it’s not necessary to manually add them if you are providing them as part of forwarding or redirecting. 72 Chapter 3 ■ Spring MVC • Supports parameterized URI template on redirect strings. • RequestMappings now support consumes/produces, so it’s not necessary to specify h eaders=\"ContentType=application/json\". This is a little closer to the JAX-RS style of specifying @Consumes/@Produces annotations. This helps in producing the correct error code if unsupported media types are referenced on REST requests. The preceding list is not complete. If you want a full read of all the advantages of using the new handler support classes, you can find it in the official documentation.7 Some are also mentioned in the following sections; those are the ones you should focus on for the exam. When the web application starts, if the logger of the application is configured properly, you should be able to see all the beans used in the application, including the infrastructure beans. The following is a snippet from a debug log printed when 02-pr-mvc-basic-solution starts. Run the project yourself to analyze the console output in more detail. INFO Initializing Spring FrameworkServlet 'mvc-dispatcher' ... DEBUG o.s.b.f.s.DefaultListableBeanFactory - Pre-instantiating singletons ..., accountRepo,hospitalRepo,personManager,identityCardRepo,transactionManager, entityManagerFactory, ..., o.s.w.s.m.m.a.RequestMappingHandlerMapping#0, ... ,o.s.w.s.m.m.a.RequestMappingHandlerAdapter#0, o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver#0,..., org.springframework.web.servlet.view.InternalResourceViewResolver, ,messageSource,localeResolver,themeResolver, ... ViewResolver The HTTP response returned to the client after the execution of a handler method is constructed using a model and a view. The model contains the data that is used to populate a view. Spring provides view resolvers to avoid ties to a specific view technology. Out of the box, Spring supports JSP, Velocity templates, and XSLT views. The interfaces needed to make this possible are ViewResolver and View. The first provides a mapping between view names and actual views. The second takes care of preparing the request and forwards it to a view technology.8 7http://docs.spring.io/spring/docs/current/spring- framework-reference/htmlsingle/#mvc-ann- requestmapping-31-vs-30, http://docs.spring.io/spring/docs/current/spring- framework-reference/ htmlsingle/#mvc-config-enable. 8http://docs.spring.io/spring/docs/4.1.x/spring- framework-reference/htmlsingle/#mvc-viewresolver. 73 Chapter 3 ■ Spring MVC All handler methods must resolve to a logical view name that corresponds to a file, either explicitly by returning a String, View, or ModelAndView instance or implicitly based on internal conventions. The core view resolver provided by Spring is the InternalResourceViewResolver, which is the default view resolver, as you can see in the DispatcherServlet.properties file: org.springframework.web.servlet.ViewResolver= org.springframework.web.servlet.view.InternalResourceViewResolver View Resolver Chaining A web application can have more than one ViewResolver configured and the DispatcherServlet discovers them by type. In this case, the default view resolver configuration is overridden, meaning the InternalResourceViewResolver is not the default resolver anymore, so if this bean is needed, it has to be configured explicitly. In this case, the available view resolvers can and should be chained to have a fixed sequence of resolvers trying to obtain a view. The next example shows how two view resolvers can be chained together to resolve JSP and Excel views: <!-- in mvc-config.xml --> <bean name=\"persons/list.xls\" class=\"com.book.persons.PersonsExcelView\"/> <bean id=\"xlsViewResolver\" class=\"...web.servlet.view.BeanNameViewResolver\" p:order=\"0\"/> <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:order=\"1\" /> ■ ! Defining bean properties using the p: ... syntax is possible by using the p namespace that offers a way to contract bean definitions in XML configuration files to reduce their size and make them more readable.9 Chaining view resolvers is also possible using a Java configuration class: \\\\ in @Configuration annotated class @Bean(name=\"persons/list.xls\") public View excelView(){ return new PersonsExcelView(); } @Bean(name=\"xlsViewResolver\") public ViewResolver xlsViewResolver(){ BeanNameViewResolver resolver = new BeanNameViewResolver(); 9You can read more about it in the official documentation at http://docs.spring.io/spring/docs/current/ spring-framework-reference/html/beans.html#beans- p-namespace. 74 Chapter 3 ■ Spring MVC resolver.setOrder(0); return resolver; } @Bean public ViewResolver jspViewResolver() { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); ... resolver.setOrder(1); return resolver; } When a view resolver does not result in a view (usually null is returned, but there are view resolvers that throw exceptions), Spring examines the application context for other view resolver beans and inspects each of them until a view is obtained. If this is not possible, a ServletException is returned. When resolver beans are chained, the inspection is done based on the value of their order property; the lower the value of the property, the higher the priority when resolving view names. ■ ! the InternalResourceViewResolver resolves the view no matter what view name is returned. it throws an exception if it cannot resolve a view name, so this bean always has to be placed last in the chain; otherwise, Spring skips looking for other view resolver beans in the context. XSLt and JSOn are also resolvers that must be last in the chain. tiles, Velocity, and FreeMarker can appear anywhere in the chain. In the case just presented, if the BeanNameViewResolver does not return a view (a request method has returned a logical view name different than \"persons/list.xls\"), the next resolver is called to do that. The InternalResourceViewResolver is the most important implementation provided by Spring. It is a specialization of UrlBasedViewResolver (so they cannot be used together in a configuration, chained or not) and inherits the behavior of interpreting view names as a URL, supports the \"redirect:\" prefix and the \"forward:\" prefix. And supports InternalResourceView(Servlets and JSPs) and JstlView. ■ ! the \"redirect:\" and \"forward:\" prefixes are appended to the logical view name to tell the servlet container what to do. With \"forward:\", the servlet container just forwards the same request to the target UrL, and the browser is not involved and does not know the UrL has changed. a forward should be used for safe operations when reloading the page won’t result in corrupt data (usually for requesting data to display in the page). With \"redirect:\", the response status is set to 302 and the UrL to redirect to is set in a Location header, then the response is sent to the browser. the browser then makes another request to the new UrL. redirect is a two-step operation; it is recommended to be used when the first request is a data manipulation request, and the browser must then be redirected to a confirmation page to prevent data duplication. The “redirect:” prefix can be returned together with a view name to delegate the creation of the response to another handler. The most suitable for such behavior is when a POST request was received and the possibility to resubmit the same form data has to be eliminated. The browser sends an initial POST, receives a response to redirect to a different URL, and then performs a GET request for the URL received as a 75 Chapter 3 ■ Spring MVC response. This sequence of actions matches a web development design pattern named Post-Redirect-Get that prevents duplicate form submissions. In Figure 3-7, the Post- Redirect-Get process is displayed using the PersonsController. Figure 3-7. Post-Redirect-Get in Spring using the \"redirect:\" prefix compared to \"forward:\" \"redirect:\" and \"forward:\" are recognized by the UrlBasedViewResolver and all its subclasses. They treat them accordingly and consider the view name after the prefix as the redirect/forward URL. ■ ! You will have the occasion to work with \"redirect:\" and \"forward:\" in the 05-pr-mvc-form-practice project. All view file templates are stored under /WEB-INF for security reasons. They cannot be accessed directly via a manually introduced URL and they require a model in order to be rendered. The previously mentioned view implementations supported by InternalResourceViewResolver have the following characteristics: • InternalResourceView exposes the model attributes as request attributes and forwards the request to the specified resource URL using a RequestDispatcher. • JstlView is a specialization of InternalResourceView that exposes request attributes specifying the locale and the resource bundle for JSTL’s formatting and message tags, using Spring’s locale and MessageSource ( the JSTL library is required in the classpath for this View technology to be available). 76 Chapter 3 ■ Spring MVC More about this topic is covered later in this chapter. This is an example of how a view is resolved using the chained resolvers configured earlier: /* 1 */ @RequestMapping(\"/persons.htm\") public String listHtml(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); return \"accounts/list\"; } /* 2. */ @RequestMapping(\"/persons.xls\") public String listExcel(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); return \"persons/list.xls\"; } The first method has InternalResourceViewResolver resolve the view, and the second is taken care of by BeanNameViewResolver and a PersonsExcelView is rendered. As you can see, the implementation for the two methods is almost identical. The URL and the logical view name returned are different, however. And there’s a programming principle called Don’t Repeat Yourself! that those two methods do not respect. Let’s try and respect that principle by merging the two methods into one: /* 1 */ @RequestMapping(\"/persons\") public String list(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); if (rq.getRequestURL().toString().endsWith(\"xls\")) { return \"persons/list.xls\"; } else { return \"persons/list\"; } } But this is not an acceptable solution either. What if the application is requested to support PDF views too?",
    "answer": "That means more if-else instructions have to be added. Right now you are probably telling yourself: “There’s gotta be a better way of doing this!” And there is. Worry not, this shall be covered in the next section. ■ ! take a look at the 03-chapter-06-solution project. it has been set up to work with the chained resolver configuration mentioned in this chapter. the data can be viewed in a web page, an excel document or a pDF. run it and take a look at the implementation before moving on to the next section. 77",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Use a distinct URL for each resource by using a different extension in the URL (example: http://localhost:8080/persons/list.xls requests an Excel view containing a list of persons, while http://localhost:8080/persons/list.pdf requests a PDF view containing a list of persons) • Use the same URL but set the Accept HTTP request header to the desired resource type (example: a request coming from http://localhost:8080/persons/list having the Accept header set to application/pdf requests a PDF view containing a list of persons) ■ ! the problem with the Accept header is that it cannot be used when the client is a browser, as most browsers force its value to text/html. Because of this, web applications are always built to use the first approach and each view type is mapped to its own UrL (taking the extension into consideration; for example: /persons/list.html, /persons/list.xls). the Accept header approach is most useful for reSt web services and similar automation scenarios. The ContentNegotiatingViewResolver implements the Ordered interface, so it can be used alongside other resolvers, it can be part of a view resolver chain, and it has to have the highest priority in the chain. This is due to its behavior; if theContentNegotiatingViewResolver cannot select a View, it returns null, and Spring examines the application context for other view resolver beans and inspects each of them until a view is obtained. Usually the ContentNegotiatingViewResolver is configured to pick up view resolvers automatically from the application context, so it should always resolve to a View. The next resolvers in the chain can be considered a fallback solution, to make sure that a View is provided. The ContentNegotiatingViewResolver can be configured in a similar way, as shown in the following example: <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\" p:order=\"-1\"> <property name=\"mediaTypes\"> <map> <entry key=\"html\" value=\"text/html\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"json\" value=\"application/json\"/> </map> </property> 78 Chapter 3 ■ Spring MVC <property name=\"viewResolvers\"> <list> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\" /> <bean class=\"com.book.resolver.JsonViewResolver\"/> </list> </property> <property name=\"defaultViews\"> <list> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" /> </list> </property> <property name=\"defaultContentType\" value=\"text/html\"/> <property name=\"ignoreAcceptHeader\" value=\"true\"/> <property name=\"favorParameter\" value=\"false\"/> <property name=\"favorPathExtension\" value=\"true\"/> </bean> <!-- Fallback Resolver: If no extension matched, use JSP view --> <!-- Resolves view names to protected .jsp resources within the /WEB-INF directory --> <bean class=\"o.s.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/\" p:suffix=\".jsp\" p:order=\"0\"/> Here is the meaning of each property used in the previous configuration: • mediaTypes: Map containing extension to content-type correspondences. This property is not mandatory and it does not have to be set in the application when the JavaBeans Activation Framework is used, in which case the types are determined automatically.10 • viewResolvers: The list of view resolvers to delegate to. This property is not mandatory and when it is not set, all view resolver beans in the context are detected and used, but they have to be ordered. • defaultViews: The default view to use when a more specific view could not be obtained. The property is not mandatory. • defaultContentType: The type to render in case a match was not found. The property is not mandatory. • ignoreAcceptHeader: Indicates that the HTTP Accept header should be ignored if true, and taken into consideration if false. The property is not mandatory, and if not set, it defaults to false. 10By default, strategies for checking the extension of the request path and the Accept header are registered. The path extension check performs lookups through the ServletContext and the JavaBeans Activation Framework (if present) unless media types are configured. In order to use the JavaBeans Activation Framework, the activation.jar has to be in the classpath of the application. 79 Chapter 3 ■ Spring MVC • favorParameter: Indicates if a request parameter named format should be used to determine the requested content-type. The property is not mandatory, and if not set, it defaults to false. • favorPathExtension: Indicates if the extension of the request URL should be used to determine the requested content-type. The property is not mandatory, and if not set, it defaults to true. Starting with Spring 3.2, ContentNegotiationManagerFactoryBean and ContentNegotiationManager were introduced in order to encapsulate all content-type related configurations for the ContentNegotiatingViewResolver. ContentNegotiationManagerFactoryBean provides access to a ContentNegotiationManager configured with one or more ContentNegotiationStrategy. An equivalent configuration to the preceding, after Spring 3.2, looks like this: <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\"> <property name=\"viewResolvers\"> <list> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\"/> <bean class=\"com.book.resolver.JsonViewResolver\"/> </list> </property> <property name=\"defaultViews\"> <list> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" /> </list> </property> <!-- All content-type related configuration is now done by this bean since Spring 3.2 --> <property name=\"contentNegotiationManager\"> <bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean> <property name=\"mediaTypes\"> <map> <entry key=\"html\" value=\"text/html\"/> <entry key=\"json\" value=\"application/json\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> </map> </property> <property name=\"defaultContentType\" value=\"text/html\"/> <property name=\"ignoreAcceptHeader\" value=\"true\"/> <property name=\"favorParameter\" value=\"false\"/> <property name=\"favorPathExtension\" value=\"true\"/> </bean> </property> 80 Chapter 3 ■ Spring MVC ■ ! the problem with using JavaBeans activation Framework is that if the extension is not recognized, it sets the content-type to application/octet-stream by default. this means that the Views configured with the defaultViews property are not taken into consideration and the ContentNegotiatingViewResolver will return null. that’s why in Spring 3.2, the useJaf property was introduced; it can be set to false to disable the JavaBeans activation Framework. this property has been added to ContentNegotiationManagerFactoryBean too. Considering the previous configuration, the following code displays how a view is resolved using content negotiation type: // In PersonsController.java @RequestMapping(\"/persons\") public String list(Model model) { model.addAttribute(personManager.getAllPersons()); return \"persons/list\"; } <!-- In mvc-config--> <bean class=\"com.book.persons.PersonsExcelView\"/> As you can see, there is no need for the bean name to be persons/list.xls, because the ContentNegotiatingViewResolver does the match without it. ■ ! in the following XML configuration, the util namespace is introduced to simplify the configuration. the util namespaces allows you to define and use collections in the same way that beans are defined and used in a configuration file. This configuration can be simplified by using the p and util namespaces, which allow the ContentNegotiatingViewResolver XML bean definition to be simplified, as follows: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> ... 81 Chapter 3 ■ Spring MVC <!-- sample usage of the util namespace to declare a map --> <util:map id=\"mediaTypesMap\"> <entry key=\"html\" value=\"text/html\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"json\" value=\"application/json\"/> </util:map> <!-- sample usage of the util namespace to declare a list --> <util:list id=\"defaultViewsList\"> <!-- Excel view--> <bean class=\"com.pr.views.PersonsExcelView\"/> <!-- JSON View --> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\"/> </util:list> <util:list id=\"resolverList\"> <bean class=\"com.pr.resolver.JsonViewResolver\"/> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <!-- Resolves logical view names to Tiles 3 definitions --> <bean id=\"tilesViewResolver\" class=\"o.s.web.servlet.view.tiles3.TilesViewResolver\" p:requestContextAttribute=\"requestContext\"/> </util:list> <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\" p:order=\"-1\" p:defaultViews-ref=\"defaultViewsList\" p:viewResolvers-ref=\"resolverList\"> <property name=\"contentNegotiationManager\"> <bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean\" p:defaultContentType=\"text/html\" p:ignoreAcceptHeader=\"true\" p:favorParameter=\"false\" p:favorPathExtension=\"true\" p:mediaTypes-ref=\"mediaTypesMap\"/> </property> </bean> <beans> Of course, this means taking out the defaultViewsList and the mediaTypesMap outside the declaration of the ContentNegotiatingViewResolver, which is the only place that they are needed. In this configuration, they can be used by other beans, although this is rarely needed. The choice belongs to the developer, depending on what configuration approach he is most comfortable with. ■ ! When the p namespace is used, the p:[property-name]-ref means this property is a reference to an existing bean in the context, with the id specified as the value. 82 Chapter 3 ■ Spring MVC That’s mostly it when it comes to content-type negotiation. What is left to add is some sample code for the Java configuration: @Configuration @EnableWebMvc public class WebConfig extends WebMvcConfigurerAdapter { // Configures the contentNegotiationManager bean @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { configurer .ignoreAcceptHeader(true) .defaultContentType(MediaType.TEXT_HTML) .favorParameter(false) .favorPathExtension(true); } //Configure ContentNegotiatingViewResolver @Bean public ViewResolver contentNegotiatingViewResolver (ContentNegotiationManager manager) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(manager); // Define all possible view resolvers List<ViewResolver> resolvers = new ArrayList<>(); resolvers.add(beanNameViewResolver()); resolvers.add(tilesViewResolver()); resolvers.add(jsonViewResolver()); resolver.setViewResolvers(resolvers); List<View> defaultViewList = new ArrayList<>(); defaultViewList.add(jsonView); resolver.setDefaultViews(defaultViewList); resolver.setOrder(0); return resolver; } @Bean public ViewResolver jsonViewResolver() { return new JsonViewResolver(); } @Bean public MappingJackson2JsonView jsonView(){ return new MappingJackson2JsonView(); } 83 Chapter 3 ■ Spring MVC @Bean InternalResourceViewResolver getViewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/\"); resolver.setSuffix(\".jsp\" ); resolver.setOrder(1); return resolver; } // other bean definitions ... } In the Java-annotated configuration there is no need to create a ContentNegotiationManager using the ContentNegotiationManagerFactoryBean. Spring does it automatically if you provide a configuration for it by overriding the implementation for the configureContentNegotiation method. JSON View Resolver In this section, in the code samples, the MappingJackson2JsonView is an example of a default View. This is a Spring MVC View implementation that renders JSON content by serializing the model for the current request using the Jackson 2.x ObjectMapper. By default, everything serializable (classes that implement the Serializable interface) in a model map is being serialized, except for framework-specific classes and classes or fields annotated with @JsonIgnore. The configuration for the view is provided by Jackson2ObjectMapperBuilder. The only tiny issue is that there is no view resolver provided by Spring, which could resolve this type of view. So a developer has to create one; but worry not— it’s quite easy: @Component public class JsonViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { MappingJackson2JsonView view = new MappingJackson2JsonView(); //make JSON output readable using proper indentation view.setPrettyPrint(true); return view; } } When using Java configuration classes, all that is needed is a @Bean annotated method: @Bean public ViewResolver jsonViewResolver() { MappingJackson2JsonView view = new MappingJackson2JsonView(); view.setPrettyPrint(true); return view; } The Jackson library provides a set of annotations designed to be used when implementing classes subjected to JSON serialization to customize what is serialized and in which format. This way of working is similar to JPA and JAXB. 84 Chapter 3 ■ Spring MVC ■ ! the project 03-chapter-07-solution has a view resolver configuration that uses a ContentNegotiatingViewResolver. the data can be viewed in a web page, excel document, pDF document, or JSOn. run it and take a look at the implementation before moving on to the next section. Personalization Beans Most web applications are created to provide a certain service to users from different places in the world, so the application needs to adapt to the language used by those customers (a process called internationalization). Some web applications offer their users the ability to customize the application’s interface based on a number of available themes. Spring offers the ability to easily customize the locale and look-and-feel of a web application via a couple of infrastructure beans. MessageSource To support internationalization, a Spring application must have in its context a bean named messageSource. The class of this bean must implement the MessageSource interface and provides access to localized messages. This class provides concrete implementations for localization methods named getMessage(...). When an ApplicationContext is loaded, it automatically searches for this bean in the context and all calls to getMessage(...) methods are delegated to this bean. Spring provides two out-of-the-box implementations for the MessageSource interface: ResourceBundleMessageSource and StaticMessageSource. The second one allows messages to be registered programmatically and it is intended to be used in testing. The first implementation relies on JDK’s ResourceBundle implementation. Reloading a resource bundle during execution is not possible, as ResourceBundle caches loaded bundles files forever, so the implementation usually used in a web application is ReloadableResourceBundleMessageSource, which is a Spring-specific implementation that accesses bundles using specified base names, participating in the Spring ApplicationContext’s resource loading. This class supports reloading properties files containing the internationalization information; it is usually slightly faster than ResourceBundleMessageSource. Another advantage is that it can read properties files with a specific character encoding. In the following, you can see a simple XML configuration of this bean: <bean id=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\"> <property name=\"basenames\"> <list> <value>/WEB-INF/messages/global<value/> </list> </property> <property name=\"cacheSeconds\">1</property> </bean> When only one resource bundle and the p-namespace are used, the previous definition becomes this: <bean id=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\" p:basename=\"/WEB-INF/messages/global\" p:cacheSeconds=\"1\"/> 85 Chapter 3 ■ Spring MVC When Java-based configuration is used, the bean definition looks like this: @Bean public MessageSource getMessageSource(){ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename(\"/WEB-INF/messages/global\"); messageSource.setCacheSeconds(1); return messageSource; } The cacheSeconds property is used to set the number of seconds to cache the loaded property files. Internationalization messages are loaded from properties files under /WEB-INF/messages/; they are named global_[locale].properties. To use the messageSource bean to retrieve internationalized resources inside handler methods, simply inject the bean in the controller and call the desired getMessage(...) method. The Spring type library is used for this purpose too. The fmt tag library, which is a component of JSTL, can be used too. The syntax is a little different, as you can see in the following example: <!-- JSTL fmt way --> <fmt:message key=\"menu.home\"/> <!-- Spring way --> <spring:message code=\"menu.home\"/> When using the spring:message tag, the MessageSource classes can be integrated with the Spring context. The spring:message- tag works with the locale support that comes with Spring. If the “code” attribute isn’t set or cannot be resolved, the “text” attribute is used as the default message. And spring:message supports dynamic names for internationalization codes, so a message code can be an expression: <spring:message code=\"myPrefix.${account.state}\"/> ReloadableResourceBundleMessageSource is able to load messages from properties files with a specific encoding. In order for those messages to be successfully incorporated in a view, Spring provides a class called CharacterEncodingFilter, which is used to apply character encoding to requests. It can work in two modes to do the following: • Enforce the encoding • Apply the encoding if one is not already defined This bean is added to the web.xml file like this: <filter> <filter-name>characterEncodingFilter</filter-name> <filter-class>o.s.web.filter.CharacterEncodingFilter</filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> 86 Chapter 3 ■ Spring MVC <init-param> <param-name>forceEncoding</param-name> <param-value>true</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterEncodingFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> Equivalent Java-based configuration looks like in the following code snippet: \\\\in class implementing WebApplicationInitializer @Override protected Filter getServletFilters() { CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(\"UTF-8\"); characterEncodingFilter.setForceEncoding(true); return new Filter { characterEncodingFilter}; } LocaleResolver In order for the messageBean to solve the messages, a locale must be defined for a web application. The value for the locale is taken from the browser. The bean resolving the locale must be named localeResolver and it must implement the LocaleResolver interface, because the DispatcherServlet looks for such a bean to use. A LocaleResolver can also store a different locale defined by the user. In Spring, there are three types of locale resolvers defined: • AcceptHeaderLocaleResolver: Reads the locale from the request • CookieLocaleResolver: Reads/writes the locale from/to a cookie named org. springframework.web.servlet.i18n.CookieLocaleResolver.LOCALE (unless named otherwise in the bean definition using property cookieName) • SessionLocaleResolver: Reads/writes the locale from/to an HTTP session ■ ! the default name of the cookie can be confusing because it looks like a full name for a static variable, but no such variable exists. the same applies to the theme cookie mentioned in the next section. When a specific LocaleResolver is not defined, AcceptHeaderLocaleResolver is used as default. When users select language, CookieLocaleResolver or SessionLocaleResolver can be used. CookieLocaleResolver is most often used in stateless applications without user sessions; this bean is defined in the mvc-config.xml file. The following definition is quite common: <bean id=\"localeResolver\" class=\"o.s.w.s.i18n.CookieLocaleResolver\" p:defaultLocale=\"en\" p:cookieMaxAge=\"3600\"/> 87 Chapter 3 ■ Spring MVC The cookieMaxAge sets the maximum age in seconds for the cookie. If set to –1, the cookie is deleted only when the client shuts down. In order for Spring to be notified of the changes in the locale, a bean of type LocaleChangeInterceptor needs to be configured. This ensures that the locale interceptor will be applied to all handler mappings. <mvc:interceptors> <bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /> </mvc:interceptors> An equivalent Java configuration for this bean can be used by providing an implementation for the addInterceptors method when implementing WebMvcConfigurer or overriding the same method when extending WebMvcConfigurerAdapter: \\\\in the @Configuration and @EnableWebMvc annotated class @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(localeChangeInterceptor()); \\\\other interceptors can be added here } @Bean public LocaleChangeInterceptor localeChangeInterceptor(){ return new LocaleChangeInterceptor(); } This interceptor detects requests to change the locale by looking for a request parameter named locale by default. The LocaleResolver bean is used to store the value of this parameter. A different name can be set by using a different value for the parameterName property. Request URLs to change the locale are expected to contain the parameter name and a value in the URL: http://myapp.com/?",
    "answer": "[parameterName]=[locale_name] (under /WEB-INF/messages/ a [filename]_[locale_name].properties files is defined). ThemeResolver If the web application has a customizable look and feel, the different themes can be managed using a bean named themeResolver. The bean resolving the theme has to implement the ThemeResolver interface, because the DispatcherServlet looks for such a bean to identify the resources needed for creating a response. To use a ThemeResolver, you have to do the following: 1. Create a [theme].properties file on the classpath (under /WEB-INF/classes/). The “theme” term can be replaced with any word describing that theme. In it, add the properties specific to that theme. In the code samples attached to this",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "FixedThemeResolver: The default implementation uses a configured default theme • CookieThemeResolver: Reads/writes the theme attribute from/to a cookie named org.springframework.web.servlet.theme.cookieThemeResolver.THEME (unless named otherwise in the bean definition using property cookieName) • SessionThemeResolver: Reads/writes the theme attribute from/to a HTTP session Figure 3-8. List of cookies for the Personal Records Manager application 89 Chapter 3 ■ Spring MVC You can view the two cookies using the Firebug extension for Firefox by opening the console and looking in the Cookies tab. You should see a cookie listing similar to the one shown in Figure 3-8. For Spring to be notified of the changes in the theme, a bean of type ThemeChangeInterceptor needs to be configured. This ensures that the theme interceptor is applied to all handler mappings: <mvc:interceptors> <bean class=\"org.springframework.web.servlet.theme.ThemeChangeInterceptor\" /> </mvc:interceptors> An equivalent Java configuration for this bean can be used by providing an implementation for the addInterceptors method when implementing WebMvcConfigurer or overriding the same method when extending WebMvcConfigurerAdapter: \\\\in the @Configuration and @EnableWebMvc annotated class @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(themeChangeInterceptor()); \\\\other interceptors can be added here } @Bean public ThemeChangeInterceptor themeChangeInterceptor(){ return new ThemeChangeInterceptor(); } This interceptor detects requests to change the theme by looking for a request parameter named theme by default. The ThemeResolver bean is used to store the value of this parameter. A different name for it can be set by using a different value for the parameterName property. Request URLs to change the theme are expected to contain the parameter name and a value defined in the application: http://[parameterName]?",
    "answer": "theme=[theme_name] (under /WEB-INF/classes/ a [theme_name].properties files is defined). HandlerExceptionResolver Exceptions can be thrown during handler mapping or execution. Spring MVC catches and handles the exceptions using implementations of HandlerExceptionResolver. The developer writing the application can customize the beans provided by Spring or provide his own implementation. The typical way to treat an MVC exception is to prepare a model and select an error view. Multiple exception resolvers can be used to treat different types of exceptions in different ways. They can also be chained using the order property like any other infrastructure bean. Spring MVC supports the following default resolvers: org.springframework.web.servlet.HandlerExceptionResolver= o.s.w.s.m.a.AnnotationMethodHandlerExceptionResolver,\\ o.s.w.s.m.a.ResponseStatusExceptionResolver,\\ o.s.w.s.m.s.DefaultHandlerExceptionResolver 90",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Maps exception classes to view names • Specifies a default error page for any exception that is not handled • Logs a message if configured to do so by setting a logger name for the warnLogCategory property • Sets the name of the exception attribute to add to the model so it can be used inside a view The following is an example on how to configure a SimpleMappingExceptionResolver bean to map exception types to error views, depending on the class name: <bean class=\"o.s.web.servlet.handler.SimpleMappingExceptionResolver\"> <property name=\"exceptionMappings\"> <map> <!-- No need for package name, any package name will match. If you have two exceptions with the same name in different packages, you need to use the full class name to implement the proper behaviour --> <entry key=\"DataAccessException\" value=\"databaseError\"/> <entry key=\"InvalidPncException\" value=\"pncError\"/> <!-- The databaseError and pncError are logical view names --> </map> </property> <property name=\"defaultStatusCode\" value=\"500\"/> <property name=\"defaultErrorView\" value=\"error\"/> </bean> An equivalent Java configuration can be obtained by defining the bean programmatically: \\\\in the @Configuration and @EnableWebMvc annotated class @Bean(name=\"simpleMappingExceptionResolver\") public SimpleMappingExceptionResolver createSimpleMappingExceptionResolver() { SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver(); Properties mappings = new Properties(); mappings.setProperty(\"DatabaseException\", \"databaseError\"); mappings.setProperty(\"InvalidPncException\", \"pncError\"); resolver.setExceptionMappings(mappings); // None by default resolver.setDefaultStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value()); resolver.setDefaultErrorView(\"error\"); return resolver; } 91 Chapter 3 ■ Spring MVC ■ ! Views returned from @ExceptionHandler methods do not have access to the exception, but views defined to SimpleMappingExceptionResolver do. this means that when using SimpleMappingExceptionResolver, the @ExceptionHandler methods must construct and return a ModelAndView instance. (See example in the 02-pr-mvc-basic-solution module.) in order to return a logical view name from a method annotated with @ExceptionHandler, ExceptionHandlerExceptionResolver must be extended. To provide a custom implementation, the SimpleMappingExceptionResolver can be extended; its methods can be overridden to provide the desired functionality. Methods annotated with @ExceptionHandler can be used to handle exceptions inside a single controller or they may apply to many when defined inside a class annotated with @ControllerAdvice. Annotated exception handler methods are automatically called when controller methods throw an exception, and the method does not treat it itself. Method signatures are as flexible for an exception handler method as the controller handler methods (this is discussed in the “Controllers” section). Next you see an exception handler method used to handle database exceptions for the PersonsController class: @Controller public class PersonsController { ... @ExceptionHandler public String handleException(DataAccessException ex) { return \"databaseError\"; } } The @ExceptionHandler can be set to treat a specific type of exception, using the annotation parameter, thus rendering the exception argument of the method unnecessary. @Controller public class PersonsController { ... @ExceptionHandler(DataAccessException.class) public String handleException() { return \"databaseError\"; } } But using a parameter gives access to the exception, which can be treated or logged. Of course, the two approaches can be mixed. The @ExceptionHandler can be set to treat an array of exceptions. If an exception is thrown that matches one of the types in the list, then the method annotated with the matching @ExceptionHandler is invoked. The same can be done by setting the array as an argument for the annotated method. By using different @ExceptionHandler annotated methods for each type of exception, the code can become crowded. So exceptions can be grouped by different criteria; for example, an @ExceptionHandler method can handle a group of database access exceptions, another can treat security exceptions, and so on. The chosen approach depends on the exception handling specifications of a project and developer preference. 92 Chapter 3 ■ Spring MVC Spring MVC internal exceptions raised while processing a request are translated by a class named DefaultHandlerExceptionResolver to specific error codes: a client error (4xx) or a server error (5xx), which is set on the response. This class is registered by default with the MVC namespace and @EnableWebMVC. But when writing your own exceptions, you can set the status code on the exception class, like this: @ResponseStatus(value= HttpStatus.NOT_FOUND, reason=\"Requested item not found\") public class NotFoundException extends Exception { ... } A class annotated with @ControllerAdvice allows you to use the same exception handling techniques across the whole application, not just a single controller. Three types of methods are supported inside a class annotated with @ControllerAdvice: • Methods annotated with @ExceptionHandler that are used to handle exceptions • Methods annotated with @ModelAttribute that are used to add data to the model • Methods annotated with @InitBinder that are used for configuring form-handling A controller advice class used only for exception handling could look like in the following example, which depicts a global default exception handler: @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception { if (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != null){ // we test to see if the exception is annotated with @ResponseStatus // if it is, we will re-throw it and let Spring handle it. throw e; } ModelAndView mav = new ModelAndView(); //set exception details to be displayed in the page mav.addObject(\"exception\", e); //set request URL to be displayed in the page, so the request causing //the problem can be identified mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(\"error\"); return mav; } } 93 Chapter 3 ■ Spring MVC ■ ! notice in the previous example that the exception handler method returns a ModelAndView instance that is created inside the method body. the reason for this is that the methods in classes annotated with @ControllerAdvice are methods that apply to a group of controllers in the application. this can be customized via annotations(), basePackageClasses(), and basePackages() methods. But the methods are not part of the controller, so a model cannot be automatically injected by Spring. also, a global exception handler like this one uses the same view to display all exception-specific messages in the application, so the view must be linked to the model, which in this case can only be done by creating a ModelAndView instance that is handled appropriately by the DispatcherServlet. If you want to analyze the full capabilities of treating exceptions with Spring MVC, you can take a look at tutorials posted on their official site.11 For passing the certification exam, all that was presented here should suffice. User-Provided Components Although Spring MVC offers a lot of ready-to-use components for creating web applications (all that is required are small customizations), there are components that need to be implemented by the developer. Such components are controllers and interceptors. Controllers include and are the focus object of everything that has been presented so far. Controllers are the handlers identified by handler mappings; their methods handle application requests and return views. They can use message source to populate models with internationalized data and can contain methods for exception handling. If until now it was hard to connect all the infrastructure beans and picture what exactly they did, this mystery will be solved in the “Controllers” section, which puts every LEGO piece in its proper place. The handler interceptors are not really a big thing compared to it, but they are useful too. Controllers Controllers are POJOs—simple beans annotated with the @Controller annotation—that are used to handle requests. Each controller class contains methods that are mapped to a request URL via the @RequestMapping annotation. These methods are used to handle different requests. Each method executes three steps: 1. Invoke services. 2. Populate a model. 3. Select a view. 11A detailed explanation of exception handling using Spring MVC is at https://spring.io/blog/2013/11/01/ exception-handling-in-spring-mvc. 94 Chapter 3 ■ Spring MVC Here is a simple controller example. Notice the syntax for @RequestMapping annotation. @Controller @RequestMapping(\"/persons\") public class PersonsController { private PersonManager personManager; @Autowired public PersonsController(PersonManager personManager) { this.personManager = personManager; } // Handles requests to list all persons. @RequestMapping(value=\"/\", method = RequestMethod.GET) public String list(Model model) { model.addAttribute(\"persons\", personManager.findAll()); return \"persons/list\"; } //Handles requests to shows detail about one person. @RequestMapping(value=\"/{id}\", method = RequestMethod.GET) public String show(@PathVariable Long id, Model model) { model.addAttribute(\"person\", personManager.findOne(id)); return \"persons/show\"; } } When @RequestMapping is used to annotate a controller class, the path that the controller is mapped to is a part of the request’s URL. The previous methods handle requests looking like this: # handled by the list menthod http://localhost:8080/persons/ # handled by the show menthod http://localhost:8080/persons/144 All handling methods are relative to the path set by the @RequestMapping at class level. This means that the class mapping is solved first, and then the request mapping. ■ ! a controller can have methods that are not annotated with @RequestMapping. these methods are not used to solve requests. they are practically ignored, processing a user request. 95 Chapter 3 ■ Spring MVC The methods of a controller can be mapped using @RequestMapping with the following URI templates: • By URL only: @RequestMapping(\"persons/list\") public String list(Model model) { ... } • By URL and request method: @RequestMapping(\"persons/list\", method = RequestMethod.GET) public String list(Model model) { ... } • By URL with request parameters: @RequestMapping(value=\"/persons/show\", params={\"id\"}) public String show(@RequestParam(\"id\") Long id, Model model) { ... } • By URL with a parameter and a specific value for it: @RequestMapping(value=\"/persons/show\", params={\"id=1123\"}) public String show(@RequestParam(\"id\") Long id, Model model) { ... } • By URL with a path variable: @RequestMapping(value=\"/persons/{id}\") public String show(@PathVariable(\"id\") Long id, Model model) { ... } • By URL with a path variable and a regular expression that the value must match: @RequestMapping(value = \"/{id:[\\\\d]*}\") //the regular expression [\\\\d]* insures the id to be numeric, //made of one or more digits. public String show(@PathVariable(\"id\") Long id, Model model) { ... } 96 Chapter 3 ■ Spring MVC The preceding are simple examples of URIs onto which controllers methods are mapped. The options do not stop here and any of these can be mixed, depending on the developer’s needs. For example, you can do something like this in web applications: @RequestMapping(value=\"/persons/{id}/?",
    "answer": "dateOfBirth=1983-08-18\") public String show(@RequestParam(\"dateOfBirth\") Date date, @PathVariable Long id, Model model) { ... } The controller methods can have very flexible signatures. The following can be used as arguments in any combination or order:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Model • HttpServletRequest • HttpServletResponse • HttpSession • Locale • Principal In the body of a controller method, path variables and request parameters must be accessed to process the request. If the URI template is a RESTful URI,12 then the variable is part of the URI, called a path variable, and can be accessed using @PathVariable: @RequestMapping(value=\"/persons/{id}\") public String show(@PathVariable(\"id\") Long identifier, Model model) { ... } ■ CC When the method argument has the same name with the path variable, the value for the @ PathVariable annotation is no longer required. So the preceding method becomes: @RequestMapping(value=\"/persons/{id}\") public String show(@PathVariable Long id, Model model) { ... } 12A RESTful URI identifies a domain resource (like a book, or a person, in this case) rather than an application resource like a web page or a form. URI is the acronym for Uniform Resource Identifier. URL is the acronym for Uniform Resource Locator. REST services work only with URIs and @PathVariable. 97 Chapter 3 ■ Spring MVC And handles requests similar to: http://localhost:8080/persons/144. There is a special case when the @PathVariable is not even needed and the default is the argument name; this happens when the application is compiled with debug symbols enabled. It is rarely used because the result is an unoptimized/debuggable byte code. This is mentioned here because the official course mentions it too, and it might be useful to know that this possibility exists in case you ever need it. When the URI is non-RESTful, the variable is provided as a parameter in the request URL. The request parameter can be accessed using the @RequestParam annotation. @RequestMapping(value=\"/persons/show\", params={\"id\"}) public String show(@RequestParam(\"id\") Long identifier, Model model) { ... } Type conversion is applied, and if the parameter value is missing or has the wrong type, an exception is thrown. ■ CC When the method argument has the same name with the request parameter, the value for the @RequestParam annotation is no longer required. the params property is no longer needed for the @RequestMapping either. So the preceding method becomes this: @RequestMapping(value=\"/persons/show\") public String show(@RequestParam Long id, Model model) { ... } The request parameter can be set as optional if it is not a primitive type; in this case, it defaults to null and must be handled in the method body. @RequestMapping(value=\"/persons/show\", params={\"id\"}) public String show(@RequestParam(value=\"id\", required=false) Long identifier, Model model) { if(identifier == null) { //return a specific view } ... } The request parameter can also be set as optional when the request parameter is a primitive type and a fallback default value is provided. @RequestMapping(value=\"/persons/show\", params={\"id\"}) public String show(@RequestParam(value=\"id\", required=false, defaultValue = \"2\") long identifier, Model model) { if(identifier == null) { //return a specific view } ... } 98 Chapter 3 ■ Spring MVC Request parameters can have any type, including Date and Number, and these types can be formatted by using the following annotations: //matches http://localhost:8080/persons/1983-08-18 @RequestMapping(value=\"/persons/{birthDate}\") public String list(@PathVariable @DateTimeFormat(pattern = \"yyyy-MM-dd\") Date birthDate, Model model) { ... } //matches http://localhost:8080/accounts/?",
    "answer": "minAmount=$5000.50 @RequestMapping(value=\"/accounts\" params={\"minAmount\"}) public String list(@RequestParam @NumberFormat(style = NumberFormat.Style.CURRENCY) Double minAmount, Model model) { ... } To generate a Spring-parametrized URI in a JSP file, a combination of <spring:url> tag and <spring:param/> is used: <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> ... <spring:url var=\"showUrl\" value=\"{id}\"> <spring:param name=\"id\" value=\"${person.id}\"/> </spring:url> <a href=\"${showUrl}\">${person.id}</a> The first three lines of the preceding example generate a URI similar to http://localhost:8080/ person/123 by using the current context of the application and the person attribute in the model. The generated URI is stored as a value for the showUrl attribute in the model. In the next line, that attribute is used to populate the HTML link element. After the execution of the code in a mapping method, the controller selects a view for the resulting data to be rendered in. The controller’s responsibility includes populating a model map with the data to display in the view. There are multiple ways of specifying the resulting view too, but the default is for the mapping method to return a string, which is the logical view name. (By default, a path to a JSP file is expected, unless some view resolver is used, such as TilesResolver, for example). Also, the controller can directly write to the response stream and complete the request (when handling AJAX calls or REST services, cases that are presented in detail in the following chapters). The process to identify which view is being used is called view resolution, which is performed by one view resolver class or a chain of view resolver classes. 99",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Person person = personManager.getById(id); model.addAttribute(person); //added as \"person\" as the reference type is Person • List<Person> persons = personManager.findAll(); model.addAttribute(persons); // added as \"personList\" as reference type is List<Person> ■ CC When objects are added to a model without specifying an attribute name, this is inferred by lowercasing the first letter of the reference type. if the attribute is a collection of objects, the attribute name is composed from the reference type with first letter lowercased and suffixed with the specific collection suffix (a simple name of the Collection interface implemented): “Set” for Set<?",
    "answer": ">, “List” for List<?>, etc. When only one object needs to be added to the model, the object can simply be returned by the method and it is automatically added to the model. This obviously does not work with objects of type String, because Spring assumes the returned String value is a logical view name. When the following approach is used, the returned object is added to the model as an attribute and the name is inferred based on the conventions mentioned earlier. @RequestMapping(\"/persons/list\") public List<Person> list() { return personManager.findAll(); //model name attribute convention will be used } But the attribute name can be specified by annotating the method with @ModelAttribute and specifying a different attribute name. @RequestMapping(\"/persons/list\") @ModelAttribute(\"persons\") public List<Person> list() { return personManager.findAll(); } 100",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "preHandle: Called after the HandlerAdapter has identified the handler method and before its invocation. This method controls the execution of other interceptors in the chain and the handler method by returning a Boolean value. • postHandle: Called after the HandlerAdapter invokes the handler method and before the DispatcherServlet renders the view (can add extra objects to the model). • afterCompletion: Called after the request has processed and the view has rendered. This method is called regardless of the outcome of the handler method call; it can be used for resources cleanup (behavior similar to a finalize method). The interceptors that modify the response before serialization must implement ResponseBodyInterceptor and provide an implementation for the beforeBodyWrite method. (This is covered in more detail in Chapter 5. 106 Chapter 3 ■ Spring MVC When personalizing the application with locale and theme, the LocaleChangeInterceptor and ThemeChangeInterceptor are configured like this: <!-- XML --> <mvc:interceptors> <bean class=\"o.s.web.servlet.i18n.LocaleChangeInterceptor\"/> <bean class=\"o.s.web.servlet.theme.ThemeChangeInterceptor\"/> </mvc:interceptors> //Java Configuration //in the @Configuration and @EnableWebMvc annotated class @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(localeChangeInterceptor()); registry.addInterceptor(themeChangeInterceptor()); } @Bean public LocaleChangeInterceptor localeChangeInterceptor(){ return new LocaleChangeInterceptor(); } @Bean public ThemeChangeInterceptor themeChangeInterceptor(){ return new ThemeChangeInterceptor(); } Both interceptors use their preHandle method to set locale and theme values on the appropriate resolvers.15 Users can also create their own interceptors; in 02-pr-mvc-basic-solution the AuditInterceptor is given as an example. @Component public class AuditInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // custom implementation here return true; } 15You can take a look at these interceptors’ code on GitHub at https://github. com/spring-projects/spring- framework/blob/master/spring- webmvc/src/main/java/org/ springframework/web/servlet/theme/ ThemeChangeInterceptor.java and https://github.com/spring-projects/spring-framework/blob/master/ spring-webmvc/src/main/java/org/springframework/web/servlet/i18n/LocaleChangeInterceptor.java. 107 Chapter 3 ■ Spring MVC @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // custom implementation here } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // custom implementation here } } To enable this interceptor, you have to configure it in the context. The following snippets show how this can be done in XML and using Java configuration: <!-- XML --> <mvc:interceptors> <bean class=\"com.pr.interceptor.AuditInterceptor\"/> </mvc:interceptors> //Java Configuration //in the @Configuration and @EnableWebMvc annotated class @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(auditInterceptor()); } @Bean public AuditInterceptor auditInterceptor(){ return new AuditInterceptor(); } The schema in Figure 3-9 displays what happens “behind the scenes” when a handler interceptor is used in a Spring MVC application. 108 Chapter 3 ■ Spring MVC Figure 3-9. Handler Interceptor methods and places where invoked View Technologies Again, Spring MVC was designed to be as view agnostic as possible. Most web applications generate HTML content. The “ViewResolver” section mentions how a Spring web application can generate other types of content, such as PDF, Excel, or JSON. The complete list of view technologies that Spring supports is far longer than this. To put it in perspective, anything that provides a ViewResolver and a View implementation is compatible with Spring. Based on the type of content being generated, the views can be categorized as follows: • Display views: The response is an HTML page generated using a template: JSP, Tiles, Thymeleaf, FreeMarker, or Velocity. • File-generating views: The response is an output file when rendered and it is automatically downloaded by the browser: Apache POI, JExcelApi (Excel), IText (PDF), JasperReports, or XSLT transformation. • Data-delivery views: The response is actually just data and it is meant to be used with AJAX and web services: JSON, Java-XML Marshalling, Atom, and RSS. This book covers Tiles and Thymeleaf. Tiles is in the official certification course. Thymeleaf is a bonus section that was added because it is the newest template engine in the web development world (its “birth” year was 2014) and it is quite a promising technology. Its goal is to provide templates that are easy to use and extend. It works in web and non-web environments. 109 Chapter 3 ■ Spring MVC ■ ! the book-code module 03-chapter-07-solution covers all three categories of the views mentioned. take a look at it before advancing to the next section. Tiles Layouts A web application of composed of more html pages which have a common structure, typically a header/ footer, a menu for navigation, and a section with the actual content of the page. The header, footer, and navigation menu are usually the same on every page and they can separate from the contents of a page in their own files to be reused every time a new page is created. If you were working with JSP, the files header. jsp, footer.jsp, and menu.jsp would be included in every page by using <jsp:include page=...\"/>. This means three repetitive include statements in every page. A more practical approach is to create a page template that contains common page elements and placeholders for dynamic content, similar to what is depicted in Figure 3-10. The placeholders are replaced at rendering time with whatever is needed (usually subviews).16 Figure 3-10. Reusable page template 16This approach is described by the Composite View pattern that introduces the notions of composite and atomic views. A composite view is a tree structure of atomic views. An atomic view can be included dynamically and it changes based on the context. 110 Chapter 3 ■ Spring MVC Doing this with only plain JSP is not an option. There are currently multiple ways available to do it. But the one that was interesting for the Spring creators is Apache Tiles. Apache Tiles is an open source template engine framework that was a part of the currently deceased Apache Struts 1. It is based on the Composite View pattern and was built to simplify the development of user interfaces. To use tiles in a Spring web application, you have to do the following: 1. Define template layout for the pages. 2. Configure tiles definitions in tiles.xml file(s). 3. Configure the tiles resolver bean. Apache Tiles 3.0.5, which is the version used for the code samples, is the most recent stable release at the time this book was written. Define Page Templates A simple template layout, matching the page representation in Figure 3-10, is as simple as this: ... <%@ taglib prefix=\"tiles\" uri=\"http://tiles.apache.org/tags-tiles\" %> ... <!-- /WEB-INF/templates/layout.jsp --> <head> <tiles:insertAttribute name=\"pageTitle\"/> </head> <body> <div class=\"header\">...</div> <div class=\"menu\">...</div> <div class=\"content\"> <tiles:insertAttribute name=\"content\"/> </div> <div class=\"footer\">...</div> </body> Configure Tiles Definitions The tiles.xml files are Tiles configuration files, which define the structure of a page using XML. One or more tiles definitions can be in the same file; it is recommended to store the configuration file and the pages configured in the same directory, as shown in Figure 3-11. 111 Chapter 3 ■ Spring MVC Figure 3-11. Tiles configuration files and templates positioning in the application structure Tiles definitions are reusable fragments consisting of a template and attributes. Inheritance is possible using the extends attribute. A tile definition element looks like this: <!DOCTYPE tiles-definitions PUBLIC \"-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN\" \"http://tiles.apache.org/dtds/tiles-config_3_0.dtd\"> <tiles-definitions> <definition name=\"layout\" template=\"/WEB-INF/templates/layout.jsp\"/> </tiles-definitions> This example is called a base tile because every other definition extends it. Without this tile definition, every other tile definition in your project has to be configured with the template attribute, underlined in the preceding example. The extended version of the layout.jsp is quite big, and some parts are replaced by “...” . To view its real and full content, please see the 03-pr-mvc-layout-practice project. ... <%@ taglib prefix=\"tiles\" uri=\"http://tiles.apache.org/tags-tiles\" %> ... <!-- /WEB-INF/templates/layout.jsp --> <head> ... 112 Chapter 3 ■ Spring MVC <title> <spring:message> <tiles:insertAttribute name=\"pageTitle\"/> </spring:message> </title> </head> ... <div class=\"page\"> <!-- The header is actually a png image banner, that will be loaded depending on the chosen theme--> <div class=\"banner\"></div> <!-- section to select Locale and Theme --> <div class=\"themeLocal\"> ...</div> <!-- section with the navigation menu, dynamic data The menu item is modified to display the current page based on the value for the menuTab attribute --> <div class=\"menu\"> <ul> <li><c:if test=\"${menuTab eq 'home'}\"> <strong> <a href=\"<c:url value=\"/\"/>\"><spring:message code=\"menu.home\"/></a> </strong> </c:if> <c:if test=\"${menuTab != 'home'}\"> <a href=\"<c:url value=\"/\"/>\"><spring:message code=\"menu.home\"/></a> </c:if> </li> ... </ul> </div> <!-- Dynamic data - body of the page --> <div class=\"content\"> <tiles:insertAttribute name=\"content\"/> </div> <div class=\"footer\"> <p><spring:message code=\"footer.text\"/></p> </div> This is what a simple tile definition that extends the base tile looks like: <definition name=\"home\" extends=\"layout\"> <put-attribute name=\"pageTitle\" value=\"home.title\"/> <put-attribute name=\"content\" value=\"/WEB-INF/home.jsp\"/> <put-attribute name=\"menuTab\" value=\"home\" /> </definition> 113 Chapter 3 ■ Spring MVC The tiles attributes are the placeholders for dynamic data; the gaps in the template need to be filled. The following can be an attribute: • A string that will be rendered or used as it is. • A template with or without attributes that need to be filled to render the page. • A tile definition with all (some) attributes filled. ■ ?",
    "answer": "in the code sample, can you identify which of these types of tiles attributes were used? Accessing tiles attributes in JSP is done using the tag provided by tiles:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "<tiles:insertAttribute/>: The standard approach to insert the value of an attribute into a page17 • <tiles:importAttribute/>: This is used to add attributes to model (it works only with Spring)18 In the following example, the menuTab attribute is used for navigation in the application. Each tile definition sets a different value for that attribute. The value is tested and the menu navigation option matching the current page is displayed in bold text. ... <tiles:importAttribute name=\"menuTab\" /> <c:if test=\"${menuTab eq 'home'}\"> <!-- show the home menu option with bold text --> </c:if> Configure the Tiles Resolver Bean Spring MVC provides out-of-the-box support for Apache Tiles. There is a TilesView to interpret logical view names as tiles definitions. There is a TilesViewResolver bean to resolve views and a class named TilesConfigurer to bootstrap Tiles with a set of configuration files. <!-- Resolves view names to Tiles 3 definitions --> <bean id=\"tilesViewResolver\" class=\"org.springframework.web.servlet.view.tiles3.TilesViewResolver\"/> <!-- Configures Tiles 3 --> <bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3.TilesConfigurer\"> <property name=\"definitions\"> 17Detailed API information on tiles:insertAttribute is at https://tiles.apache.org/framework/ tiles-jsp/tlddoc/tiles/insertAttribute.html. 18Detailed API information on tiles:importAttribute is at https://tiles.apache.org/framework/ tiles-jsp/tlddoc/tiles/insertAttribute.html. 114 Chapter 3 ■ Spring MVC <list> <value>/WEB-INF/tiles.xml</value> <!-- add more tiles definition files if present --> </list> </property> </bean> The equivalent Java configuration looks like this: // In the @Configuration and @EnableMvc annotated class @Bean TilesViewResolver tilesViewResolver(){ return new TilesViewResolver(); } @Bean TilesConfigurer tilesConfigurer(){ TilesConfigurer tilesConfigurer = new TilesConfigurer(); tilesConfigurer.setDefinitions(\"/WEB-INF/tiles.xml\"); // add more tiles definition files if present return tilesConfigurer; } This code sample replaces the InternalResourceViewResolver with TilesViewResolver. The InternalResourceViewResolver can be configured for plain *.jsp files too, but do not forget to set the order property and/or configure a content negotiating resolver. ■ ! the module 03-pr-mvc-layout-practice of the personal records Manager project covers tiles definitions and their usage with Spring MVC. Further details are presented in the practice section of this chapter, but you can take a look at the 03-pr-mvc-layout-solution if you cannot wait to see the tiles in action. Thymeleaf When asked why he decided to create another template engine, because there were already quite a few available, co-creator Daniel Fernandez said this on the Thymeleaf official forum:19 In my humble opinion, Spring MVC 3 is a fantastic web framework tied to a horrible, extremely old and spaghetti-code-loving template engine: JSP. That’s why I wanted the combination of Spring MVC with Thymeleaf to really shine. In some ways I suppose I wanted to give Spring MVC the template engine it deserved. Not from the performance point of view (matching the speed of JSPs, which run in specialized containers, would be very difficult), but more from the points of view of code elegance, readability, and design/ coding separation of concerns. Also, I wanted to provide first-class support for the emerging HTML5 standard. 19A full discussion is at http://forum.thymeleaf.org/why-Thymeleaf-td3412902.html. 115 Chapter 3 ■ Spring MVC The underlined text in Fernandez’s reply should interest any developer. Thymeleaf is not a certification exam subject, so it can be skipped. But Thymeleaf is nevertheless a practical alternative to JSP, and the SpringSource team fancies it quite a bit, so knowing how to configure it and use it could be useful in the future. Both Spring and Tiles come with an attribute set that you can use to write your page templates. Thymeleaf is more flexible because it allows you to define a set of template attributes or even tags with the names that you want and with the logic that you want. So it is not just a template engine, it is a framework. Something called standard dialects are offered: Standard and SpringStandard, which contain all you might need to create a page template. You can recognize them in a page because they are prefixed with \"th:\". The two dialects are almost identical, but the one created for Spring has additional capabilities for integrating into Spring MVC applications (it supports SpEl , the Spring expression language). Most Thymeleaf attributes allow their values to be set as or containing expressions called Standard Expressions, which can be of the following types: • Variable expressions <td th:text=\"${person.firstName}\"></td> <!-- or --> <tr th:each=\"person : ${personList}\"> • Selection or asterisk expressions: These are executed on a previously selected object instead of the entire context variables map. <div th:object=\"${person}\"> <p th:value=\"*{firstName} *{lastName}\"></p> </div> • Text externalized expressions (internationalization expressions) used to retrieve locale specific messages from external sources (*.properties files). They even accept parameters. <tr> <td th:text=\"#{person.label.firstname} & #{person.label.lastname}</td> <!-- or --> <td th:text=\"#{person.created(${id})}\"</td> </tr> • URL expressions used to generate session- and context-specific URIs (equivalent to <spring:url/> and <c:url/>). <img alt=\"Simple tymeleaf application\" title=\"logo\" th:src=\"@{/images/banner.png}\"/> <form th:action=\"@{/createPerson}\"> <a href=\"show.html\" th:href=\"@{/persons(id=${person.id})}\"> Thymeleaf allows HTML attributes so that templates can link to each other nicely when opened directly in a browser, outside the context of the application, in the same way that Thymeleaf attributes link to each other when executed in the context of a web application. In the previous example, if you want to view your template before deploying the application, you can open the file in a browser and the th:href will be replaced by the values of the static href. 116 Chapter 3 ■ Spring MVC Considering the following Thymeleaf template: ... <h4> Welcome to the sample page with Spring MVC and Thymeleaf! <br/> Here is a list of random persons: </h4> <div class=\"content\" th:if=\"${not #lists.isEmpty(personList)}\"> <table> <thead> <tr> <td>Cnt.</td> <td>First Name</td> <td>Last Name</td> </tr> </thead> <tbody> <tr th:each=\"person,iterationStatus : ${personList}\"> <td><a th:text=\"${iterationStatus.count}\" href=\"show.html\" th:href=\"@{/persons(id=${person.id})}\">1</a></td> <td th:text=\"${person.firstName}\">John</td> <td th:text=\"${person.lastName}\">Smith</td> </tr> </tbody> </table> </div> ... In Figure 3-12 you can see what the page looks like when opened in the browser outside the application context. Figure 3-12. Thymeleaf template page opened in the browser outside the application context 117 Chapter 3 ■ Spring MVC In the application context, all the Thymeleaf expressions are resolved and the resulting page looks like the one shown in Figure 3-13. Figure 3-13. Thymeleaf template page opened in the browser in the application context The URL expression th:href=\"@{/persons(id=${person.id})} turns into a URL with a request parameter; for example, .../persons?",
    "answer": "id=4. To generate a URI, .../persons/4 the expression has to be modified to this: th:href=\"@{/persons/ ${person.id}__}\". The notions presented here are the minimum necessary to create a Thymeleaf simple template. The 03-chapter-08-solution module in the book-code project is a perfect example of how simple it is to create a Thymeleaf template to display a list of persons. All that is left now is to explain how Thymeleaf can be integrated with Spring. Thymeleaf integrates with both Spring 3.x and Spring 4.x and uses two separate libraries, which are packaged in separate *.jar files: thymeleaf-spring3-{version}.jar and thymeleaf-spring4-{version}. jar. As this book is being written, the most current version of Thymeleaf is 2.1.4.RELEASE. The library corresponding to the Spring version used needs to be added to the classpath together with the thymeleaf. jar. Thymeleaf offers a set of Spring integrations equivalent to the ones in JSP:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Spring SpEl can be used in Thymeleaf templates • It creates forms in templates that are completely integrated with form-backing beans and result hidings • It displays internationalization messages from message files managed by Spring via MessageSource To integrate Thymeleaf with Spring, you need to define the following: • The view resolver bean of type ThymeleafViewResolver • The Thymeleaf engine bean of type SpringTemplateEngine used to handle the Thymeleaf expressions • The template resolver bean of type ServletContextTemplateResolver used to configure the location and type of templates that the other beans are expected to work with 118 Chapter 3 ■ Spring MVC <bean id=\"templateResolver\" class=\"org.thymeleaf.templateresolver.ServletContextTemplateResolver\"> <property name=\"prefix\" value=\"/WEB-INF/persons/\" /> <property name=\"suffix\" value=\".html\" /> <property name=\"templateMode\" value=\"HTML5\" /> <!-- Template cache is true by default. Set to false if you want --> <!-- templates to be automatically updated when modified. --> <property name=\"cacheable\" value=\"true\" /> </bean> <bean class=\"org.thymeleaf.spring4.view.ThymeleafViewResolver\"> <property name=\"templateEngine\" ref=\"templateEngine\" /> <property name=\"order\" value=\"1\"/> </bean> <bean id=\"templateEngine\" class=\"org.thymeleaf.spring4.SpringTemplateEngine\"> <property name=\"templateResolver\" ref=\"templateResolver\" /> </bean> And this is all. If you would like to use Thymeleaf in your future projects, you can find all the information you need on their official site at http://www.thymeleaf.org. Also, before continuing to the next section, you might want to run and take a look at the 03-chapter-08-solution module. Forms Starting with version 2.0, Spring provides a set of specialized tags for handling form elements when using JSP and the Spring Web MVC. Each tag provides support for a set of attributes matching the ones in the corresponding HTML element, which makes Spring quite easy for the user. The Spring tag library is integrated into Spring MVC, which allows the tags to have access to the command object and model. The Spring tag library is inside the spring-webmvc.jar. To use the tags in a JSP page, the following directive must be added on top of the JSP page: <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> The \"sf\" prefix is short for spring form. Any prefix can be used, but in this book, \"sf\" was chosen because it is short and its meaning is quite obvious. The \"spring\" prefix will be used for Spring-specific tags that are not related to forms (internationalization and URL generation). In the examples attached to this chapter, you create forms to edit and to search for a person. A form for editing a person is depicted in Figure 3-14. 119 Chapter 3 ■ Spring MVC Figure 3-14. Form used to edit a Person The Spring form tag library provides equivalent elements for the HTML elements needed to design a form, annotations for data binding and data validation, and tools for error processing. The code that creates form follows Figure 3-14. ... <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> ... <div class=\"person\"> <spring:url value=\"/persons/{id}\" var=\"editUrl\"> <spring:param name=\"id\" value=\"${person.id}\"/> </spring:url> <sf:form modelAttribute=\"person\" action=\"${editUrl}\" method=\"POST\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> : </label> </th> <td><sf:input path=\"firstName\"/> <sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> ... <tr> <th> <label for=\"dateOfBirth\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.dob\"/> : </label> </th> 120 Chapter 3 ■ Spring MVC <td><sf:input path=\"dateOfBirth\"/> <sf:errors cssClass=\"error\" path=\"dateOfBirth\"/></td> </tr> <tr> <th> <label for=\"gender\"> <spring:message code=\"label.Person.gender\"/> : </label> </th> <td> <sf:radiobutton path=\"gender\" value=\"MALE\"/> <spring:message code=\"label.Person.male\"/> <sf:radiobutton path=\"gender\" value=\"FEMALE\"/> <spring:message code=\"label.Person.female\"/> </td> </tr> <tr> <th> <label for=\"hospital\"> <span class=\"man\">*</span> <spring:message code=\"label.Hospital\"/> : </label> </th> <td> <sf:select path=\"hospital\"> <c:choose> <c:when test=\"${person == null}\"> <sf:option value=\"\"> <spring:message code=\"label.choose\"/></sf:option> </c:when> <c:otherwise> <sf:option value=\"${person.hospital.id}\"> ${person.hospital.name} </sf:option> </c:otherwise> </c:choose> <sf:options items=\"${hospitalList}\" itemValue=\"id\" itemLabel=\"name\"/> </sf:select> </td> </tr> <tr> <td> <button id=\"saveButton\" type=\"submit\"> <spring:message code=\"command.save\"/> </button> </td> 121 Chapter 3 ■ Spring MVC <td> <a href=\"${editUrl}\"> <spring:message code=\"command.cancel\"/> </a> </td> </tr> </table> </sf:form> </div> In the previous code there are a few elements that are underlined. They are Spring form tags equivalent to HTML form tags. The only difference is that they are fully integrated with Spring MVC and their content is populated from the modelAttribute and other Spring form–specific objects, which are covered a little bit later. The behavior of a Spring form can be described using this succession of steps: 1. An initial GET request causes the form object to be created and presented to the user. 2. The user inserts data in the form and sends a POST request to submit the form. In this step, the data inserted is evaluated, validated, and stored in the form object. 3. POST-Redirect-GET if the operation is successful (if the objective of the POST request has succeeded, a GET request is created to present a confirmation message to the user). Without the POST-Redirect-GET behavior, an application will behave incorrectly, because subsequent POST requests could lead to duplicate data and/or data corruption. The forms used for search operations do not need a POST request, because submitting a search query has no side effects and it redirects to the results page. When working with forms, all the fields in a form should map to the fields of an object called a data transfer object (DTO). In the example, this is done for the Search Person form, which is covered later. When editing a person, it is more suitable to use a Person object as a data transfer object. The Person object is an instance of an @Entity class, and maps to a row in the person table in the database. These types of objects are called domain objects. This requires that the object used for this purpose should have a default constructor, getters, and setters for all the fields used in the form. Although using a domain object as a form object welcomes the undesired possibility that some web logic–specific operations might creep in, it is practical to use when the objects handled are simple20 and entity fields are annotated with specific validation annotations (example: @NotEmpty, NotNull, etc.), because implementing a validator class at the web layer may no longer be necessary. Form-specific data transfer objects are also required when the information from a form is aggregated from multiple domain objects. This allows the form object to encapsulate only what is needed to be displayed on the screen: web layer logic, validation logic, logic for information transfer between the form object, and domain object. Figure 3-15 shows the correspondence between the form tags and the fields in the CriteriaDto object. 20Adam Bien, one of the most respected Java developers in the world, has named DTOs objects “anemic in general and do not contain any business logic” on his blog at http://www.adam-bien.com/roller/ abien/entry/ value_object_vs_data_transfer. 122 Chapter 3 ■ Spring MVC Figure 3-15. Form to search a Person The following can be said when using Spring forms: • The CriteriaDto object is linked to the form via modelAttribute=\"criteriaDto\" and it corresponds to the @ModelAttribute annotated object in the controller class. • The Spring form has a method attribute the same as an HTML form, and the value of this attribute is the type of request being sent to the server. <sf:form action=\"${personsUrl}\" modelAttribute=\"criteriaDto\" method=\"get\"> .... </sf:form> • The Spring form has an action attribute the same as an HTML form, and the value of this attribute is the URL of the request. <spring:url value=\"/persons/go\" var=\"personsUrl\"/> <sf:form action=\"${personsUrl}\" modelAttribute=\"criteriaDto\" method=\"get\"> .... </sf:form> • <sf:input path=\"fieldName\"/> is rendered into an HTML input field that is populated with the value of the field named fieldName in the criteriaDto object. Each of the fields defined in a Spring form specifies a path attribute that corresponds to a getter/setter method of the model attribute (in this case the CriteriaDto object). When the page is loaded, Spring calls the getter of each field to populate the form view. When the form is submitted, the setters are called to save the values submitted by the user using the form to the model attribute fields. • <sf:select/> elements are rendered into HTML select elements and can be constructed using domain object lists: <sf:select path=\"hospital\" itemValue=\"id\" itemLabel=\"name\" items=\"${hospitalList}\"/> 123 Chapter 3 ■ Spring MVC The hospitalList has to be added to the model by the controller as an attribute: model.addAttribute(\"hospitalList\", hospitalRepo.findAll()); • <sf:select/> elements can have customized behavior by using the <sf:option/> and <sf:options/> tag. For example, if the same form is used for editing and creating a person instance, when a new person is created, you might want to display a default option in the hospital drop-down list, making it obvious for the user that a value has to be selected. That default option is not part of the hospital list model attribute. When a person is edited, you want to select the hospital where that person was born. <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> .... <sf:select path=\"hospital\"> <c:choose> <!-- no person attribute, form is used to create a person --> <c:when test=\"${person == null}\"> <sf:option value=\"\"> <!-- default option not in the hospital list model attribute --> <spring:message code='label.choose'/> </sf:option> </c:when> <!-- form is used to edit a person, person model attribute is set --> <c:otherwise> <sf:option value=\"${person.hospital.id}\"> ${person.hospital.name} </sf:option> </c:otherwise> </c:choose> <!-- Dynamic list of options --> <sf:options items=\"${hospitalList}\" itemValue=\"id\" itemLabel=\"name\"/> </sf:select> The preceding example is rendered as an HTML select element containing all hospitals in the hospitalList model attribute and an extra static Choose hospital option when the form is used to create a person. The names of the hospitals are used as labels for the available options in the select element. The JSP c taglib is used for conditional operations. • The Spring JSP tag library integrates nicely with other JSP libraries, like Tiles and JSTL. • The <sf:errors/> is a Spring special tag for displaying errors. The error messages can be internationalized; this is covered in the “Data Validation” section. When it comes to using Spring forms, three key subjects must be well understood to use them like an expert: formatting, data binding, and validation; each of these is given the proper coverage in its own section. 124 Chapter 3 ■ Spring MVC Data Formatting In the Person edit form, you need to display and eventually edit a java.util.Date instance and a Hospital instance. These are complex types and the Spring tag library does not know how to handle them on its own. The developer must provide implementations for the org.springframework.format.Formatter<T> interface for the specific type of object handled in the form. Formatter classes parse text data, turn them into objects, and transform beans into text data ready for rendering. In the 05-pr-mvc-form-solution module, which is the project specific to this section, two formatters are used in the Edit person form; where they are used is shown in Figure 3-16. Figure 3-16. Formatters used in the form to edit a person Formatters can be used in four places in the application: • On the field using annotations (all JSPs pages displaying this annotation use this formatter) @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date dateOfBirth; • In the JSP tags (used when multiple JSP pages need to display data differently) <fmt:formatDate value=\"${person.dateOfBirth}\" pattern=\"yyyy-MM-dd\" /> • Registered in the application using the FormattingConversionServiceFactoryBean bean <mvc:annotation-driven conversion-service=\"typeConversionService\" \"/> <!-- Define a custom ConversionService --> <bean id=\"typeConversionService\" class=\"o.s.format.support.FormattingConversionServiceFactoryBean\"> <property name=\"formatters\"> <set> <bean class=\"com.pr.util.DateFormatter\"/> <bean class=\"com.pr.util.HospitalFormatter\"/> </set> </property> </bean> 125 Chapter 3 ■ Spring MVC The DateFormatter implementation used in the personal-records project looks like this: public class DateFormatter implements Formatter<Date>{ public static final SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\"); @Override public Date parse(String s, Locale locale) throws ParseException { return formatter.parse(s); } @Override public String print(Date date, Locale locale) { return formatter.format(date); } } • On the controller or service method arguments by using implementation of the org. springframework.validation.Validator interface and the @Validated annotation. In the following example, the URI path variable used to request data about a person is of type String and it has to be checked for whether it represents a valid id. @Component public class IdValidator implements Validator { @Override public boolean supports(Class<?",
    "answer": "> clazz) { return String.class.equals(clazz); } @Override public void validate(Object target, Errors errors) { String id = (String) target; if(!id.matches(\"/{id:\\\\d*}\")) { errors.reject(\"id.malformed\"); } } } The controller method to retrieve a person’s data and using that validator looks like this: @RequestMapping(value = \"/{id}\", method = RequestMethod.GET) public String show(@Validated(IdValidator.class)@PathVariable String id, Model model) throws NotFoundException { Long theId = Long.parseLong(id); Person person = personManager.findById(theId); if(person == null) { throw new NotFoundException(Person.class, theId); } model.addAttribute(\"person\", person); return \"persons/show\"; } 126",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "formatting numbers: @NumberFormat(style=Style.NUMBER, pattern=\"#,###.###\") private final BigDecimal amount; • formatting currencies: @NumberFormat(style=Style.CURRENCY) private final BigDecimal amount; When field values are formatted inside a JSP page, formatting annotations are no longer needed. When formatters are registered using the FormattingConversionServiceFactoryBean bean, the specific types are automatically converted without another annotation or tag. The <mvc:annotation-driven/> and @EnableWebMVC registers default formatters for Numbers and Dates by offering support for specific annotations: @NumberFormat and @DateTimeFormat. If Joda Time is in the classpath, support for it is also enabled. Java configuration to register custom formatters can be done in two ways: by defining a @Bean of type ConversionService, or by implementing the addFormatters method defined in WebMvcConfigurer (or by overriding it when implementations of this interface are used). The second way is easier: \\\\in the @Configuration & @EnableWebMvc annotated class @Override public void addFormatters(FormatterRegistry formatterRegistry) { formatterRegistry.addFormatter(getDateFormatter()); formatterRegistry.addFormatter(getHospitalFormatter()); } @Bean public DateFormatter getDateFormatter(){ return new DateFormatter(); } @Bean public HospitalFormatter getHospitalFormatter(){ return new HospitalFormatter(); } The first way is more complicated. The following is an example of an annotated ConversionService bean definition: \\\\ in the @Configuration annotated class public ConversionService conversionService() { FormattingConversionServiceFactoryBean bean = new FormattingConversionServiceFactoryBean(); bean.setFormatters(getFormatters()); bean.afterPropertiesSet(); ConversionService object = bean.getObject(); return object; } 127 Chapter 3 ■ Spring MVC private Set<Formatter> getFormatters() { Set<Formatter> formatters = new HashSet<>(); formatters.add(dateFormatter); formatters.add(dateFormatter); return formatters; } // definition for formatter beans as in the previous example Now you have the conversionService bean. Let’s look at the equivalent for <mvc:annotation-driven conversion-service=\"conversionService\" />: @FeatureConfiguration class MvcFeatures { @Feature public MvcAnnotationDriven annotationDriven( ConversionService conversionService) { return new MvcAnnotationDriven().conversionService(conversionService) } ... } MvcAnnotationDriven provides the same options as the XML elements using a conveniently chained method API. But who needs a complicated way to do this when there is an easier way, right?",
    "answer": "HospitalFormatter is a custom formatter specifically created to be used in projects attached to this book. It basically transforms a Hospital instance into its name so that it can be rendered in a view. And it takes a hospital id and retrieves the Hospital instance from the database to be returned to the controller, where it is used further. As the HospitalFormatter is a bean like any other, the HospitalManager bean can be injected into it to make this happen. So the custom implementation looks like this: public class HospitalFormatter implements Formatter<Hospital> { @Autowired HospitalManager hospitalManager; @Override public Hospital parse(String text, Locale locale) throws ParseException { Long id = Long.parseLong(text); return hospitalManager.findOne(id); } @Override public String print(Hospital hospital, Locale locale) { return hospital.getName(); } } 128",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "@NotNull: Field cannot be null • @Size (min, max): File must have a length in the range (min, max) • @Pattern: String not null and matching • @NotEmpty: String must not be empty (Hibernate) • @Min(val), @Max(val): String must be of length at least minimum, or maximum in size They are used on the fields of interest in the domain object or data transfer object: public class Person extends AbstractEntity { @Size(min=2, max=50) public String firstName; @Size(min=2, max=50) public String lastName; @NotNull // comment the following if a custom formatter is registered @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date dateOfBirth; ... } The validation is invoked by annotating the form object with @Valid and the errors are registered in the BindingResult object too, alongside the binding errors. In the JSP form, the way the errors are displayed can also be customized. In the previous section, each error was mapped to its field, but you can also print all the errors in the same place by using the following syntax: <sf:form modelAttribute=\"person\"> <form:errors path=\"*\"/> ... </sf:form> This approach is not recommended for big forms. It is also quite annoying for the user to have to search for the form field he has to correct. By linking the error to the form field, it becomes quite obvious where the correction must be applied. 133 Chapter 3 ■ Spring MVC The Hibernate Validator contains its own set of internationalization files with default internationalized messages. The Resource bundle is named ValidationMessages; it is located in the hibernate-valdiator.jar under the org.hibernate.validator package. You can expand the hibernate-validator.jar and look at it contents in Intellij IDEA, as shown in Figure 3-19. Figure 3-19. Contents of the hibernate-validator.jar The message keys in the ValidationMessages.properties files are the message keys set by default in the definition of each annotation. For example, the following is a snippet of code for the @NotEmpty annotation: @Constraint(validatedBy = { }) @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER }) @Retention(RUNTIME) @ReportAsSingleViolation @NotNull @Size(min = 1) public @interface NotEmpty { String message() default \"{org.hibernate.validator.constraints.NotEmpty.message}\"; ... } For every field that fails, the @NotEmpty validation has the default error message printed next to it (if configured so), read from the Hibernate Validator resource bundle files. These messages can be overridden by creating your own ValidationMessages resource bundle in the classpath of the project. Also, the message keys can be customized by making the new message key a parameter for the message property when using the annotation; this allows specific messages to be displayed when the same annotation is used on different fields: // in the Person entity class @NotEmpty(message=\"lastname.notempty\") public String lastName; #in the ValidationMessages.properties lastname.notempty=Lastname cannot be empty! 134 Chapter 3 ■ Spring MVC When using Spring forms, the error messages can be part of the application resource bundle under WEB-INF\\messages; the message keys usually respect the following template: constraintName.modelAttributeName.propertyName Each part of the Spring message key is linked to elements in the application, as depicted in Figure 3-20. Figure 3-20. Spring message keys and linked elements The message samples at the end of the previous section include customized validation messages, used in the 05-pr-mvc-form-practice and solution modules. Spring also supports the JEE @Constraint21 annotation, which can be used to define customized validation annotations. // Pnc.java @Constraint(validatedBy = [PncValidator.class]) @Target( { ElementType.METHOD, ElementType.FIELD }) @Retention(RetentionPolicy.RUNTIME) public @interface Pnc { //using specific message key String message() default \"{pncFormatExpected}\"; Class<?",
    "answer": ">[] groups() default {}; } 21See http://docs.oracle.com/javaee/7/api/javax/validation/Constraint.html. 135",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Considering the following configuration in web.xml, what is the name of the parameter that holds the location of the Spring MVC configuration file?",
    "answer": "<servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class>o.s.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>?????</param-name> <param-value> /WEB-INF/spring/mvc-config.xml </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> A. contextListener B. configurationLocation C. contextConfigLocation",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Considering the following configuration in web.xml, what is the name of the parameter that points to the Spring infrastructure bean that enables Java configuration?",
    "answer": "<servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class>o.s.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>???</param-name> <param-value> o.s.web.context.support.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> 139",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "In web.xml, the servlet name has been configured to mvc-dispatcher. What is the default name of the MVC configuration file that Spring looks for?",
    "answer": "A. mvc-config.xml B. mvc-dispatcher.xml C. mvc-dispatcher-servlet.xml",
    "source": "extracted",
    "confidence": 0.69
  },
  {
    "question": "As a developer, what do you need to do to configure Spring Web MVC application without using an web.xml file ?",
    "answer": "A. Extend the AbstractDispatcherServletInitializer class and override at least createServletApplicationContext and getServletMappings. B. Extend the AbstractAnnotationConfigDispatcherServletInitializer class and override at least getServletConfigClasses and getServletMappings. C. Implement WebApplicationInitializer. D. Extend WebApplicationInitializer and annotate the class with @ EnableWebMvc.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Which of the following are Spring MVC infrastructure components?",
    "answer": "A. Validator implementations B. HandlerAdapter implementations C. HandlerMapping implementations D. ControllerAdvice implementations",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "RequestMappingHandlerMapping is registered by default when the following configuration style is used for a Spring web application: A. XML configuration using the MVC namespace specific element <mvc:annotation-driven/> B. Java configuration using a configuration class annotated with @EnableWebMVC 140 Chapter 3 ■ Spring MVC Question 8: What are the key interfaces used by Spring to render responses without tying itself to a specific view technology?",
    "answer": "A. View B. ViewResolver C. ViewConfigurer",
    "source": "extracted",
    "confidence": 0.41
  },
  {
    "question": "Which of the following is an out-of-the-box view technology supported by Spring?",
    "answer": "A. JSP B. Thymeleaf C. Velocity templates D. XSLT E. Tiles",
    "source": "extracted",
    "confidence": 0.58
  },
  {
    "question": "What is the default ViewResolver implementation configured by Spring?",
    "answer": "A. InternalResourceViewResolver B. JspResourceViewResolver C. UrlBasedViewResolver D. BeanNameViewResolver",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the difference between chaining ViewResolver beans and content-type negotiation?",
    "answer": "A. There is no difference. B. View Resolver chaining allows supporting multiple view types in a single application. C. Content-type negotiation allows support for multiple view types for the same resource.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is true about the HTTP Accept header?",
    "answer": "A. It can be used in a Spring Web MVC application to decide the view type for a resource only when the client is a browser. B. It is used for REST web services. C. It is useless when the client is a browser. D. It can be taken into consideration by setting a value for the ignoreAcceptHeader property in the ContentNegotiatingViewResolver bean.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "From the following list, select the Spring infrastructure bean types responsible with application personalization: A. MessageSource implementations B. LocaleChangeInterceptor C. LocaleResolver implementations D. ThemeResolver implementations 141 Chapter 3 ■ Spring MVC Question 14: What is true about the @ExceptionHandler and @ControllerAdvice annotations?",
    "answer": "A. They are used for handling exceptions thrown by controller methods. B. When a method inside a controller is annotated with @ExceptionHandler, this method handles the exceptions thrown only in that controller. C. @ControllerAdvice is used at class level; in addition to @ExceptionHandler annotated methods, this class can define other types of methods.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Given the following controller, to what request will the call method be mapped to?",
    "answer": "@Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(\"/list\") public String call(Model model,HttpServletRequest rq) { ... } } A. http://localhost:8080/persons B. http://localhost:8080/persons/list C. http://localhost:8080/persons/call",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Given the following controller, is the declaration of the show method correct?",
    "answer": "@Controller @RequestMapping(\"/persons\") public class PersonsController { @RequestMapping(\"/{id}\") public String show(@PathVariable String number, Model model) { ... } } A. Yes B. No",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What of the following is something that a Spring MVC handler method could not return?",
    "answer": "A. a string B. a Model C. a ModelAndView D. a JstlView instance E. a null value 142",
    "source": "extracted",
    "confidence": 0.83
  },
  {
    "question": "Which of the following statements regarding annotation-based configuration are true?",
    "answer": "A. Annotating a class with Controller is not enough for that class to handle requests; the class also has to extend Spring’s AbstractController class. B. @RequestMapping is both used at class and method level. C. To enable auto-detection of controller classes, you have to enable component scanning in your configuration. D. @ModelAttribute can only be used to annotate controller method arguments.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is true about @ModelAttribute ?",
    "answer": "A. This annotation is used to bind a method parameter or method return value to a named model attribute, exposed to a web view. B. If a method is annotated with it, that method will be executed before handling any request. C. This annotation is used to bind a form object to a controller.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is @InitBinder used for?",
    "answer": "A. To initialize a controller. B. To mark a method that initializes the WebDataBinder, which is used to populate command and form object arguments of annotated handler methods. C. To mark a method for execution before handling any request.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Which is true when a new view technology is added to a Spring web application?",
    "answer": "A. The view technology in question must provide a class implementing Spring’s View interface. B. The view technology in question must provide a class implementing Spring’s ViewResolver interface. C. The view technology must require specific configuration beans to be defined.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "When working with Spring forms, which is the recommended workflow?",
    "answer": "A. A GET request is made to display the form, a POST request is made to submit the data, and a GET request is made to display a confirmation page and prevent multiple resubmissions. B. A GET request is made to display the form, and a POST request is made to submit the data.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Given the following Spring form definition, what is wrong with it?",
    "answer": "<%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> ... <sf:form action=\"${personsUrl}\" method=\"GET\"> ... </sf:form> 143",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Which of the following are validation annotations used on form object fields?",
    "answer": "A. @NotNull B. @Size C. @Valid D. @NotEmpty E. @Constraint F. @Required G. @Pattern Practical Exercise This chapter is quite big, so it has four module projects associated with it and each of the modules covers a specific section. Figure 3-21 depicts the eight module projects attached to this chapter: four practice projects and four proposed solutions for them. You are welcome to analyze the proposed solutions and compare them to your solutions to test your understanding of Spring MVC. Figure 3-21. Practice projects for Chapter 3 144",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The data tier is the data access layer that usually encapsulates persistence mechanisms and exposes the data. It should provide an application programming interface (API) to the logic tier that exposes methods of managing the stored data without exposing or creating dependencies on the data storage mechanisms.22 • The logic tier (also known as the service layer) controls an application’s functionality by performing detailed processing. This tier is needed when the application needs to be accessed by different type of clients (browsers, web services, etc.). • The presentation layer is the topmost level of the application that users can directly access, such as a web page or a desktop GUI. Figure 3-22. Typical standardized three-tiered architecture 22In the PErsonal REcords Manager project, because Spring DATA JPA is used, the implementation of the repositories API is reduced to interfaces extending the JpaRepository interface. They are placed in the logic tier/service layer. 145 Chapter 3 ■ Spring MVC Because the Personal Records Manager is quite a small project, the service classes do not do much besides calling analogous methods form repository beans. The HospitalFormatter is part of the 01-pr-service module because it needs a manager instance to retrieve the hospital instance from the repository. The DBInitializer class is also located in the service class; it is used to populate the database with some sample entries when a web application starts. This class is a simple bean with access to all the service components used in the application, and with a @PostConstruct annotated method that uses those service classes to insert data. This is the most practical way to initialize a small test-scoped database that does not require external configuration files or additional libraries in the classpath. The bean is annotated with @Component and it is automatically discovered, created, and initialized at application boot time. The @Service annotated classes are organized in the hierarchy depicted in Figure 3-23. Figure 3-23. Service classes hierarchy They are all named [EntityType]ManagerImpl, where EntityType is the type of object managed by the class. The Impl suffix is used to emphasize that the class is a concrete implementation for the [EntityType] Manager interface. The BaseManager interface contains all the basic method skeletons common to all service classes. @Transactional public interface BaseManager<E extends AbstractEntity> { @Transactional(readOnly = true) List<E> findAll(); @Transactional(readOnly = true) E findById(Long id); E save(E e); void delete(E e); void deleteById(Long id); } The manager interfaces extending it add method skeletons specific to each managed entity-type. The repository components are created using Spring Data JPA and are in fact interfaces extending the JpaRepository interface. This interface extends CrudRepository, which provides sophisticated CRUD functionality for the entity class being managed. All other method definitions that are needed, but not 146 Chapter 3 ■ Spring MVC provided, are defined in the interface extending JpaRepository. They are annotated with the @Query annotation, and the query to be executed is set through it; for example: @Query(\"select p from Person p where p.lastName = :lastName\") List<Person> getByLastname(@Param(\"lastName\") String lastName); For Spring to provide proxy repositories with the configured implementation for the interfaces that extend JpaRepository, the following line has been added to the app-dao-config.xml configuration file: <beans xmlns=\"http://www.springframework.org/schema/beans\" ... xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans ... http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd ...\"> <jpa:repositories base-package=\"com.pr.repos\"/> </beans> The equivalent Java configuration makes use of the @EnableJpaRepositories annotation: @Configuration @EnableJpaRepositories(\"com.pr.repos\") class ApplicationConfiguration { @Bean public EntityManagerFactory entityManagerFactory() { ... } @Bean public DataSource dataSource() {...} ... { The basic configuration *.gradle file for each web module project looks like this: (1) apply plugin: 'war' apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin' dependencies { (2) compile project(':01-pr-service') compile misc.slf4jApi, misc.slf4jJcl, misc.logback, hibernate.ehcache, hibernate.em, hibernate.core, hibernate.validator, spring.jdbc, spring.orm, spring.contextSupport, spring.data, spring.webmvc, misc.dbcp, misc.h2, misc.joda, misc.jstl, misc.tilesJsp, misc.tilesReqApi, misc.javaxEl testCompile tests.junit, tests.mockito, spring.test, tests.hamcrestCore, tests.hamcrestLib } 147 Chapter 3 ■ Spring MVC gretty { port = 8080 (3) contextPath = '/mvc-layout' } 1. This line is where the Gretty plugin is defined to run this module. 2. This is the line where the dependency from the 01-pr-service project is defined. This line ensures that before compiling the web application, the 01-pr-service is compiled first. 3. This is the line where the Gretty plugin is configured to start the application with a different context than the name of the project. In the case presented here after starting the application, the web interface can be accessed at http://localhost:8080/mvc-layout This was necessary for practical reasons, because by default the module name is used, and the names of the modules in this chapter are quite long. All the projects can be built without the tests by running the allCompile task, as mentioned earlier in the book. In case you forgot, the task can be found directly under the project root, in this case the personal- records project, in the Intellij IDEA Gradle task tab, as you can see in Figure 3-24. Figure 3-24. The Gradle allCompileTask The other two tasks you need to use are the appStart and appStop under the module-project name in the Intellij IDEA Gradle task tab; they start and stop the web application, as depicted in Figure 3-25. 148 Chapter 3 ■ Spring MVC Figure 3-25. The Gerry start and stop web application tasks All the modules in personal-records can be built and run separately when using Gradle outside of Intellij IDEA, by using the command line in a terminal and running specific Gradle tasks: $ cd personal-records $ gradle :02-pr-mvc-basic-practice:build $ gradle :02-pr-mvc-basic-practice:run In the previous examples, the :02-pr-mvc-basic-practice is the name of the submodule, and :build and run are Gradle tasks to be run for the modules. ■ ! When running examples in the command line, the run task is used instead of appStart to run the web modules in gretty, so the execution can be ended by pressing any key in the terminal. Each of the projects suffixed with -practice is incomplete, missing either a bean definition or a configuration. In its place there is a TODO comment explaining what you have to do to make the project build. Each project covers a specific topic from the chapter, as follows: • 02-pr-mvc-basic-practice is a simple Spring web application project that displays a list of persons from the applications. It should contain proper definitions for all the personalization beans you read about in the chapter; it is what the TODOs are all about: configuring the personalization beans properly. It has only one controller, the PersonsController, which is used to populate the list.jsp and show.jsp views. This controller also has an @ExceptionHandler method that handles cases when a link is manually created with a non-existing person id. (Test the exception handling method by manually accessing http://localhost:8080/mvc-basic/persons/99.) • 03-pr-mvc-layout-practice is a simple Spring web application project that uses the Tiles engine to create views. Some configuration is missing and some methods have to be added for the project to work correctly. The Tiles template for the application is found under webapp/WEB-INF/templates; it is called layout.jsp. You can see the full path within the project in Figure 3-26. 149 Chapter 3 ■ Spring MVC Figure 3-26. Path of the Tiles layout template There are two controllers defined PersonsController and HospitalsController. Each of the controllers has the responsibility of populating the corresponding list.jsp views and the HospitalsController has a method that uses redirect: and redirectAttributes. This project also contains unit and integration tests designed to test you controllers. • 04-pr-mvc-view-practice is a simple Spring web application project that uses content view negotiation to present the data to the user in a specific view format for the persons/list URL. All it is missing is a proper configuration for the ContentNegotiatingViewResolver bean. • 05-pr-mvc-form-practice is a simple Spring web application project that presents the user with a form to edit users and one to search for users. The TODO tasks require the user to place the correct annotation on methods to enable validation and finish implementing the person search form. The part of the application managing Hospital entries has been removed for the purpose of simplicity, but if you want to practice your Spring form skills, you are welcome to try to create an edit form for a Hospital entry after you have solved the existing TODOs. All the applications are internationalized and themed. There are two languages available—English and German, and two colored themes—blue and green. When all the tests pass, all the applications start successfully and provide the expected functionality, and you feel confident that you have a solid grasp of the Spring Web MVC, you can continue to the next chapter. 150 Chapter 4 Spring Portlets Although not required for the certification exam, spring portlets are covered in this book because a lot of medium-sized companies tend to favor portal applications, which come with a set of modules already implemented. Companies may also hire developers to provide the customized functionality via pluggable components. Usually, these portal applications are licensed and supported, which is an advantage when things do not go exactly as planned, because you have direct contact with a team of experts that can help you with problems specific to the software. Portlets are pluggable web components used when creating a portal, which is a complex web-based application that provides personalization, authentication, and customizable content aggregation from multiple sources. A portlet is a Java-based web component; its lifecycle is managed by a portlet container, which processes requests and generates dynamic content.1 Each portlet produces a fragment of markup that is combined with the markup of other portlets in the context of a composite portal page. On enterprise application servers, a new war archive is deployed on a server, either manually by copying it into a deployment directory, or by uploading it using a manager application. A standard Java portlet should be deployable on any portlet container2 that complies with the standard. The advantage of using portlets is that the developer has to only handle the implementation of the logic inside a portlet; the portal server takes care of the rest, such as building and securing the page. Although this seems restrictive, the value of a portal application is the control that is given to administrators and users. A portlet (or a collection of portlets) behaves as a web-based application per-se, and it can be aggregated to build more complex web applications—portals. Portal applications are as widely used as servlet applications and the design of such applications comes in two flavors: • Portlets provide small units of functionality and are aggregated by the portal server into a larger application (see Figure 4-1). 1This definition is given in the official Java portlet specification at https://jcp.org/en/jsr/detail?",
    "answer": "id=286. 2A portlet container is an application that runs portlets and provides the appropriate context. Examples of well-known and widely used portal applications that can be customized using portlets include IBM WebSphere Portal; Liferay Portal, an enterprise web platform for building business solutions; GateIn Portal (formerly JBoss Portal), an open source web site framework; and the Blackboard learning management system. 151",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Whole applications can be written to reside in only one or a few portal pages (see Figure 4-2). Figure 4-2. Diagram of a multipage portal application 152 Chapter 4 ■ Spring portletS Choosing which approach to use depends on the requirements of the application and the number of different functionalities that the application must provide. For example, a university’s portal application is made of multiple pages, and each of those is made of multiple portlets with functionality related to a common domain. But a smaller application—a blog, for example—does not need multiple pages; the whole application can fit into one portal page. Liferay Community Edition version 6.2-ce-ga43 is used to run the examples in this chapter (Figure 4-3 shows the official Liferay site to help you easily see what you need to download). Choices are made by taking compatibility with Spring into consideration, as well as how practical development and deployment will be. Every portal application requires specific configurations, but Liferay allows high decoupling between portal and application configuration, which is quite an important feature, as you will soon discover. Figure 4-3. Liferay Portal version to download: Community Edition Bundle with Tomcat Spring provides an MVC framework for the JSR-168 and JSR-268 portlet development. This framework tries, as much as possible, to mirror the Web MVC framework, and also uses the same underlying view abstractions and integrations technology to make portlet development more practical. 3Download the Liferay Community Edition from http://www.liferay.com/downloads/liferay-portal/ available-releases. 153 Chapter 4 ■ Spring portletS Portlet Basics Portlet workflow is different from servlet workflow because it involves two distinct phases: an action phase and a render phase. The action phase is executed only once; this is the phase where backend logic is executed. During the render phase, the response that gets sent back to the user is produced. So there is a separation between activities that affect the state of the system and the activities that generate data to be displayed. Figure 4-4 depicts the difference between MVC servlet handling and MVC portlet handling when using Spring. Figure 4-4. Spring MVC portlet handling In the early versions of Spring MVC framework, implementing a controller class in a servlet-based application meant extending the o.s.web.servlet.mvc.AbstractController class (or implementing the org.springframework.web.servlet.mvc.Controller interface) and overriding the handleRequest() method, which is called by DispatcherServlet. Starting with Spring 3.0, this was no longer necessary, because annotations (@Controller and @RequestMapping) are used to provide a more flexible and practical way of working with controllers. There is an equivalent Spring class for portlets that should be extended to create a portlet: the org.springframework.web.portlet.mvc.AbstractController class (and an equivalent interface org.springframework.web.portlet.mvc.Controller). The handleActionRequest() and the handleRenderRequest() methods should be overridden; the org.springframework.web.portlet.DispatcherPortlet handles their invocation. Since Spring 3.0, annotations have made things easier for development of portlets too. @Controller is used to annotate a portlet controller, @RenderMapping is used to annotate a render method, and @ActionMapping is used to annotate an action method. 154 Chapter 4 ■ Spring portletS The advantage of annotations is that multiple render and action methods can be defined, and they can be called depending on the request parameters. The DispatcherPortlet uses a few special infrastructure beans to process requests and render appropriate views; they are implementations of interfaces analogous to MVC servlet interfaces. So when it comes to portlets, handler mappings are used to map requests and portlet modes with controllers, multipart resolvers, and handler exception resolvers. Data binding, command object usage, model handling, and view resolution are the same as in the servlet framework, and they are performed by the same classes. An intermediary servlet bridge class, called ViewRendererServlet, is used for rendering views; it transforms a portlet rendering request to a servlet request and the view can be rendered using the servlet infrastructure specific beans (view resolvers, messageSource, etc.). The only things not available are the usage of the redirect: prefix and RedirectView, because these kinds of operations are linked to the URL of the request, which in this case is generated by the portal and the results would be unexpected. Most portal applications expect the result of rendering a portlet to be an HTML fragment, so any view technologies like JSP/JSTL, Velocity, FreeMarker, and XSLT are allowed. This also means that Spring taglib and Spring form taglib are supported. Each portlet has a javax.portlet.PortletMode defined, which indicates the function the portlet is performing in the render method. A portlet can change its portlet mode programmatically when processing an action request. The portlet specification defines three portlet modes: VIEW, EDIT, and HELP. Depending on the security restrictions, a user can have access only to specific portlet modes; unauthenticated users can only use VIEW and HELP, whereas authenticated users can also use EDIT. Portlets are required to support VIEW mode; and this is the only mode needed—even in complex applications. EDIT and HELP are not mandatory. Portal applications can define their own custom portlet modes. For example, the Liferay Portal has additional portlet modes: • ABOUT • CONFIG • PRINT • PREVIEW • EDIT_DEFAULTS • EDIT_GUEST Liferay also allows its users to create their own portlet modes. Spring also acts as a portlet container, providing portlets with a runtime environment and managing their lifecycle. Spring receives requests from the portal and decides which portlet to execute. The portal is responsible with aggregating the resulted content. The following is the typical flow of events for using a portal application: 1. The user gets authenticated by the portal. 2. The user makes an HTTP request to the portal. 3. The request is received by the portal. 4. The portal determines if the request contains an action targeted to any of the portlets associated with the portal page. 5. Using the portlet container, the portal invokes portlets to obtain content to be displayed in the resulting portal page. 6. The portal aggregates the output of the portlets in the main page, and then sends the results back to the client. 155 Chapter 4 ■ Spring portletS As seen in this example, even if the request is directed to a single portlet in the page, the whole page is being reconstructed and rendered. This can be avoided by using AJAX components in the portlet pages, and instead of action requests, resource requests can be used (methods will be annotated with @ResourceMapping), but this implies adding a lot of resource handling logic for conversion and validation, which otherwise can be done by Spring automatically. A portal page can be made of one or more portlets, as seen in Figure 4-5. Figure 4-5. Liferay Portal page with various portlet components Configuration Spring Portlet is a request-driven web MVC framework designed around the DispatcherPortlet, which is the entry point for a portlet application. It plays the same role as a front controller as DispatcherServlet does for servlet applications. Because each portlet behaves as a stand-alone application, a DispatcherPortlet is defined for each portlet. Each DispatcherPortlet has its own WebApplicationContext, which inherits everything defined in the root WebApplicationContext. Everything inherited can thus be overridden in the portlet-specific scope. A context inheritance diagram example is depicted in Figure 4-6. 156 Chapter 4 ■ Spring portletS Figure 4-6. Context inheritance diagram in this chapter’s application sample Configuring a portlet application can be done by using only XML files, but when working with Spring MVC portlet, it is practical to use annotations to reduce the size of XML configuration files and make them more readable. In the source code attached to this chapter, two portlets are defined: PortletSearch and PortletAdd. Snippets of code from the content of one or the other are used in this book to provide examples for the terms and definitions being mentioned. The XML Part of the Configuration The DispatcherPortlet(s) is/are declared in a configuration file name portlet.xml, which resides under the WEB-INF directory. This file must exist with the mentioned name and in the mentioned location in any web archive containing portlet definitions. It is the configuration file for the portlet applications. You can consider it the equivalent of web.xml for portlets. A portlet application has the same structure as a normal web application, but the necessary configuration files depend on the portal application. How to use Liferay in this case will be discussed shortly; you can see the application structure provided in Figure 4-7. 157 Chapter 4 ■ Spring portletS Figure 4-7. The structure and configuration files for a Liferay portlet application Each file under WEB-INF has a specific purpose that will be discussed in detail later in this chapter. A short description of these files and their purposes can be seen in Table 4-1. Table 4-1. Message Converters Table File Name Purpose Observation app-config.xml Application configuration Spring, part of the root context liferay-display.xml List of portlets available Liferay liferay-portlet.xml Portlets configuration in the portal Liferay mvc-config.xml Web infrastructure configuration Spring, part of the root context personAdd-portlet.xml PersonAdd portlet configuration file Spring, inherits root context personSearch-portlet.xml PersonSearch portlet configuration file Spring, inherits root context The following list describes what every configuration file contains. • app-config.xml and mvc-config.xml are the typical Spring configuration files that contain the user-defined application beans and web infrastructure beans that are inherited by portlet contexts: <!-- app-config.xml --> <context:component-scan base-package=\"com.pr\"> <context:include-filter type=\"annotation\" expression=\"o.s.stereotype.Service\"/> <context:include-filter type=\"annotation\" expression=\"o.s.stereotype.Repository\"/> </context:component-scan> 158 Chapter 4 ■ Spring portletS <!-- Import configuration for the datasource and the dao project --> <import resource=\"classpath:spring/app-dao-config.xml\"/> <import resource=\"classpath:spring/db-config.xml\"/> <!-- mvc-config.xml --> <bean id=\"viewResolver\" class=\"o.s.web.servlet.view.InternalResourceViewResolver\" p:viewClass=\"org.springframework.web.servlet.view.JstlView\" p:prefix=\"/WEB-INF/person/\" p:suffix=\".jsp\"/> <bean id=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\" p:basename=\"classpath:localization/global\" lazy-init=\"true\"/> • liferay-display.xml is a Liferay Portal configuration file, which contains the list of portlets available to add in the pages of a site and a category that groups them together. This file is not mandatory, but it is recommended to create it to shorten the deployment process. Having this file in the war (alongside liferay-display.xml) allows you to install a portlet war application using the App Manager in Liferay, without any additional operations (see Figure 4-8). Figure 4-8. The App Manager in Liferay 159 Chapter 4 ■ Spring portletS • This is the syntax of the file: <display> <category name=\"Personal Records\"> <portlet id=\"personAdd\" /> <portlet id=\"personSearch\" /> </category> </display> • And when creating a site or a site template, Liferay provides user portlets (see Figure 4-9). Figure 4-9. How Liferay provides user portlets for usage in portal pages 160 Chapter 4 ■ Spring portletS • liferay-portlet.xml is a Liferay configuration file that contains typical settings for user created portlets in the context of the web application: portlet names, if they can be used more than once in a page,4 additional JavaScript files, CSS files,5 and so forth. <liferay-portlet-app> <portlet> <!-- The canonical name of the portlet, it has to be unique --> <portlet-name>personSearch</portlet-name> <!-- Indicates if multiple instances of this portlet can appear on the same page --> <instanceable>false</instanceable> <!-- not used in the example, but can appear in a configuration --> <footer-portlet-javascript>/js/main.js</footer-portlet-javascript> <header-portlet-css>/styles/general.css</header-portlet-css> <requires-namespaced-parameters>false</requires-namespaced-parameters> ... </portlet> </liferay-app> As these settings are Liferay specific, they won’t be covered in detail here. If you are interested in working with Liferay, you can find more details on the official site at www.liferay.com. ! Starting with liferay 6.2, the requires-namespaced-parameters parameter must be specified for a portlet. it must be set to false for parameter values to be read correctly. When not specified, the default value is true and the portal associates a unique name to each htMl element in the page to prevent name collisions between different portlets in the page. • personSearch-portlet.xml and personAdd-portlet.xml are portlet application configuration files. A configuration file for each portlet must be created. All beans used by the portlet controller bean (except the beans inherited from the root context) are declared in it. The name must match the <portletName>-portlet.xml template, where <portletName> is the name of the portlet as declared in portlet.xml. In our example, only the definition of the portlet controller bean can be specified. This file is loaded by the DispatcherPortlet: <bean id=\"personSearch\" class=\"com.pr.search.PersonController\" p:personManager-ref=\"personManager\"/> 4Portlets behave as stand-alone applications, so it is possible to add the same portlet multiple times to a page, unless configured differently. 5Liferay and other portlet containers provide a context for the portlets to run in. This context contains theme elements defined in CSS files, and additional functionality in the interface via JavaScript. But the user can override or complement Liferay by providing custom CSS and JavaScript files. 161 Chapter 4 ■ Spring portletS But if you want to use annotations as much as possible, you could do so: <!-- in personSearch-portlet.xml --> <context:component-scan base-package=\"com.pr.search\"/> <mvc:annotation-driven/> <!-- in personAdd-portlet.xml --> <context:component-scan base-package=\"com.pr.add\"/> <mvc:annotation-driven/> The scanned package contains the portlet controller class and all the components involved in defining the functionality of a portlet. Although the <mvc:annotation-driven/> declaration seems redundant, it is actually needed because portlets are independent applications, even if they inherit the same root context and they reside in the same portal application context. As mentioned, each portlet behaves as a standalone application, and that’s why these configuration files are needed. The root Spring configuration is defined in the app-config.xml and mvc-config.xml. Without these configuration files, the deployment will fail, because the Spring MVC portlet expects a configuration file for each portlet. Here is what happens at deploy time if the personSearch-portlet.xml file is missing: o.s.w.p.c.XmlPortletApplicationContext - Refreshing PortletApplicationContext for namespace 'personSearch-portlet'... o.s.b.f.x.XmlBeanDefinitionReader - Loading XML bean definitions from PortletContext resource /WEB-INF/personSearch-portlet.xml ERROR o.s.w.p.DispatcherPortlet - Context initialization failed o.spring.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from PortletContext resource /WEB-INF/personSearch-portlet.xml; nested exception is java.io.FileNotFoundException: Could not open PortletContext resource /WEB-INF/personSearch-portlet.xml ... • portlet.xml is the configuration file that defines settings for the portlet(s), such as the portlet request handler (the portlet class). When working with Spring only, DispatcherPortlet, supported modes, supported locales, supported MIME types, and the resource bundle are used. This file contains multiple portlet elements—one for each portlet defined in the application. <portlet-app ...> <portlet> <portlet-name>personSearch</portlet-name> <portlet-class>o.s.web.portlet.DispatcherPortlet</portlet-class> <supports> <mime-type>text/html</mime-type> <portlet-mode>view</portlet-mode> </supports> <resource-bundle>localization.global</resource-bundle> <portlet-info> <title>Person Search</title> </portlet-info> </portlet> <portlet> 162 Chapter 4 ■ Spring portletS <portlet-name>personAdd</portlet-name> ... <!-- configuration is analogous to the one for personSearch --> </portlet> <!-- More settings for other portlets --> </portlet-app> • web.xml contains the deployment descriptor for the web resources, and this is where the ViewRendererServlet is declared and the connection to the Spring MVC configuration is made. There is no DispatcherServlet defined, because portlet applications run in a portlet context, which is different form a servlet context. According to Portlet Specification 1.0, every portlet application is also a Servlet Specification 2.3–compliant web application, and thus it needs a web application deployment descriptor, meaning a web.xml file: <web-app ...> <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/root-context.xml</param-value> </context-param> <listener> <listener-class>o.s.web.context.ContextLoaderListener</listener-class> </listener> <servlet> <servlet-name>ViewRendererServlet</servlet-name> <servlet-class>o.s.web.servlet.ViewRendererServlet</servlet-class> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>ViewRendererServlet</servlet-name> <url-pattern>/WEB-INF/servlet/view</url-pattern> </servlet-mapping> </web-app> The ViewRendererServlet is the bridge servlet for portlet support. During the render phase, DispatcherPortlet wraps PortletRequest into ServletRequest and forwards control to ViewRendererServlet for actual rendering. This process allows the Spring Portlet MVC framework to use the same View infrastructure as that of its servlet version; that is, the Spring Web MVC framework. The /WEB- INF/servlet/view is the default value available for internal resource dispatching. The ViewRendererServlet bridge servlet can be mapped to a different URL pattern by using the viewRendererUrl property. 163 Chapter 4 ■ Spring portletS ! as mentioned at the beginning of the chapter, the controllers can be created without annotations by extending the |o.s.web.portlet.mvc.AbstractController class. this is the old way of doing things, before the introduction of the @Controller annotation. it is still supported, but not recommended, and it is not as practical as using an annotated controller. in this case, the <portletName>-portlet.xml looks a little different. the HelloWorldController in the book-code/04-chapter-solution module has a configuration file that looks like this: <bean id=\"helloWorldController\" class=\"com.book.HelloWorldController\"/> <bean id=\"portletModeHandlerMapping\" class=\"o.s.web.portlet.handler.PortletModeHandlerMapping\"> <property name=\"portletModeMap\"> <map> <entry key=\"view\"> <ref bean=\"helloWorldController\"/> </entry> </map> </property> </bean> the PortletModeHandlerMapping class is an implementation of the o.s.web.portlet.HandlerMapping interface used by Spring to map from the current PortletMode to request handler beans. The Annotation Part of the Configuration At the time this book is being written, a full annotation configuration for a portlet-based application is not possible. A combination of XML and annotations can be used, because Spring MVC annotations are available for usage in portlet controllers too. For example, in the PersonAddController, the @ModelAttribute is used in a similar manner as for a servlet container. The PersonAddController is a simple controller that allows the user to create a person instance. import org.springframework.stereotype.Controller; ... @Controller(\"personAdd\") @RequestMapping(\"VIEW\") public class PersonAddController { ... @RenderMapping public String render(Model model) { model.addAttribute(new Person()); return \"add\"; } 164 Chapter 4 ■ Spring portletS @ModelAttribute private List<Hospital> getHospitals() { return hospitalManager.findAll(); } @ActionMapping(\"add\") public void addPerson(@Valid @ModelAttribute Person person, BindingResult result, ActionRequest actionRequest, ActionResponse actionResponse, SessionStatus sessionStatus, Model model) { if (!result.hasErrors()) { logger.info(\"ACTION: action saving person = \" person); try { personManager.save(person); model.addAttribute(\"message\", messageSource.getMessage(\"label.Person.saved\", null, actionRequest.getLocale())); sessionStatus.setComplete(); } catch (Exception e) { logger.error(\"Unexpected error when saving person.\", e); model.addAttribute(\"error\", \"Internal Error. Contact Administrator.\"); } } else { logger.info(\"Validation failed\"); model.addAttribute(\"errors\", result); } } } The model attribute defined by getHospitals() is used to populate the hospital drop-down list in the view fragment in add.jsp. The view fragment is basically normal JSP code; any taglibs can be used, and the portlet taglib is used to define the render and action URLs that will be mapped to methods in the controller responsible for populating and managing data for the JSP fragment. (1) <%@ taglib prefix=\"portlet\" uri=\"http://java.sun.com/portlet_2_0\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %> (2) <%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %> (3) <portlet:defineObjects /> <h3> <spring:message code=\"persons.add.title\"/> </h3> (4) <portlet:actionURL var=\"addPersonUrl\"> <portlet:param name=\"javax.portlet.action\" value=\"add\"/> </portlet:actionURL> 165 Chapter 4 ■ Spring portletS (5) <portlet:renderURL var=\"cleanPersonUrl\"> <portlet:param name=\"action\" value=\"clean\" /> </portlet:renderURL> <div class=\"person\"> ... <sf:form name=\"person\" modelAttribute=\"person\" action=\"${addPersonUrl}\" method=\"POST\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> </label> </th> <td><sf:input path=\"firstName\"/></td> <td><sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> <tr> <th> <label for=\"middleName\"> <spring:message code=\"label.Person.middlename\"/> </label> </th> <td><sf:input path=\"middleName\"/></td> <td><sf:errors cssClass=\"error\" path=\"middleName\"/></td> </tr> ... <!-- other form elements --> <tr> <td> <input type=\"submit\" value=\" <spring:message code=’command.save’/>\"> </td> <td> <a href=\"${cleanPersonUrl}\"> <spring:message code=\"command.cancel\"/> </a> </td> </tr> </table> </sf:form> </div> 166 Chapter 4 ■ Spring portletS The previous sample code is a snippet from the definition of the add.jsp fragment. A few lines are marked with numbers in parentheses; here is why those lines are important: • (1) The portlet taglib definition for JRS 286. (A portlet container that supports JSR 286 should also support JSR 168.) • (2) The Spring form taglib definition. • (3) Needed to use renderRequest, renderResponse, and portletConfig variables.6 • (4) An element used to define an action URL for a portlet. The javax.portlet.action parameter value must match the value of the @ActionMapping annotation placed on the action method in the controller. Other parameters with different names can be used and the {name,value} pairs, must appear as a value for the @ActionMapping annotation params attribute to correctly identify the action method to use. In the case described in the preceding snippet, the following method will be mapped to the addPersonUrl: @Controller(\"personAdd\") @RequestMapping(\"VIEW\") public class PersonAddController { ... @ActionMapping(\"add\") public void addPerson(...){ ... } ... } • (5) An element used to define a render URL. This element has a parameter, and its name and value appears in the @RenderMapping annotation params attribute to correctly identify the render method to use. In the case described in the preceding snippet, the following methods will be mapped to the cleanPersonUrl: @Controller(\"personAdd\") @RequestMapping(\"VIEW\") public class PersonAddController { ... @RenderMapping(params = \"action=clean\") public String renderNew(Model model) { //the model attribute is removed from the model and a new on is added //causing the form to be emptied of data model.asMap().remove(\"o.s.validation.BindingResult.person\"); model.addAttribute(new Person()); return \"add\"; } ... } 6https://blogs.oracle.com/deepakg/entry/jsr286_defineobjects_tag. 167 Chapter 4 ■ Spring portletS Configuration Details and Recommendations If you paid enough attention to the example configuration files presented in the previous sections, you might have noticed that there are some common elements between the configuration files; portlet names and portlet ids have to respect some strict rules in order for the portlets to be deployed correctly. Figure 4-10 is a mashup of all files used in defining a portlet. In this image, only configuration elements specific to the PersonAdd portlet are depicted. Analogous elements are also defined for the PersonSearch portlet in this book’s code samples. If you decide to experiment with the provided code and create your own portlet, the configuration should be done similarly to what is presented in Figure 4-10 for the PersonAdd portlet. Figure 4-10. All the files defining the PersonAdd portlet When developing a portlet, it is important to keep a standard for naming beans and configuration items; make it as global as possible, because when elements are not found, Spring reports these as errors in the portal application. Spring is quite clear in telling you what is missing, but portal application exceptions can be quite confusing, especially when you are working with a portal application for the first time. So if you want your portlet development to go flawlessly, try to follow these recommendations: 1. Try to start development by writing the controller. Name the controller appropriately. A controller name should be made of the following: a. The name of object type being manipulated b. The type of manipulation (list, search, edit, add) c. The Controller suffix 168 Chapter 4 ■ Spring portletS For example, a controller that handles requests for searching for a person would be named PersonSearchController. The name of the controller bean should be the object type name + manipulation type. So the PersonSearchController name is annotated with @Controller(\"personSearch\"). 2. The second file is the Spring portlet configuration type. It is named as follows: a. The name of the object type being manipulated b. The type of manipulation (list, search, edit, add) c. The -portlet suffix So, a file to configure a portlet that performs a person search would be called personSearch-portlet.xml. Inside this file, a bean defines the controller type that you previously created, and dependencies are injected when XML configuration is used. The bean id is the name of the controller bean defined in the previous step. <bean id=\"personSearch\"> <property name=\"personManager\" ref=\"personManager\"/> </bean> When annotations are used to configure the necessary components, only the package that you are interested in is scanned, and the <mvc:annotation-driven/> is added: <context:component-scan base-package=\"com.pr.search\"/> <mvc:annotation-driven/> 3. The liferay-display.xml is next. Set the portlet id as object type name + manipulation type. 4. In the liferay-portlet.xml, set the portlet name as object type name + manipulation type too. So, for the portlet that displays a list of people, the portlet id and portlet name should be personList. 5. In portlet.xml, use the same portlet name as you did in the previous step. 6. Another recommendation is to make portlets that display data instanceable and the portlets that alter data non-instanceable. The reason for this is as follows: if a portlet that displays data is placed twice in the page, both portlets will always display the same data, because they share the request. The same happens with portlets that alter data; so basically, two action requests are made with the same parameters, even if the input parameters have been populated in only one of them. This leads to exceptions at the database level if the database is properly designed. If not, this leads to data duplications, and sometimes data corruption. 7. If you have only one portlet, the root-context.xml is not necessary and all Spring infrastructure beans can be declared in the <portletName>-portlet.xml. The Development and Deployment of a Portlet Application Since this chapter does not cover topics required for the certification exam, no quiz or practical exercises are in it; instead, a short step-by-step tutorial explains how to install, start, and configure Liferay, and deploys the code samples offered to you. After you understand the process and create some portal pages with the given portlets, you can try to create your own portlet by following the recommendations from the previous section. 169 Chapter 4 ■ Spring portletS Download, Install, Start, and Configure Liferay As mentioned in the beginning of this chapter, Liferay can be downloaded from www.liferay.com/ downloads/liferay-portal/available-releases. The following examples use the Community Edition, bundled with Tomcat, because it is free and can be downloaded directly. Also, Tomcat is really easy to use. After you click the Download button a *.zip file is saved onto your computer. The file is usually named liferay-portal-tomcat-[version]-ce-ga[index]-[date+build_number].zip. Unpack the archive in a desired location. And this is the end of the install process. If you open the directory, you will see the content depicted in Figure 4-11. Figure 4-11. The Liferay installation archive The tomcat-[version] is the version of Tomcat that Liferay is based upon. It has the normal structure and functionality of a Tomcat application server, but it contains some extra jars and configuration files for the Liferay Portal application. ! Currently, liferay is based on tomcat 7, so a configuration without a web.xml file is not possible. To start Liferay, you have to open a shell terminal or a Command Prompt instance. Go to the tomcat/bin directory inside the Liferay installation. Start the server as you would start Tomcat. Windows / Command Prompt C:\\{directory}\\liferay-{version}\\omcat-{version}\\bin catalina.bat run # you also have the option to \"double-click\" on startup.bat Linux / MacOs shell terminal cd /{directory}/liferay-{version}/tomcat-{version}/bin ./startup.sh 170 Chapter 4 ■ Spring portletS You can look in tomcat-[version]/logs/catalina.out to see when the server is up and whether exceptions were thrown due to incompatibilities between the Java version and Liferay. There could be other tomcat *.log files in the directory, but the catalina.out file is the one you should be interested in, because it is the main logging file for Tomcat and logs are written into it in real time when the server is up. Liferay 6.2 is compatible with Java 8, however, so no such problem should arise. When the server is started, a window is opened in your default system browser at the address http://localhost:8080. This page asks you to insert a few settings details. For the examples in this book, the default configuration can be used. The page should look like the one shown in Figure 4-12. Figure 4-12. The Liferay welcome page Click the Finish Configuration button on the bottom-left corner of the page. The default settings are saved in an internal in-memory database. You should see a confirmation page that looks like the shown one in Figure 4-13. 171 Chapter 4 ■ Spring portletS Figure 4-13. Liferay configurations saved confirmation page Click the Go to my Portal button in the bottom-left corner of the page. The next page is the Terms of Use page. Just scroll down and click the I Agree button. Next, you are presented with a page requiring you to add a password reminder. Just insert something simple and click the Save button. The default password for user test@liferay.com is test (see Figure 4-14). After introducing a password reminder, you should be redirected to the portal home page (see Figure 4-15). If you see this page, then your server is correctly configured and you can start deploying custom portlets. Figure 4-14. Liferay Password Reminder page 172 Chapter 4 ■ Spring portletS Figure 4-15. Liferay Portal home page In Liferay, portlets have to be added manually to a page by selecting them from a list with available components. A page is usually part of a site. In Liferay, there are also site templates, which can be used to create multiple sites that inherit the configuration of a template. Of course, you could add the portlets directly to the home page you see after logging in, and then start testing them; but for the examples in this chapter, you will use Liferay the proper way. The first step is to create a site template. To do this, expand the Admin menu and select Control Panel. Figure 4-16 shows where this option is found on the menu. Figure 4-16. Liferay Admin menu 173 Chapter 4 ■ Spring portletS After selecting the Control Panel option, an admin page with all possibilities is displayed (see Figure 4-17). Figure 4-17. Liferay admin page These options are numbered in Figure 4-17 to show you their order of usage when creating your site: 1. Link to the Site Templates administration page. 2. Link to the portlets (Applications) administration page. 3. Link to the Sites administration page. This page takes care of administration for the portal application and all sites hosted by it. Sites can be secured or public. They can have users with different access roles and rights. They can have custom pages. Site templates can be created and user-provided portlets can be installed by using the App Manager. So let’s create a public site and populate it with the provided portlet samples. Click the Site Templates link to display the Site Template configuration page. Click the +Add button. The form for creating the site template is displayed (see Figure 4-18). Insert the name of the site template and a description, if you want (description is not mandatory, the site name is). Click the Save button. 174 Chapter 4 ■ Spring portletS Figure 4-18. Liferay create Site Template page The more extended site template configuration is next. Click the Pages option in the menu on the left. Next, click the Site pages option. In the center of the page, a set of options for all the pages in the site template are presented. One of these options is the theme for all pages. Select the Dark radio button under the Color Schemes section to use the dark scheme for the site template, because in the style sheet used in the example, the style is defined to be compatible with it (see Figure 4-5). Then click the Save button on the right. Figure 4-19 depicts the actual page and the order of operations. 1. Link to all site pages configurations. 2. Select the Dark theme option. 3. Link to the home page template configuration page. 4. Click the Save button. 175 Chapter 4 ■ Spring portletS Figure 4-19. Liferay customize site template page Click the home link (3), to customize the home page. Change the name if you want; in this example, the first letter is in uppercase. Next, select a layout. The preferred layout is 2 Columns (50/50), so the portlets can be added side by side in the page. After doing this, click the Save button. A green message box should appear at the top of the page, letting you know that all went well (see Figure 4-20). 176 Chapter 4 ■ Spring portletS Figure 4-20. Liferay customize Home Page Template So, now a site template has been created; it contains a single page named Home, which is the page the sample portlets implementations will be placed. To do that, you have to preview the site template, which is done by going back to the Site Templates Administration page and clicking the Site Templates button at the top of the page. A list with all the defined site templates is displayed. The last one on the list should be the recently created site template. Click the Actions button for the site and select the View Pages option (see Figure 4-21). 177 Chapter 4 ■ Spring portletS Figure 4-21. Liferay Site Templates page In a new browser window or tab, your site template is opened for customizations. On the left, there is a light-blue button with a + sign on it. If you click it, a menu opens to allow you to modify the content of the home page. Since there is only one page, it is automatically selected. (When there are multiple pages to customize, you would just click a page header to select it, and then all customizations to be done on it.) Click the Applications menu item to see a list of the available out-of-the-box Liferay portlets to add on the page. They are grouped by category. The page in administration mode is shown in Figure 4-22. 178 Chapter 4 ■ Spring portletS Figure 4-22. Site Template home page in administration mode Now it is time to load the sample portlets. Open the book-code project and run the war task under the 04-chapter-solution project. The execution of this task creates a *.war file under 04-chapter-solution\\build\\libs that needs to be deployed to the Liferay Portal. The module contains two portlets: • Hello World Portlet is a simple portlet application with a controller created by implementing the o.s.web.portlet.mvc.Controller, as mentioned at the beginning of the chapter. The handleRenderRequest of this portlet sets an attribute to the model, which is displayed during the render phase. import javax.portlet.ActionRequest; import javax.portlet.ActionResponse; import javax.portlet.RenderRequest; import javax.portlet.RenderResponse; import o.s.web.portlet.ModelAndView; import o.s.web.portlet.mvc.Controller; public class HelloWorldController implements Controller { 179 Chapter 4 ■ Spring portletS public ModelAndView handleRenderRequest(RenderRequest request, RenderResponse response) throws Exception { Map<String, Object> model = new HashMap<String, Object>(); model.put(\"helloWorldMessage\", \"Hello World from Spring WEB portlet example application!!\"); return new ModelAndView(\"helloWorld\", model); } public void handleActionRequest(ActionRequest request, ActionResponse response) throws Exception { //we do not have action requests } } • Hello World Portlet2 is a simple portlet application with a controller created and configured using a typical Spring configuration: annotations and XML. As a bonus, this portlet has a @ResourceMapping annotated method that is used to send a text directly to the browser. These types of methods can be used in AJAX calls, as mentioned at the beginning of this chapter. import o.s.stereotype.Controller; import o.s.ui.Model; import o.s.web.bind.annotation.RequestMapping; import o.s.web.portlet.bind.annotation.ActionMapping; import o.s.web.portlet.bind.annotation.RenderMapping; import o.s.web.portlet.bind.annotation.ResourceMapping; @Controller(\"helloworld2\") @RequestMapping(\"VIEW\") public class HelloWorldController2 { @RenderMapping public String render(Model model){ model.addAttribute(\"helloWorldMessage\", \"Hello World from Annotated Spring Portlet!!\"); return \"helloWorld2\"; } //We do not need to do anything here. //Empty method given as example of how action methods are defined. @ActionMapping(value=\"doSomething\") public void action(ActionRequest request, ActionResponse response){ } //Example of resource request method @ResourceMapping(value = \"getData\") public void getData(ResourceRequest resourceRequest, ResourceResponse resourceResponse) throws IOException { resourceResponse.getWriter().write(\"Test data for Ajax call.\"); } } 180 Chapter 4 ■ Spring portletS Please take the time to analyze the code and the configuration files, and then execute the task and build the *.war. If the task is executed correctly, you should see the result in 04-chapter-solution\\build\\libs. Compare Figure 4-23 with your own environment. Figure 4-23. The 04-chapter-solution portlet sample Now that you have the archive with the portlets, it is time to upload them to Liferay. For this you need to go the portal administration page (Control Panel) and click the App Manager link. A page with all available portlets is displayed. The following actions must be performed: 1. Click the Install tab on the menu. 2. A page with an upload Form will be displayed, asking you to upload an LPKG or a WAR file. Click the Browse button. (On some systems, this button might be named Choose File.) 3. Select the 04-chapter-solution-1.0-SNAPSHOT.war file. 4. Click the Install button. If the *.war file is installed correctly, a green message box appears on the top of the page with the message: The plugin was uploaded successfully and is now being installed (see Figure 4-24). 181 Chapter 4 ■ Spring portletS Figure 4-24. Using the App Manager to install custom portlets in Liferay ! Community editions of liferay may have minor bugs and throw exceptions, although everything is happening as it should. For example, the liferay version used to test the portlet implementations, liferay- portal-6.2-ce-ga4, throws a com.liferay.portal.kernel.messaging. MessageListenerException:java.lang. NullPointerException, which is printed in the catalina.out log file, but the portlets are installed correctly. To make sure that the portlets were installed correctly and are ready to use, click the Manage tab. The 04-chapter-solution-1.0-SNAPSHOT application should be at top of the list because of its name, and if you expand the gray rectangle underneath, you should see something similar to what’s shown in Figure 4-25. 182 Chapter 4 ■ Spring portletS Figure 4-25. Correctly installed portlet samples in Liferay Now is the time to go back to the site template and place these two portlets in the home page. Liferay has a quick navigation menu on top of the page, which can be used for faster navigation between administrative pages. (It is pinpointed to you in Figure 4-25). There is a Sites option on it. By clicking this, the Liferay site–related configurations page is displayed (see Figure 4-21). Now all you have to do is click the Site Templates button, and then preview the site template as shown earlier. The page shown in Figure 4-22 should have an extra category now, the Chapter 04 Sample. Expand this, and then drag each portlet to the page and place it accordingly. The home page should look like what’s shown in Figure 4-26; you can also see the new category group for the HelloWorld sample portlets. Figure 4-26. Sample portlets added to the page 183 Chapter 4 ■ Spring portletS Before creating a site using the template, the way to uninstall a war application should be presented, because things might go wrong during portlet development. For example, the following exception is thrown at Liferay deployment when the configuration of a portlet application is incorrect: o.s.w.p.c.XmlPortletApplicationContext - Refreshing PortletApplicationContext for namespace 'personSearch-portlet'... o.s.b.f.x.XmlBeanDefinitionReader - Loading XML bean definitions from PortletContext resource /WEB-INF/personSearch-portlet.xml ERROR o.s.w.p.DispatcherPortlet - Context initialization failed o.spring.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from PortletContext resource /WEB-INF/personSearch-portlet.xml; nested exception is java.io.FileNotFoundException: Could not open PortletContext resource /WEB-INF/personSearch-portlet.xml ... Configuration errors—such as missing beans or missing expected configuration files (like in the preceding exception)—are displayed only in the catalina.out file. In the App Manager you can see the green message confirmation box as long as the file can be read. The difference is message under the portlet name in the Manage section: There are no configurable plugins for this app. When this happens, click the Manage tab, and then click the Actions button attached to the application you want to uninstall. Select the Uninstall option. See Figure 4-27 for the message and uninstall option. Figure 4-27. Uninstall a portlet application Now let’s create a site. Select Sites from the top menu, and then select Sites. Click the +Add button. Next, select the Personal Records Template. The succession of these steps is depicted in Figure 4-28. 184 Chapter 4 ■ Spring portletS Figure 4-28. The steps to create a site using a site template You will be directed to a new page, where a name and description can be inserted for the site. There are other options possible, but for now, just accept the default values and click the Save button. The page will look like the one shown in Figure 4-29. Figure 4-29. Site configuration page 185 Chapter 4 ■ Spring portletS After creating the site, more configuration options become available, and you can see them all in the page that is loaded after the save operation. A recommended practice is to customize the site URL, as Liferay will generate one from the site name (which might not be an acceptable URL). For example, for a site named Personal Records Manager, the site URL generated by Liferay is personal-records-manager. To modify a site URL, in the site configuration page, click the Site URL menu option on the right, and then change the generated site URL with the desired URL under the Friendly URL section, as depicted in Figure 4-30. Figure 4-30. Site URL configuration Click the Save button, and then access the newly created site from the menu. Go to My Sites. The site name should appear in the menu. By clicking it, you should be redirected to the site home page (see Figure 4-31). 186 Chapter 4 ■ Spring portletS Figure 4-31. Accessing a Liferay site After the two extra-simple HelloWorld portlets from the book-code project are added to the site, look in personal-records for the module named 06-pr-mvc-portlet-solution. This module contains two complex portlets: one for creating a Person instance and one for searching the Person database and deleting Person instances. These are complex portlets that access a database and perform actual data modification; they don’t just display data. Most code samples mentioned in this chapter are from these portlets. These portlets have been developed in such a way that all Spring MVC has to offer is included: model attributes, Spring forms, automatic conversion and validation, and so on. The code for the Spring form and validation is the same as the one for forms used in a servlet environment, and you can find it all in Chapter 3. The reason for this is that servlet and portlet environments differ only by the type of requests being resolved and the way they are mapped to handlers. Once a request has been mapped to a handler, processing the data inside the body of a request is independent of the application type. Please take a look at the project, and then deploy the portlets on Liferay and add them to the site template in the same manner presented so far. Your updated site should afterward look like what is shown in Figure 4-32, or a little different if you chose a different way to place your portlets in the page. 187 Chapter 4 ■ Spring portletS Figure 4-32. The Personal Records Manager portal site Summary After reading this chapter, you should have a basic understanding of how to use the Spring MVC Portlet framework with the Liferay Portal application. Here is a list of things that you should remember in case you ever end up working on a portal project: • Portlets are specialized web components that behave as stand-alone web applications and used to create composite pages in portal applications. • The Spring MVC Portlet framework mirrors the Spring MVC framework. The role of the front controller is played by the DispatcherPortlet in portlet applications. • A portlet works with two types of requests: render and action. The render requests do not involve business logic or data manipulation; they just request data from the portal to display it in the page. Actions do the actual data manipulation. • Most Spring MVC infrastructure beans and features are available for use in portlet applications. • Liferay is very compatible with Spring MVC Portlet; the configuration is totally decoupled. 188 Chapter 5 Spring RESTful Services REST is an acronym for REpresentational State Transfer. It was introduced and defined in 2000 by Roy Fielding in his doctoral dissertation. REST is a lightweight alternative to mechanisms like RPC (Remote Procedure Calls) and web services (SOAP, WSDL, etc.). REST is an architecture style for designing networked (distributed) applications. The idea is that, rather than using complex mechanisms such as CORBA, RPC, or SOAP to connect machines, simple HTTP is used to make calls between machines. RESTful applications use HTTP requests to post data (create and/or update), read data (e.g., make queries), and delete data. Thus, REST uses HTTP for all four CRUD (create/read/update/delete) operations. Core REST Concepts The REST architectural style describes six constraints: • Uniform interface: Defines the interface between client and server. Rest uses HTTP as an application protocol, as a platform, not just a transport protocol. The following HTTP specifications are used: • HTTP verbs are used as actions to execute on the resources (GET, PUT, PATCH, POST, DELETE, HEAD, and OPTIONS)1 • URIs are used to identify resource names. The resources are conceptually separate from representations. Representations of the resources are returned from the server to the client, after a client request (typically JSON or XML). Representations contain metadata that can be used by the client to modify or delete the resource on the server, provided it has permission to do so. • HTTP response: Response codes, the body, and headers are used to deliver state to clients. Clients deliver state using body content, query-string parameters, request headers, and the URI. 1Although REST seems strongly connected to HTTP, REST principles can be followed using other protocols too, for example: POP, IMAP, and any protocol that uses URL-like paths and supports GET and POST methods. 189 Chapter 5 ■ Spring reStful ServiCeS • Statelessness: The server should contain no client state. Each request has enough context for the server to process the message. The URI uniquely identifies the resource, and the body contains the state (or state change) of that resource if the request is one that has a body (PUT, POST, PATCH). When working with a specific container, a session is used to preserve state across multiple HTTP requests. When using REST, there is no need for this, which increases the scalability because the server does not have to maintain, update, or communicate the session state. • Client-server: A RESTful architecture is a client-server architecture, so the system is disconnected. The server might not be available all the time, so operations are asynchronous. • Cacheable: Anything returned by the server can be cached explicitly (the server specifies conditions for caching), implicitly (the client uses its own caching conditions), or negotiated(the client and the server negotiate caching conditions) • Layered system: The client cannot assume direct connection to the server. Sometimes a requested resource can be cached, and some other unknown software and hardware layers are interposed between the client and the server. Intermediary servers may improve system scalability and/or security by enabling load balancing, providing shared caches, and enforcing security policies. • Code on demand: Executable code can be transferred as a representation to the client (usually JavaScript or compiled Java applications known as applets). ■ Note processes running on different hosts communicate over a layered set of network protocols defined by the OSi model. the uppermost level is the application layer and protocols specific to it are called application protocols. this is the layer that is closest to the user, which means the user interacts directly with the software application. Between the application layer and the transport layer are two more layers. the transport layer provides the functional and procedural means of transferring variable-length data sequences from a source to a destination host via one or more networks, while maintaining the quality of service functions. the protocols specific to it are called transport protocols. When using reSt, data is not just sent and received via http (transport), but data is actively manipulated by the user in the context of an application. More information about network layers and protocols can be found on the internet; if you are interested in finding out more, you can check out Wikipedia at https://en.wikipedia.org/ wiki/OSI_model. advanced networking is not the object of this book or the certification exam. Complying with the first five constraints ensures that a RESTful application will be scalable, simple, easy to modify, portable, and reliable. The last constraint is optional; a REST application can be built without code being transferred to clients, if there is no need for such operations. The main REST HTTP methods are presented in Table 5-1. 190 Chapter 5 ■ Spring reStful ServiCeS Table 5-1. Message Converters HTTP Method Purpose Observation GET Read Reads a resource; does not change it: therefore, it can be considered safe. Reading the same resource always returns the same result: therefore, it can be considered idempotent. POST Create Used to create a new resource. Neither safe nor idempotent. Two identical POST requests will result in two identical resources being created or errors at application level. PUT Update Most often used for update capabilities. It is not safe, because it modifies the state on the server, but is idempotent (unless subsequent calls of the same PUT request increments a counter within the resource, for example). DELETE Delete Used to delete resources. Not safe, but can be considered idempotent because requests to delete a resource that no longer exists will always return a 404 (not found). To analyze contents of the REST requests and responses handled by the browser, the Firebug plugin in Firefox can be used. Simply install it directly from the official site (http://getfirebug.com/) and enable it by clicking the little bug on the right corner of the page (1). To see the contents of a request, just click on the Net tab (2), as depicted in Figure 5-1. Figure 5-1. Using the Firebug plugin in Firefox to analyze REST requests and responses handled by the browser 191 Chapter 5 ■ Spring reStful ServiCeS The following describes the GET example shown in Figure 5-2: • It retrieves a representation of a resource. • It might have length restrictions.2 • It is a safe operation; idempotent; repetitive execution that has no side effects. • It is cacheable and ETags are used to keep tags on resource versions.3 • When a resource is not found, a 404 (Not Found) status code is returned; otherwise 200 (OK) Figure 5-2. GET Request and Response example; snippets form the Firebug console The following describes the POST example shown in Figure 5-3: • It creates a new resource. • It is not idempotent; repetitive execution causes duplicate data and/or errors. • The response has the created resource location URI in the response header. • When the resource being created requires a parent that does not exist a 404 (Not Found) status code is returned. When an identical resource already exists a 409 (Conflict) status code is returned. When the resource was created correctly a 201 (Created) status code is returned. 2Servers should be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations may not properly support these lengths. When a browser does not support a certain request length, a 400 (Bad Request) status code is returned. 3You can read more about ETags at http://en.wikipedia.org/wiki/HTTP_ETag. 192 Chapter 5 ■ Spring reStful ServiCeS Figure 5-3. POST Request and Response example The following describes the PUT example shown in Figure 5-4: • It updates an existing resource or creates it with a known destination URI. The URI of a resource contains an identifier for that resource. If that identifier is not generated by the application, but can be created by the client a behavior such as this can be implemented: when a PUT request refers to an existing resource, the resource is updated, otherwise a new resource with the identifier from the URI and the contents in the request body is created. • It is idempotent; repetitive execution has the same result. • It is not safe; repetitive updates could corrupt data. • When the resource being updated requires a parent that does not exist, or the resource requested to be updated does not exist, a 404 (Not Found), status code is returned. When the resource is updated correctly, a 200 (OK) (or a 204 (No Content) if not returning any content in the body) status code is returned. Figure 5-4. PUT Request and Response example 193 Chapter 5 ■ Spring reStful ServiCeS The following describes the DELETE example shown in Figure 5-5: • It deletes a resource. • It is idempotent; repetitive execution has the same result. • It is not safe; repetitive deletes could corrupt data. • When the resource being deleted does not exist, a 404 (Not Found), status code is returned. When the resource was deleted correctly, a 200 (OK) status code is returned. Figure 5-5. DELETE Request and Response example When it comes to REST, everything is about resource states and transferring them between a client and a server, in different forms. The request specifies the representation type using the Accept HTTP header for GET and the Content-Type HTTP header for PUT and POST, as you have seen in the preceding images, because when the client is not a browser (remember Chapter 3), the Accept header is taken into consideration. The URI extension can be used as a representation type identifier too. The response reports the representation type returned using the Content-Type HTTP header. When using Spring, the representation type is specified using an attribute of the @RequestMapping annotation and well-known media types defined in the MediaType class: @RestController @RequestMapping(value = \"/rest-persons\") public class PersonsRestController extends BaseController { ... @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"id/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public Person getPersonById(@PathVariable Long id) throws NotFoundException { logger.info(\"-----> PERSON: \" + id); Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } return person; } ... } 194 Chapter 5 ■ Spring reStful ServiCeS //Exception handler class for Rest errors. @ControllerAdvice(basePackages = \"com.pr.rest\") public class RestExceptionProcessor { / Maps NotFoundException to a 404 Not Found HTTP status code. @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"This entity is not found in the system\") @ExceptionHandler({NotFoundException.class}) public void handleNotFound(NotFoundException nfe) { // just return empty 404 logger.info(\"-----> Entity \" + nfe.getObjType() + \" with identifier\" + nfe.getObjIdentifier() + \"not found.\"); } } HATEOAS On his public blog,4 Roy Fielding mentioned that most REST services are not really RESTful, because fully RESTful services should only return links. Basically, HATEOAS implies that when a client makes a REST request to a server, the server should return a response that informs the client of all possible REST operations using links. For example, a resource should contain links to related resources, including URIs for editing it and deleting it, and so forth. Following this idea, well-known author Leonard Richardson defined the Richardson Maturity Model,5 which describes four levels of REST compliance: • Level 0, also known as the Swamp of POX. Only HTTP is used as a transport method. • Level 1, also known as the Resource Level. HTTP is used as a transport method and URIs are used to identify resources. • Level 2, also known as the HTTP Verb Level. This is the level where HTTP headers, statuses, methods, distinct URIs and everything else HTTP has to offer to provide a REST service. At this level, HTTP is used the way it’s meant to be. • Level 3, also known as the Hypermedia Controls Level. This is the final level, where a fully complying REST service should be. HATEOAS, an abbreviation for Hypermedia As The Engine Of Application State, is a constraint of the REST application architecture that distinguishes it from most other network application architectures. The principle is that a client interacts with a network application entirely through hypermedia provided dynamically by application servers. The Spring team has developed a separate project to make it easy to implement RESTful services that comply with the third level. Spring HATEOAS6 provides APIs to ease creating REST representations that follow the HATEOAS principle when working with Spring, and especially Spring MVC. 4This blog is at http://roy.gbiv.com. 5Martin Fowler has a great article on this at http://martinfowler.com/articles/richardsonMaturityModel.html. 6The project official page is at http://projects.spring.io/spring-hateoas/. 195 Chapter 5 ■ Spring reStful ServiCeS HATEOAS is a concept of application architecture, which defines the way clients interact with servers using hypermedia links they find inside representations returned by the server. To implement HATEOAS, resources representations must comply with a set of standards and contain hypermedia information. One of the most common standards used to hyperlink resources is HAL.7 A resource in HAL is just a plain-old JSON or XML object with whatever properties needed, but that provides the possibility to hyperlink resources. The following is a code snippet showing what a resource representation that complies to the HAL standard looks like: //GET Request: /persons/5 using JSON format // Response representation returned below: { \" links\": { \"self\": { \"href\": \"/persons/5\" }, \"parents\": [ { \"href\": \"/persons/2\", \"title\": \"mother\" }, { \"href\": \"/persons/3\", \"title\": \"father } ] }, \"firstName\" : \"John\", \"middleName\" : \"Constantine\", \"lastName\" : \"Smith\", \"dateOfBirth\" : \"1935-10-01\", \"gender\" : \"MALE\", \"hospital\" : { \"code\" : \"134181\", \"name\" : \"General Hospital\", \"address\" : \"Sample address\", \"location\" : \"Constance, Romania\" }, \"identityCard\" : { \"pnc\" : \"1351001134181\", \"series\" : \"CO\", \"number\" : \"205727\", \"emittedAt\" : \"1949-10-01\", \"expiresAt\" : \"1985-10-01\", \"address\" : \"34eeb1d5-0ff4-4d4a-b811-4ff32aa15ada\" } } //GET Request: /persons/5 analogous example using XML <?",
    "answer": "xml version=\"1.0\" encoding=\"utf-8\"?> <person rel=\"self\" href=\"/person/5\"> <linkList> <link rel=\"parent\" title=\"mother\" href=\"/persons/2\"/> <link rel=\"parent\" title=\"father\" href=\"/persons/3\"/> </linkList> 7This is at http://stateless.co/hal_specification.html. 196",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "REST is simple. • REST is widely supported. • Resources can be represented in a wide variety of data formats (JSON, XML, Atom, etc.). • You can make good use of HTTP cache and proxy servers to help you handle high loads and improve performance. • It reduces client/server coupling. • Browsers can interpret representations. • JavaScript can use representations. • A REST service can be consumed by applications written in different languages. • It is easy for new clients to use a RESTful application, even if the application was not designed specifically for a client. • Because of the statelessness of REST systems, multiple servers can be behind a load balancer and provide services transparently, which means increased scalability. • Because of the uniform interface, documentation of the resources and basic API operations are unnecessary. • The hypermedia constraint assures that application processing transitions are always navigable by clients, simply by following opaque server-provided links. Thus, the client does not need to understand anything more than the data format. (And when JSON is used, the data format is quite obvious.) • Using REST does not imply specific libraries at the client level in order to communicate with the server. With REST, all that is needed is a network connection. 197 Chapter 5 ■ Spring reStful ServiCeS REST services can be secured, but as the interaction between the client and server is stateless, credentials have to be embedded in every request header. Basic authentication is the easiest to implement without additional libraries (HTTP Basic, HTTP Digest, XML-DSIG, or XML-Encryption), but it guarantees the lowest level of security. Basic authentication should never be used without TLS (formerly known as SSL) encryption because the credentials can be easily decoded otherwise. In Figure 5-6, you can see how basic authentication is used when a client communicates with a RESTful application that requires basic authentication. Figure 5-6. Basic authentication when using RESTful systems ! When a collection is expected, it is enough use: /persons (plural) and /hospitals (plural). the /all link was used here because the original web controllers implemented in Chapter 3 were kept separate, so you can access the interface and verify the changes you are doing via reSt in the browser. Basically, the reSt and web functionalities are fully decoupled. and because the PersonsController was already mapped to /persons and the HospitalController was already mapped to /hospitals, there was no other way to do this but to map the reSt controllers to different urls. ! Snippets of code from the HospitalsRestController are not mentioned in the book, because the code is almost identical to the one for the reSt methods in PersonsController; the only difference is the resource type. But the code is available for you to practice on in the book’s code samples. Other common protocols used with RESTful systems are OAuth 1.0a and OAuth 2.0. Custom security implementation should be used only if necessary, because the skill to understand cryptographic digital signatures is quite difficult to master. There may be a lot more to say about REST in general, but the introduction to REST must end here, as this chapter is about Spring and how Spring can be used to develop RESTful applications. And you will notice that providing and consuming REST services with Spring is so easy that a deep understanding of REST is not actually needed. 198 Chapter 5 ■ Spring reStful ServiCeS RESTful Applications Using Spring MVC To learn how to implement and test RESTful services using MVC, module 09-pr-rest-practice was created. This module contains the implementation of the operations depicted in Figure 5-7. Figure 5-7. RESTful architecture for the practice section RESTful Clients with Spring A RESTful application can be accessed by any type of client that can create the type of request supported by the application. To test a Spring RESTful application, Spring provides two classes: RestTemplate and AsyncRestTemplate. The RestTemplate is Spring’s central class for synchronous client-side HTTP access. This class provides a wide set of methods for each HTTP method, which can be used to access RESTful services and enforces REST principles.8 Figure 5-8 depicts a correspondence between HTTP methods and RestTemplate methods that can be used to access REST services. 8Javadoc for this class can be found at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/ springframework/web/client/RestTemplate.html. 199 Chapter 5 ■ Spring reStful ServiCeS Figure 5-8. RestTemplate api to HTTP methods correspondence As you can see, the execute and exchange methods can be used for any type of REST calls, as long as the HTTP method is given as a parameter for the methods. All methods are polymorphic,9 and using one or another depends on the requirements and the developer’s preferences. URI instances are returned to identify resources, and RestTemplate methods support URI templates. So, the following two calls are identical: //using URI Template String url = \"http://localhost:8080/mvc-rest/rest-person/id/{id}\"; Person person = restTemplate.getForObject(url, Person.class, \"1\"); // using URI String url = \"http://localhost:8080/mvc-rest/rest-personid/1\"; Person person = restTemplate.getForObject(url, Person.class); 9Multiple methods with the same name, but different signatures are provided. Just check out the Spring API for RestTemplate at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/ RestTemplate.html. 200 Chapter 5 ■ Spring reStful ServiCeS The execute method can also be given a RequestCallback implementation as a parameter, which tells the RestTemplate what to do with the request before sending it to the server. Considering this, a GET request for a Person instance with id=1 could be written with the exchange method like this: String url =\"http://localhost:8080/mvc-rest/rest-person/id/{id}\"; Person person = restTemplate.execute(url, HttpMethod.GET, new RequestCallback() { @Override public void doWithRequest(ClientHttpRequest request) throws IOException { HttpHeaders headers = request.getHeaders(); headers.add(\"Accept\", MediaType.APPLICATION_JSON_VALUE); System.out.println(\"Request headers = \" + headers); } }, new HttpMessageConverterExtractor<Person>(Person.class, restTemplate.getMessageConverters()) , new HashMap<String, Object>() {{ put(\"id\", \"1\"); }}); Objects passed to and returned from the methods getForObject(), postForLocation(), and put() are converted to HTTP requests and from HTTP responses by HttpMessageConverters. Message converters are automatically detected and used by Spring in applications configured with <mvc:annotation-driven/> or @EnableWebMvc. In the code sample for this chapter, the representations are in JSON format, so MappingJackson2HttpMessageConverter is used. And because the message format is supported by default, the HttpMessageConverterExtractor<T> is not necessary in the previous example. Also, if no Accept header is specified, all formats supported by Spring are considered. So in this case, RequestCallback becomes unnecessary too, so you can stick to the simpler restTemplate.getForObject method that was mentioned in the previous code snippet. Speaking of message converters, restTemplate deals only with objects, so it internally converts resources to representations, and vice-versa, using message converter implementations of the HttpMessageConverter<T> interface. Spring comes with a default long list of supported message converters, but if necessary, a developer can provide his own implementation of the HttpMessageConverter<T>. Table 5-2 provides a list of the most commonly used message converters and the datatype handled: Table 5-2. Message Converters Message Converter Data Type Observation StringHttpMessageConverter text/plain MappingJackson2HttpMessageConverter application/*+json Only if Jackson 2 is present on the classpath AtomFeedHttpMessageConverter application/atom+xml Only if Rome is present on the classpath RssChannelHttpMessageConverter application/rss+xml Only if Rome is present on the classpath MappingJackson2XmlHttpMessageConverter application/*+xml Only if Jackson 2 is present on the classpath 201 Chapter 5 ■ Spring reStful ServiCeS To use a restTemplate, you can define and initialize it directly where you need it, or declare a bean and inject it. restTemplate handles HTTP connections internally, so the developer does not have to write extra code with opening and closing connections. A different HTTP client can also be used, and Apache provides an implementation that can be injected into a RestTemplate bean. This is highly recommended for production applications when authentication and HTTP connection pooling are usually needed. To use the Apache Commons HttpClient, Spring provides a factory class named HttpComponentsClientHttpRequestFactory, which provides an HttpClient instance that uses a default org.apache.http.impl.conn.PoolingClientConnectionManager10 that is able to service connection requests from multiple execution threads. <bean id=\"restTemplate\" class=\"o.s.web.client.RestTemplate\"> <property name=\"requestFactory\"> <bean class= \"o.s.http.client.HttpComponentsClientHttpRequestFactory\"/> </property> </bean> Configuring a RestTemplate bean using Java Configuration looks like this: \\\\in the @Configuration and @EnableWebMvc annotated class @Bean public RestTemplate restTemplate() { RestTemplate restTemplate = new RestTemplate(); restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory()); return restTemplate; } Other examples of restTemplate usage are in the following code snippet: // GET request to retrieve all persons born at a hospital with a specific code String url = \"http://localhost:8080/mvc-rest/rest-hospitals/{code}/persons\"; Person[] persons = restTemplate.getForObject(url, Person[].class, \"134181\"); // POST request to create a person Person person = buildPerson(); final HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); final HttpEntity<Person> personRequest = new HttpEntity<>(person, headers); String url = \"http://localhost:8080/mvc-rest/rest-persons/create\"; // this method returns the created resource Person newPerson = this.restTemplate.postForObject(url, personRequest, Person.class); //this method returns the URI of the created resource URI uri = this.restTemplate.postForLocation(url, personRequest, Person.class); //DELETE request to delete a person by id String url = \"http://localhost:8080/mvc-rest/rest-persons/delete/23\"; restTemplate.delete(url); 10The class is part of the Apache http-client library. JavaDoc API can be accessed at http://hc.apache.org/ httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/ conn/PoolingClientConnection Manager.html. 202 Chapter 5 ■ Spring reStful ServiCeS REST services are used most commonly by AJAX components in a web application, and currently all HTTP methods are supported in AJAX. But most browsers do not support any other methods besides GET and POST in HTML forms. To use them in a form, Spring has introduced hidden methods. Basically, a hidden input is added to a form with a regular POST method. If the POST request is to be treated as a PUT request, the value of the field will be equal to this method name, as shown in the code sample below. A filter interceptor intercepts the request, searches for that parameter, and modifies the request accordingly before sending it to the appropriate handler. For this to work, the Spring form has the method attribute value set to the desired HTTP method, and the resulting HTML form has a hidden field added: <!-- Spring form --> <sf:form method=\"put\" action=\"..\" modelAttribute=\"..\"> ... </sf:form> <!-- HTML form --> <form method=\"post\" action=\"...\"> <input type=\"hidden\" name=\"method\" value=\"put\" /> ... </form> The filter interceptor that takes care of intercepting requests and modifying the methods is the HiddenHttpMethodFilter, which can be configured in a web.xml file or in a class implementing WebApplicationInitializer. <!-- in web.xml --> <!-- Enables use of HTTP methods PUT and DELETE --> <filter> <filter-name>httpMethodFilter</filter-name> <filter-class>o.s.web.filter.HiddenHttpMethodFilter</filter-class> </filter> <filter-mapping> <filter-name>httpMethodFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> \\\\in class extending AbstractDispatcherServletInitializer \\\\ or AbstractAnnotationConfigDispatcherServletInitializer @Override protected Filter[] getServletFilters() { return new Filter[] { new HiddenHttpMethodFilter()}; } Asynchronous REST Calls At the beginning of this section, AsyncRestTemplate was mentioned. This class can be used to create Spring REST clients that make asynchronous calls to a REST service. The AsyncRestTemplate class is nothing other than a wrapper class for RestTemplate that provides the asynchronous behavior via a set of methods (analogous to the ones in RestTemplate) that return Future<T> wrappers (or ListenableFuture<F> 203 Chapter 5 ■ Spring reStful ServiCeS that extends Future<T> when a callback method is needed) instead of concrete data. An example of an asynchronous GET request can be found in the AsyncRestTemplateTest class, in the 07-pr-rest-solution. In the same class, you can also find an example with a callback. private static final String PERSON_BASE_URL = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; AsyncRestTemplate asyncRestTemplate = new AsyncRestTemplate(); ... Future<ResponseEntity<Person>> futurePerson = asyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\"); //waiting a little, to give time to the async call to complete Thread.sleep(1000L); ResponseEntity<Person> result = futurePerson.get(); Person person = result.getBody(); assertNotNull(person); //callback example ListenableFuture<ResponseEntity<Person>> futurePerson = asyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\"); futurePerson.addCallback(new ListenableFutureCallback<ResponseEntity<Person>>() { @Override public void onSuccess(ResponseEntity result) { Person person = (Person) result.getBody(); assertNotNull(person); } @Override public void onFailure(Throwable t) { logger.error(\"------> Async call failure!\", t); } }); Implementing REST with Spring MVC There are multiple Java frameworks available for implementing RESTful applications: Spark, Restlet, JAX-RS(Java EE), and RESTEasy, but Spring MVC is the easiest to use. This section contains a lot of information and code snippets to convince you that this affirmation is true. REST support was added to Spring MVC in version 3.0, and although developing RESTful applications was always easy, in version 4.x things have become even more practical. Among the aforementioned frameworks, JAX-RS is shipped with out-of-the-box Spring Integration. This framework encapsulates the Java API for RESTful web services (JAX-RS, defined in JSR 311). Jersey, the reference implementation of JAX-RS, implements support for the annotations defined in JSR 311, making it easy for developers to build RESTful web services by using the Java programming language. It is focused more on application-to-application communication, so the focus is not on browser clients. That’s the amazing thing about Spring MVC—a Spring RESTful application does not care about its client type at all. 204 Chapter 5 ■ Spring reStful ServiCeS Spring MVC provides the following resources to build RESTful applications: • The potential to declare status codes. • URI templates. • Content negotiation. • Many message converters offer out-of-the-box support. • RestTemplate and AsyncRestTemplate classes are used for easily creating client applications or for testing RESTful application services. • Browsers are supported as clients, although HTTP method conversion is necessary for PUT and DELETE methods. When making REST requests from a web page, jQuery can be used (this is covered in Chapter 6). A few of these have already been mentioned in the previous section, as they were involved in creating REST clients; the others are covered in this section. To develop a RESTful service class with Spring MVC, you have to do the most obvious thing: create a controller that contains handler methods that return resources representations instead of views, which are the actual response body. In Spring 3.0, we had to do the following: @Controller @RequestMapping(value = \"/rest-persons\") public class PersonsRestController { @Autowired PersonManager personManager; @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET) public @ResponseBody Person getPersonById(@PathVariable Long id) throws NotFoundException { Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } return person; } } Looks like any MVC controller, right?",
    "answer": "The only difference is the @ResponseBody that indicates a method return value should be bound to the web response body. The advantage here is that, in the same controller you can also have methods that are not used to provide REST representations, having all the people management data in one place. But, because it is a good practice to decouple code with different scopes, in Spring MVC 4.0 the @RestController was introduced. This annotation is conveniently annotated with 205",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "In the REST client to encapsulate every detail about a REST request that is made by calling restTemplate.exchange. final String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; final RequestEntity<Person> entity = RequestEntity.post(new URI(url)) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) //setting a custom header that will be accessed in the handler method .header(\"custom\", \"true\") .body(person); ResponseEntity<Person> response = restTemplate.exchange(entity, Person.class); Person newPerson = response.getBody(); //get URI location for the Person created HttpHeaders headers = response.getHeaders(); URI uri = headers.getLocation(); • In the RESTful handler method to access request headers, read the body of a request, and write headers to the response stream. @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create3\", method = RequestMethod.POST) public ResponseEntity<Person> handle(HttpEntity<Person> requestEntity, @Value(\"#{request.requestURL}\") StringBuffer originalUrl) throws UnsupportedEncodingException { // will return \"true\" String requestHeader = requestEntity.getHeaders().getFirst(\"custom\"); //we are just making sure the header is the one sent from the client assertTrue(Boolean.parseBoolean(requestHeader)); Person person = requestEntity.getBody(); Hospital hospital = hospitalManager. findByCode(person.getHospital().getCode()); person.setHospital(hospital); Person newPerson = personManager.save(person); HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.set(\"Location\", getLocationForPersonResource(originalUrl, person.getId())); return new ResponseEntity<>(newPerson, responseHeaders, HttpStatus.CREATED); } 212 Chapter 5 ■ Spring reStful ServiCeS ! as with @RequestBody and @ResponseBody, Spring uses HttpMessageConverter<T> to convert to and from the request and response streams. the HttpMessageConverter<T> and supported implementations were covered in the “reStful applications using Spring MvC” section. Asynchronous REST Services Using @Async Annotated Methods The “Asynchronous REST Calls” section showed how to make an asynchronous REST call using the AsyncRestTemplate class. In that case, the client did the rest call and could then focus on other operations until the Future object returned the concrete data. But asynchronous calls can be made in a different way using @Async annotated methods. This annotation marks a method as a candidate for asynchronous execution. It can also be used at type level; in this case, all methods in the class are considered asynchronous. Asynchronous methods can have any signature and any parameter types. There are absolutely no restrictions about this. However, the return type is restricted to void and Future (and implementations of this interface). Immediately after a client calls an asynchronous method, the invocation returns and the execution of the method is submitted to a Spring TaskExecutor12. Asynchronous methods that return void are used when the client does not expect a reply. By default, to execute a method annotated with @Async, the executor that is used is the one supplied to the <task:annotation-driven/> element. (The Spring Task namespace was introduced in Spring 3.0 to help configure TaskExecutor and TaskScheduler instances.) <task:annotation-driven executor=\"prExecutor\"/> <task:executor id=\"prExecutor\" pool-size=\"100\"/> In Java Configuration, support for @Async can be enabled using @EnableAsync in one of the configuration classes of the application—those annotated with @Configuration. To provide a different executor, like in the preceding XML example, the class must implement org.springframework.scheduling. annotation.AsyncConfigurer and provide a concrete implementation for the getAsyncExecutor method. @Configuration @EnableAsync public class AppConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(100); executor.initialize(); return executor; } ... } 12Spring’s TaskExecutor interface is equivalent to the java.util.concurrent.Executor interface and extends it without modifying the API in order for clients to declare a dependency on an executor and receive any TaskExecutor implementation. It was created to remove the need for Java libraries when using thread pools. 213 Chapter 5 ■ Spring reStful ServiCeS Also the @Async annotation has a value attribute to indicate that an executor other than the default should be used when the executor13 is defined as a bean: @Async(\"otherExecutor\") public Future<Person> findPerson(Long id) throws InterruptedException { String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; Person person = restTemplate.getForObject(url, Person.class, \"1\"); Thread.sleep(1000L); return new AsyncResult<>(person); } <!-- in a spring configuration file we define an Executor bean --> <bean id=\"otherExecutor\" class=\"o.s.scheduling.concurrent.ThreadPoolTaskExecutor\" init-method=\"initialize\" destroy-method=\"shutdown\"> <property name=\"corePoolSize\" value=\"100\"/> </bean> // in a class annotated with @Configuration @Bean(name=\"otherExecutor\", destroyMethod = \"shutdown\", initMethod = \"initialize\") ThreadPoolTaskExecutor getExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(100); return executor; } ! an example of an @Async annotated method and usage can be found in 07-pr-rest-solution. the example is covered in the “practical exercise” section. Intercepting REST Calls There is a section in Chapter 3 about handler interceptors for controller methods, which mentions that REST requests can be intercepted too, but the REST interceptors have to implement the ResponseBodyAdvice<T> or extend one of its subclasses and provide the proper implementation for the beforeBodyWrite and supports. When extending JsonViewResponseBodyAdvice or AbstractMappingJacksonResponseBodyAdvice, the beforeBodyWriteInternal method must be implemented, because the AbstractMappingJacksonResponseBodyAdvice class provides a concrete implementation for beforeBodyWrite, which calls beforeBodyWriteInternal after creating a proper JSON body container. ResponseBodyAdvice<T> implementation allows you to customize the response after the execution of a @ResponseBody or a ResponseEntity<T> method, but before being passed for conversion to an HTTP message converter. These interceptors are annotated with @ControllerAdvice and are automatically picked up and used by Spring. 13You can see all methods available for a ThreadPoolTaskExecutor at http://docs.spring.io/spring/docs/4.1.x/ javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html. 214 Chapter 5 ■ Spring reStful ServiCeS In the 07-pr-rest-solution module, such an interceptor is implemented for you: @ControllerAdvice(basePackages = \"com.pr.rest\") //this interceptor is retricted to the classes in package \"com.pr.rest\" public class AuditRestInterceptor extends JsonViewResponseBodyAdvice { private Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class); @Override public boolean supports(MethodParameter returnType, Class converterType) { logger.info(\"-----> Audit REST interceptor supports(Person.class) ?",
    "answer": "\" + Person.class.isAssignableFrom(returnType.getParameterType())); return (super.supports(returnType, converterType) && returnType.getMethodAnnotation(JsonView.class) != null); } .... } The supports method tests if the AuditRestInterceptor supports the given controller method return type and the selected HttpMessageConverter<T> type. The value logged in the preceding supports method implementation is true if the controller method return type is assignable to a reference of type Person. @ControllerAdvice(basePackages = \"com.pr.rest\") //this interceptor is retricted to the classes in package \"com.pr.rest\" public class AuditRestInterceptor extends JsonViewResponseBodyAdvice { private Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class); ... @Override protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) { logger.info(\"-----> Audit REST interceptor beforeBodyWrite\"); response.getHeaders().add(HttpHeaders.CONTENT_ENCODING, \"UTF-8\"); super.beforeBodyWriteInternal(bodyContainer, contentType, returnType, request, response); } } In the beforeBodyWriteInternal, the CONTENT_ENCODING header is added to the response, so the presence of this header can be tested in the client and you can make sure that the interceptor did its job. After that, the super.beforeBodyWriteInternal() is called to keep the original behavior of the extended class, which is to modify the response body before being converted and sent back to the client. 215",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is REST?",
    "answer": "A. a software design pattern B. a framework C. an architecture style",
    "source": "extracted",
    "confidence": 0.68
  },
  {
    "question": "Which of the following methods are HTTP methods?",
    "answer": "A. PUT B. GET C. SUBMIT D. OPTIONS",
    "source": "extracted",
    "confidence": 0.34
  },
  {
    "question": "What Spring class can be used to access and test REST services?",
    "answer": "A. RestTemplate B. AsyncRestTemplate C. Both D. None",
    "source": "extracted",
    "confidence": 0.52
  },
  {
    "question": "What does the RestTemplate handle?",
    "answer": "A. Resources B. Representations C. Both",
    "source": "extracted",
    "confidence": 0.39
  },
  {
    "question": "What can be said about the @RestController annotation?",
    "answer": "A. It is used to declare a controller providing REST services. B. Is annotated with @Controller and @ResponseBody. C. Controller methods annotated with @RequestMapping assume @ResponseStatus semantics by default when the controller is annotated with @RestController.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the effect of annotating a method with @ResponseStatus?",
    "answer": "A. The default behavior for resolving to a view for methods returning void or null is overridden. B. The HTTP status code matching the @ResponseStatus is added to the response body. C. It forces usage of HTTP message converters.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Which of the following HTTP message converters are supported by Spring MVC?",
    "answer": "A. StringHttpMessageConverter B. MappingJackson2HttpMessageConverter, but Jackson2 must be in the classpath C. YamlMessageConverter 221",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Which of the following RestTemplates can be used to make a GET REST call to a URL?",
    "answer": "A. restTemplate.getForObject(...) B. optionsForAllow(...) C. getForEntity(...) D. exchange(..., HttpMethod.GET,...)",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Does the following REST handler method comply with the HATEOAS constraint?",
    "answer": "@ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public Person createPerson(@RequestBody @Valid Person newPerson) { logger.info(\"-----> CREATE\"); Hospital hospital = hospitalManager.findByCode( newPerson.getHospital().getCode()); newPerson.setHospital(hospital); Person person = personManager.save(newPerson); logger.info(\"-----> PERSON: \" + person); return person; } A. Yes, because it returns a representation of the object that was created. B. No, because it does not set the location header to the URI of the created resource. C. This is not a REST handler method. D. No, because a Link object is not added to the returned resource. Practical Exercise The practical exercises for this chapter require you to develop some REST client test methods to check your understanding of implementing RESTful application with Spring MVC. The project module is named 07-pr-rest-practice. An analogous module with proposed solutions exists, which is named 07-pr-rest-solution. The projects and their TODOs are shown in Figure 5-10. 222",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "com.pr.config contains the Java Configuration class used to configure the application. • com.pr.hateoas contains classes that describe a hypermedia-driven REST web service • com.pr.problem contains classes that handle the exceptions thrown in the application. – GlobalExceptionHandler handles exceptions thrown by methods in the controllers under the com.pr.web package. The restriction is done using @ControllerAdvice(basePackages = \"com.pr.web\"). – NotFoundException is a type of exception thrown when a resource cannot be found. – RestExceptionProcessor handles exceptions thrown by methods in the REST controllers under the com.pr.rest package. 223 Chapter 5 ■ Spring reStful ServiCeS • com.pr.rest contains classes that implement REST services and interceptors. – AuditRestInterceptor is an interceptor for REST services that prints simple messages and adds a header to the response before it is written. – HospitalsRestController is a REST controller for managing Hospital resources. – PersonsRestController is a REST controller for managing Person resources. • com.pr.web contains the web controllers that receive requests from a browser and return views. The structure of the project is depicted in Figure 5-11. Figure 5-11. Package organization of the 07-pr-rest-practice project module The tests for the rest controllers are located under the same packages as the controllers being tested. The only exception is the com.pr.async that contains a configuration class, a service class, and a test class used to test an asynchronous REST method annotated with @Async. You have no TODO tasks in this package; the example is simply provided for you to run it and see how an REST asynchronous is made. All the TODO tasks are in the RestPersonControllerTest class. They cover GET, POST, and DELETE operations. The practical exercise for this chapter requires Gradle tasks to be run in parallel, because the REST tests require the web application to be started. To do this, you have to create an Intellij IDEA Gradle launcher to start the application, and another to stop it. The test cases are run by right-clicking the method you want to execute, and then selecting Run from the menu that appears. 224 Chapter 5 ■ Spring reStful ServiCeS To create a Gradle launcher, you have to do the following: 1. In the Gradle Task view, right-click the appStart task. A menu is displayed. Select Create personal-records:07-pr-rest-practice. 2. In the popup check the Single instance only check box. Modify the name to something more relevant, like mvc-rest-start. 3. Click Apply, and then OK. Your launcher should be available in the Intellij IDEA launcher menu. The flow for creating a Gradle launcher is depicted in Figure 5-12. Do the same to create a launcher for the appStop task. Figure 5-12. Creating a Gradle launcher 225 Chapter 5 ■ Spring reStful ServiCeS Then from the launcher menu, select the mvc-rest-start launcher and start the application. If the application starts correctly, you should see in the console the following log: INFO Jetty 9.2.10.v20150310 started and listening on port 8080 INFO mvc-rest runs at: INFO http://localhost:8080/mvc-rest Run 'gradle appStop' to stop the server. Open the link in a browser. You should see the page shown in Figure 5-13. Figure 5-13. The mvc-rest web application The web application will help you verify that your REST requests have executed correctly. Once you have the web application up, you can go ahead and try to solve the TODO tasks. There are eight TODOs, numbered from 15 to 22, that require you to perform certain types of REST requests. ! get requests can be done directly in the browser, so if you want to get creative with get reSt handler methods, you can test them in a browser. for example, try to access http://localhost:8080/mvc-rest/ rest-persons/id/1. You should see a JSOn reply like the one depicted in the figure 5-14. 226 Chapter 5 ■ Spring reStful ServiCeS Figure 5-14. JSON response for a GET REST request To format JSON representations properly for display, a @MappingJackson2HttpMessageConverter bean has to be defined and configured accordingly. There are two ways of doing this: • Call setPrettyPrint on the @MappingJackson2HttpMessageConverter @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); converter.setObjectMapper(objectMapper()); converter.setPrettyPrint(true); return converter; } @Bean public ObjectMapper objectMapper() { return new ObjectMapper(); } 227 Chapter 5 ■ Spring reStful ServiCeS • Enable the indentation of the serialization output by calling enable on the objectMapper set for the @MappingJackson2HttpMessageConverter bean @Bean public ObjectMapper objectMapper() { ObjectMapper objMapper = new ObjectMapper(); objMapper.enable(SerializationFeature.INDENT_OUTPUT); return objMapper; } ! pOSt and Delete requests can be tested using a firefox plugin called poster.14 figure 5-15 shows a reSt pOSt request and response done with poster. Figure 5-15. POST REST request and response done with Poster. You have to copy and paste the RequestBody into the Poster content text area 14The plugin can be found at https://addons.mozilla.org/en-US/firefox/addon/poster/. 228 Chapter 6 Spring Web with AJAX The topic of this chapter is not a subject in the certification exam, but it is useful to know all the tools that can be used to develop a web application in the most efficient way. A properly designed user interface should ensure that a request is sent to the server only when the content of the request is complete and valid so that it can be used by a server operation. Using requests between the client and the server application is not a good practice. It is time-consuming and can go wrong when the network connection is unstable. What Is AJAX?",
    "answer": "AJAX is an acronym for asynchronous JavaScript and XML, but over the years, this term has grown and means so much more than the technologies that make the acronym. AJAX describes the way that various web technologies can make web applications highly responsive and provide the user with an almost desktop-like interaction. Basically, web applications developed with AJAX can provide rich interaction, just-in-time information, and dynamic information without a page refresh. Of course, this comes with programming complexity; some of the logic that happens on the server must be moved on the client side, where the logic must be implemented in JavaScript. The most obvious example is the validation of user input. There's no point in sending invalid data to the server, right?1 Before AJAX, a web application functioned like this: 1. The user requested a page using a browser. 2. The server where the web application was installed created and sent a response to be rendered in the browser. 3. The user sent some data to the server. 4. The server received the data and validated it. If the validation failed, the data and validation errors were put into a response that was sent back to the browser. 5. The response was received by the browser, which displayed the new page. 1There are JavaScript libraries that can validate form user input before submission; for example, the jQuery validation plugin (http://jqueryvalidation.org). 229",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is AJAX?",
    "answer": "A. a framework to create responsive web pages B. a set of standards on how to create responsive web pages C. an acronym for Asynchronous JavaScript and XML D. a set of technologies that can be used to create highly responsive web applications",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What can be said about jQuery?",
    "answer": "A. It is a tag library. B. It is a set of technologies to create responsive web pages. C. It is the most popular JavaScript library.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What jQuery method can be used to make a GET request?",
    "answer": "A. $.get B. $.getJSON C. $.ajax D. $.post 12Oracle custom tags creation; see https://docs.oracle.com/javaee/7/tutorial/. 253",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is a custom JSP tag?",
    "answer": "A. a custom tag is a user-defined JSP language element B. a special class that handles JSP tasks execution Practical Exercise The practical exercises for this chapter require you to develop a REST handler method to search and return a list of people matching the criteria sent from the browser, as well as a few JavaScript functions using jQuery to display results and errors. You'll use the 08-pr-ajax-practice project module. 08-pr-ajax-solution is analogous module with a proposed solution. This module also contains extra implementations that were mentioned earlier in the chapter. The TODO tasks for this chapter are shown in Figure 6-9. Figure 6-9. TODO tasks for Spring with AJAX practice module 254",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Duplicate submissions. • Pop-up window support within a flow. • State synchronization problems between the server and the client caused by using the browser’s back and refresh buttons. • State collisions between windows. • Stale session state. (A session can end up containing inactive data, when a timeout is set. The inactive items must be precisely identified and purged.) • Short-circuiting navigation rules. (Possibility to jump over steps in the navigation, depending on navigation conditions.) Web Flow Architecture In Spring Web Flow, flows are defined using an XML-based flow definition language. The backing classes follow the model already established by Spring MVC. Spring Web Flow provides its own classes to identify handler methods matching flow execution requests and resolving views. The DispatcherServlet is still the front controller when the application is servlet based. For implementation with portlets, there is an analogous implementation provided with DispatcherPortlet(s) as entry points. The similarities with the Spring MVC model can be observed in Figure 7-2. Figure 7-2. The Spring Web Flow backing classes 259 Chapter 7 ■ Spring Web FloW The FlowController class is the adapter between the Spring MVC Controller layer and the Spring Web Flow engine. Its responsibility is to provide implementation so that Spring Web Flow can run embedded as a controller within a DispatcherServlet. So basically, the FlowController is itself a front controller for Spring Web Flow. The FlowHandlerMapping maps all flow requests to the appropriate handlers using FlowDefinitionRegistry. The FlowHandlerAdapter takes care of executing the flow handler methods in a servlet environment using the FlowExecutor implementation. After they do their jobs, the DispatcherServlet uses the FlowViewResolver interface to resolve a view from the state of an executing flow. When working with flows, each flow definition is declared in a specific configuration file and is registered in the system by the FlowDefinitionRegistry. For each flow in the system, a configuration file is created and placed in the same directory with all resources implied in the flow execution: views templates, property files, and others. In Figure 7-3, you can see how the files are organized in the practice project for this chapter. Figure 7-3. Personal Records Manager web flow configuration file and resources 260 Chapter 7 ■ Spring Web FloW The newPerson-flow.xml configuration file contains the states that the users are directed through to create a new person. For now, the empty file is presented containing only the Spring Web Flow namespace used to define flow elements: <?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <!-- states and actions will be placed here later --> </flow> The flows are exposed to the client as web resources. The client starts flows by accessing these resources. For example, accessing http://localhost:8080/webflow-basic/persons/newPerson starts the newPerson flow. (The reason the URL has that particular structure is explained later.) Starting a flow actually means starting a new flow execution, meaning an execution context for the task currently in progress is created. The execution context is user session-scoped, meaning all the variables and data needed for the execution of the task is kept in the user session, unless an execution step requires otherwise. (Sometimes data can be saved to the database and removed from the session.) Web Flow Internal Logic When the flow starts executing, you can use the URL changing to http://localhost:8080/webflow-basic/persons/newPerson?execution=e1s1 The parameter execution is the session-scoped execution key. Its value contains the flow execution identifier (e1) and the identifier of the execution step that is currently in progress (s1). Every time the flow progresses a step, the step identifier is incremented. Every time a new flow execution is started, the execution identifier is incremented. A user resumes flow executions by clicking buttons in the interface—buttons (or links) that have events associated with them using the name property. For example: <button id=\"newPersonButton\" name=\" eventId proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> So when the button with the newPersonButton id is clicked, a request is sent to the URL. .../persons/newPerson?execution=e1s1&_event_id=proceed The data provided by the user is bound to the flow context. The flow handles the event, processes the data as defined, and decides what to do next based on the definition of the flow: display a new view to the user, display the same view, and remain in the same step of execution if validation failed or ends the flow. When a flow execution has ended, the execution cannot be resumed; this implies that the transaction cannot be completed multiple times. After a flow execution ends, the flow state is automatically cleaned. The interaction between a client and a flow always consists of two separate steps: the client will request a resource or activate (trigger) an event and the flow will redirect to the appropriate state. This means that each web flow interaction involves two requests: the client request and the flow redirect request. This has another implication: the data submitted by the initial request will not be available after the redirecting is 261",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "MVC infrastructure beans in mvc-config.xml • application custom beans in app-config.xml • Web Flow infrastructure beans in webflow-config.xml • Security infrastructure beans in security-config.xml 262 Chapter 7 ■ Spring Web FloW When configuring an application that uses Web Flow, there are roughly three steps that have to be covered: 1. A flow executor and a flow registry bean have to be defined and configured to match the structure of the application so that the flows can be executed correctly by Spring Web Flow. 2. A flow adapter and a flow mapping bean have to be defined and added to the list of existing handler mapping and handler adapter beans for the Spring MVC configuration to enable flow handling by Spring MVC. 3. An MvcViewFactoryCreator bean has to be created and configured to use the bean view resolvers already defined in the application. The following two sections cover how this is done when using XML and Java Configuration. Configuration Using XML As mentioned in previous chapters, the Spring MVC configuration infrastructure beans are defined in the examples of this book into a file named mvc-config.xml. In this file, FlowHandlerMapping and FlowHandlerAdapter bean definitions have to be added: <?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <mvc:annotation-driven conversion-service=\"typeConversionService\" validator=\"validator\"/> <bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/> <!-- Define a custom ConversionService --> <bean id=\"typeConversionService\" class=\"o.s.format.support.FormattingConversionServiceFactoryBean\"> ... </bean> 263",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "flowExecutor: This bean created is of type FlowExecutorImpl and it uses the flowRegistry bean to identify all flows eligible for execution. This bean is the entry point into the Web Flow system, as it manages starting and resuming flow executions. When an executor bean is created, Spring automatically looks for a flow registry bean named flowRegistry, so the preceding definition can be simplified to <webflow:flow-executor id=\"flowExecutor\"/> Also, because this is the central bean of the Spring Web Flow engine, listeners can be registered for it to verify rights to perform specific execution steps or audit the execution steps for debugging purposes. <webflow:flow-executor id=\"flowExecutor\"> <webflow:flow-execution-listeners> <webflow:listener ref=\"secureFlowExecutionListener\" /> <webflow:listener ref=\"auditFlowExecutionListener\" /> <webflow:flow-execution-listeners> </webflow:flow-executor> ... <bean id=\"secureFlowExecutionListener\" class=\"org.springframework.webflow.security.SecurityFlowExecutionListener\"/> <bean id=\"auditFlowExecutionListener\" class=\"com.pr.audit.AuditFlowExecutionListener\"/> ■ ! the flow execution listeners can be configured to be applied only on certain flows; for example: <webflow:listener ref=\"secureFlowExecutionListener\" criteria=\"administrativeFlow1, administrativeFlow2\"/> 265 Chapter 7 ■ Spring Web FloW the flowExecutor can be configured to tune flow execution persistence settings by adding a customized definition for flow-execution-repository. <webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\"> <webflow:flow-execution-repository max-executions=\"5\" max-execution-snapshots=\"30\" /> </webflow:flow-executor> the max-executions property is used to configure the maximum number of persistent flow executions allowed per user session. When the maximum number of executions is exceeded, the oldest execution is removed. the max-execution-snapshots property is used to configure the maximum number of history snapshots allowed per flow execution. history snapshots enable browser back button support. When snapshotting is disabled, pressing the browser back button will not work. it will result in using an execution key that points to a snapshot that has not been recorded. • flowRegistry: Each flow definition registered in this registry bean is assigned a unique identifier. The base-path property is used specify the root directory, under which all the flow definition files are found; usually this is the WEB-INF directory. The flow-location-pattern further narrows the search for the flow definitions, providing a wildcard template file name for the flow definition files. But flow definitions can be also registered one at a time using flow-location elements. For example: <webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\" flow-builder-services=\"flowBuilderServices\"> <webflow:flow-location path=\"persons/newPerson/newPerson-flow.xml\"/> </webflow:flow-registry> • flowBuilderServices: This bean registers custom implementations of services needed to build flow definitions: view resolvers, data convertors, formatters, validators, and others. In version 2.4.0.RELEASE, the validation-hints were added, so flow definition can apply partial validation on the model through the validation- hints attribute supported on view state and transition elements. This bean was modified to add a property named validation-hint-resolver that can be used to set a custom validation hints resolver. (An example is presented later in the book.) ■ ! the development=\"true\" is quite important, because as you will solve the practice exercises, you might not want to restart the application every time you make a change to a flow definition. Setting the development property to \"true\" ensures that changes to a flow definition is autodetected and results in a flow refresh. 266 Chapter 7 ■ Spring Web FloW • mvcViewFactoryCreator: This bean is used by a FlowBuilder to configure a flow’s view states with Spring MVC–based view factories. In this case, the tiles view resolver is injected into it, so it can be used to resolve view states using it. The useSpringBeanBinding property is set to “true” to enable the same binding system used by the Spring MVC in a Web Flow environment. • conversionService: This bean is a wrapper for the conversion service bean used by Spring MVC, which is provided to the flowBuilderServices bean to be used during a flow execution. Configuration Using Annotations For the 09-pr-webflow-basic-practice, a full Java Configuration is used; no web.xml. Three classes were defined for such proposes under the com.pr.config package. Figure 7-5 depicts all three classes, their parents, and the relationship between them. Figure 7-5. Configuration classes for Personal Records Manager project when Spring Web Flow is used ■ ?",
    "answer": "Can you tell which class takes care of a certain part of the infrastructure just by looking at the diagram in Figure 7-5? 267",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The MvcConfig class encapsulates the Spring MVC infrastructure bean definitions that were covered in Chapter 3. To plug in the Web Flow beans, some modifications were done. The webFlowConfig was injected so the handler mapping and handler adapter specific to flows could be configured. ... import org.springframework.webflow.mvc.servlet.FlowHandlerAdapter; import org.springframework.webflow.mvc.servlet.FlowHandlerMapping; @Configuration @EnableWebMvc public class MvcConfig extends WebMvcConfigurerAdapter { @Autowired private WebFlowConfig webFlowConfig; //other Spring MVC infrastructure beans: formatters, interceptors, // resolvers, etc. Review Chapter 3 for reference. ... //Web Flow specific infrastructure beans @Bean public FlowHandlerMapping flowHandlerMapping() { FlowHandlerMapping handlerMapping = new FlowHandlerMapping(); handlerMapping.setOrder(-1); handlerMapping.setFlowRegistry(this.webFlowConfig.flowRegistry()); return handlerMapping; } @Bean public FlowHandlerAdapter flowHandlerAdapter() { FlowHandlerAdapter handlerAdapter = new FlowHandlerAdapter(); handlerAdapter.setFlowExecutor(this.webFlowConfig.flowExecutor()); handlerAdapter.setSaveOutputToFlashScopeOnRedirect(true); return handlerAdapter; } } The WebFlowConfig class encapsulates the Spring Web Flow infrastructure bean definitions. To align these beans with Spring MVC, the mvcConfig bean was injected, so formatter, validators, and view resolvers could be accessed and set to use during flow executions. This class extends the Spring specialized AbstractFlowConfiguration class, which does not provide any configuration itself but provides access via protected methods to builders for flow executor (getFlowExecutorBuilder()), flow registry (getFlowDefinitionRegistryBuilder()), and flow builder services (getFlowBuilderServicesBuilder()). 268 Chapter 7 ■ Spring Web FloW ... import org.springframework.webflow.config.AbstractFlowConfiguration; import org.springframework.webflow.definition.registry.FlowDefinitionRegistry; import org.springframework.webflow.engine.builder.support.FlowBuilderServices; import org.springframework.webflow.executor.FlowExecutor; import org.springframework.webflow.mvc.builder.MvcViewFactoryCreator; @Configuration public class WebFlowConfig extends AbstractFlowConfiguration { @Autowired private MvcConfig mvcConfig; @Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()) // apply the listener for all flow definitions .addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\") .build(); } @Bean public FlowDefinitionRegistry flowRegistry() { return getFlowDefinitionRegistryBuilder(flowBuilderServices()) .setBasePath(\"/WEB-INF\") .addFlowLocationPattern(\"/**/*-flow.xml\") .build(); } @Bean public FlowBuilderServices flowBuilderServices() { return getFlowBuilderServicesBuilder() .setViewFactoryCreator(mvcViewFactoryCreator()) .setValidator(this.mvcConfig.validator()) .setConversionService(conversionService()) .setDevelopmentMode(true) .build(); } @Bean public MvcViewFactoryCreator mvcViewFactoryCreator() { MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator(); factoryCreator.setViewResolvers(Arrays.<ViewResolver>asList( this.mvcConfig.tilesViewResolver())); factoryCreator.setUseSpringBeanBinding(true); return factoryCreator; } 269 Chapter 7 ■ Spring Web FloW @Bean DefaultConversionService conversionService() { return new DefaultConversionService( conversionServiceFactoryBean().getObject()); } @Bean FormattingConversionServiceFactoryBean conversionServiceFactoryBean() { FormattingConversionServiceFactoryBean fcs = new FormattingConversionServiceFactoryBean(); Set<Formatter> fmts = new HashSet<>(); fmts.add(this.mvcConfig.dateFormatter()); fmts.add(this.mvcConfig.hospitalFormatter()); fcs.setFormatters(fmts); return fcs; } } ■ ! to tune the flow execution persistence settings in Java, the following configuration has to be present in the WebFlowConfig class: @Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()) .addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\") .setMaxFlowExecutions(5) .setMaxFlowExecutionSnapshots(30) .build(); } • The WebInitializer class provides the Servlet 3.0 configuration that replaces the web.xml file. The configuration classes are added to the array of configuration classes used to create the application context by providing the proper implementation for the getRootConfigClasses. public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?",
    "answer": "> getRootConfigClasses() { return null; } @Override protected Class<?> getServletConfigClasses() { return new Class<?>{ MvcConfig.class, WebFlowConfig.class }; } 270",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "View state: In this type of state, the execution of a flow is paused to render a view to the user and wait for input data. It is defined using the <view-state ../> XML element. • Action state: In this type of state, Java code is executed, and sometimes the next state to transition to depends on the outcome of this code. It is defined using the <action- state ../> XML element. • Decision state: In this type of state, some branch logic is implemented using the XML flow definition language. It is defined using the <decision-state ../> XML element. • Subflow state: The execution is transferred to another flow. When the subflow execution is completed, the execution will return to this state. It is defined using the <decision-state ../> XML element. • End state: The final state of the flow execution. It is not mandatory for this state to render a view, but usually a confirmation view is rendered to the user. It is defined using the <end-state ../> XML element. The states will be referred to using the XML element names in order to faciltate association between the state type and the element used to configure it. The switch from one state to the other is called a transition and it is triggered by events. Some data can be shared among states, depending on the scope of that data. The simple schema of a flow definition and composing elements is depicted in Figure 7-7. The data is the information that is carried from one state to the other; it has a life span that depends on the scope on which it was declared. 272 Chapter 7 ■ Spring Web FloW Figure 7-7. The general schema of a flow definition and composing elements Flow Definition A flow is defined in a single XML file, and all the states composing it are defined as child elements of the flow element. The content of the flow element is actually a task algorithm. All resources used by a flow (views, internationalization files) when being executed must be placed in the same directory as the flow definition file. Basically, each flow defined in an application has its own directory that contains all flow definition resources. This was mentioned in the “Spring Web Flow Architecture” section. In this section, all the necessary steps in defining a flow are covered in detail. For example, to develop the /persons/newPerson flow, the following has to be created (use Figure 7-8 or reference ). Figure 7-8. The components of a flow definition 273 Chapter 7 ■ Spring Web FloW • A directory with the same name as the flow you are trying to create, so as the path inside the WEB-INF matches the URL path that you want to map the flow to • message.properties internationalization files • View files • A tiles configuration file, if tiles are used • A *-flow.xml spring configuration flow definition file When developing a flow, it is recommended to think and design the flow logic first—define the states and transitions, review the flow with business analysts, use mock views (plain HTML files that replace the view in testing scenarios)—to depict the steps and then add the behavior. To define the states of a flow, the *-flow.xml file must be populated. Usually, the first step is a view-state that displays a view to the user to provide data to the flow. <!-- newPerson-flow.xml --> <?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <view-state id=\"enterPersonInfo\"/> </flow> The view-state id resolves to a view template; by default, a *.jsp file is searched for in the current directory. View resolution is pluggable, depending on the view technology used. In the examples given in this book, Apache Tiles are used to define and resolve views; so the view to display when entering the enterPersonInfo state is defined in the tiles.xml under the flow directory. The views used for the workflows extend the same tiles template, webapp/WEB-INF/standard/layout.jsp, defined for views in",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "servletRelative: Redirects to a resource relative to the current server • contextRelative: Redirects to a resource relative to the current web application context path • serverRelative: Redirects to a resource relative to the server root • http:// or https:// Redirects to a fully qualified resource URI 3The GOTO statement (see https://en.wikipedia.org/wiki/Goto). 276 Chapter 7 ■ Spring Web FloW These redirect prefixes are supported in a flow definition together with the externalRedirect: directive in view-state or end-state elements. The view-state element has a view property that can be used to specify a different view than the one with the same state id, and this view can be outside the newPerson flow directory: <flow ...> <view-state id=\"reviewPerson\" view=\"externalRedirect:contextRelative:/verifyPerson\"> <transition on=\"confirm\" to=\"enterIdentityCard\"/> </view-state> </flow> A flow can also redirect to a different flow by using the flowRedirect: directive in its end state; this basically means the current flow ends and a new one is started. In conclusion, when creating a web flow, it is recommended that the following steps be followed in this order: 1. Define view states and end states. 2. Define transition between states. 3. Create mock views to test the connection of the states. 4. Add the intended behavior. To create a web flow like the one shown in Figure 7-1, the following must be done: • When defining view states and end states, the focus is on the steps that the user is guided through. The why (conditions and events) and how (business logic) is left for later. <flow ...> <!-- newPerson-flow.xml --> <view-state id=\"enterPersonInfo\" /> <view-state id=\"enterHospitalInfo\" /> <view-state id=\"enterIdentityCard\" /> <view-state id=\"reviewPersonData\" /> <view-state id=\"enterAccountInfo\" /> <view-state id=\"reviewAccountData\" /> <end-state id=\"end\" /> </flow> • Then transitions should be defined as follows: <!-- newPerson-flow.xml --> <flow ...> <view-state id=\"enterPersonInfo\" > <transition on=\"addHospital\" to=\"enterHospitalInfo\" /> <transition on=\"proceed\" to=\"enterIdentityCard\" /> </view-state> <view-state id=\"enterHospitalInfo\" > <transition on=\"save\" to=\"enterPersonInfo\" /> </view-state> 277 Chapter 7 ■ Spring Web FloW <view-state id=\"enterIdentityCard\" > <transition on=\"review\" to=\"reviewPersonData\" /> </view-state> <view-state id=\"reviewPersonData\" > <transition on=\"addAcount\" to=\"enterAccountInfo\" /> </view-state> <view-state id=\"enterAccountInfo\" > <transition on=\"review\" to=\"reviewAccountData\" /> </view-state> <view-state id=\"reviewAccountData\" > <transition on=\"save\" to=\"end\" /> <view-state> <end-state id=\"end\" /> </flow> • To test the connections between the states, mock views should be created. This is an approach that helps users interact with the flow process to test the transitions between the states. Mock views contain static data; no extra data needs to be inserted by the user and no validation is performed. The dynamic behavior is added later, when the back end of the application is developed. <!-- newPersonInfo.jsp --> <h2> Mock New Person </h2> <div class=\"person\"> <form id=\"newPersonForm\" method=\"POST\" > <table> <tr> <th> First Name </th> <td><input path=\"firstName\"/></td> </tr> <!-- other form elements --> ... <tr> <td colspan=\"2\"> <button id=\"newPersonButton\" name=\" eventId proceed\" type=\"submit\"> Proceed </button> </td> </tr> </table> </form> </div> 278 Chapter 7 ■ Spring Web FloW <!-- enterIdentityCard.jsp --> <h2> Mock New Account </h2> <div class=\"identityCard\"> <form id=\"newIdentityCardForm\" method=\"POST\" > <table> <tr> <th> Account Number </th> <td><input path=\"accountNumber\"/></td> </tr> <!-- other form elements --> ... <tr> <td colspan=\"2\"> <button id=\"newAccountButton\" name=\"_eventId_review\" type=\"submit\"> Review </button> </td> </tr> </table> </form> </div> <!-- other mock views look similar so their content will not be listed here --> ■ ! as you probably noticed in the previous example, only view and end states were used. this is because these are the simplest states that can be used to create a flow; also, defining them is very easy and intuitive. the other types of states (action, decision, and subflow) are covered later and added, one by one, to the flow you have become familiar with to allow you to gradually increase your understanding of Spring Web Flow. Testing Web Flows Every flow in an application should have a unit test to verify that the flow logic works as expected. The Spring Web Flow provides a test class at org.springframework.webflow.test.execution. AbstractXmlFlowExecutionTests that has to be extended to use unit tests to test flows. This class provides the test infrastructure needed to test that a flow definition executes as expected; no Spring or JUnit annotations are needed. All that is needed is for the getResource(FlowDefinitionResourceFactory resourceFactory) method to be implemented correctly is to provide the test a flow definition file. 279 Chapter 7 ■ Spring Web FloW import org.springframework.webflow.config.FlowDefinitionResource; import org.springframework.webflow.config.FlowDefinitionResourceFactory; import org.springframework.webflow.test.MockExternalContext; import org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests; public class NewPersonFlowTest extends AbstractXmlFlowExecutionTests { private static final String ENTER_PERSON_INFO = \"enterPersonInfo\"; private static final String ENTER_IDENTITY_CARD = \"enterIdentityCard\"; private static final String REVIEW_ACCOUNT_DATA = \"reviewAccountData\"; private static final String END = \"end\"; @Override protected FlowDefinitionResource getResource (FlowDefinitionResourceFactory resourceFactory) { return resourceFactory.createFileResource( \"src/main/webapp/WEB-INF/persons/newPerson/newPerson-flow.xml\"); } public void testStart() throws Exception { startFlow(new MockExternalContext()); assertCurrentStateEquals(ENTER_PERSON_INFO); } public void testEnterPersonInfoProceed() throws Exception { setCurrentState(ENTER_PERSON_INFO); MockExternalContext externalContext = new MockExternalContext(); externalContext.setEventId(\"proceed\"); resumeFlow(externalContext); assertCurrentStateEquals(ENTER_IDENTITY_CARD); } // other similar transition tests .. public void testReviewPersonConfirm() throws Exception { setCurrentState(REVIEW_ACCOUNT_DATA); MockExternalContext externalContext = new MockExternalContext(); externalContext.setEventId(\"save\"); resumeFlow(externalContext); assertFlowExecutionEnded(); assertFlowExecutionOutcomeEquals(END); assertTrue(externalContext.getExternalRedirectRequested()); assertEquals(\"contextRelative:/persons/1\", externalContext.getExternalRedirectUrl()); } } The testStart method starts the flow by calling startFlow and tests that the flow has entered the start state by calling assertCurrentStateEquals. 280 Chapter 7 ■ Spring Web FloW The testEnterPersonInfoProceed tests that starting from an exact state when an event is triggered, the transition is done to the expected state. Triggering the event is done by using a mock context and calling setEventId on it. ■ ! before continuing to the next section, take a look at the 10-pr-webflow-fundamentals-practice module under the person-manger project. all the files necessary for creating a very simple flow have been provided for you. Figure 7-9 depicts the simplified version of the newPerson flow that is required to complete the practice example. it uses mock views and only view states; no business logic is required to complete this practice exercise. the purpose of this module is to help you test your understanding of defining states and transitions, and using mock flows and testing the simple flow you have created. Figure 7-9. Link to the simplified New Person flow this flow guides the user through the process of creating a person using the minimum amount of information. the first step of this flow should display a form to the user. after submitting the form, the user should be taken to a screen where he can review the information before being confirmed. after confirming, the user should be taken to the screen displaying the details of the completed transaction. the practice module has ten toDo tasks to be resolved, numbered from 40 to 49. each task has a short description instructing you on what you have to do. the web application can be started by executing the appStart gradle task. the newPerson flow definition has been completed and the execution works completely if the user can be guided through all the expected steps. the test has been implemented correctly if all the methods pass. When executing the flow, and the current state is the reviewPersonData. try clicking the back button of the browser to see what happens. You should be able to go back and resubmit. no browser warnings should occur, and the request Url should depict that you are back to the previous step of the same flow execution. if the current Url were http://localhost:8080/persons/newPerson?",
    "answer": "execution=e1s2, clicking the back button should redirect the user to http://localhost:8080/persons/newPerson?execution=e1s1. try the same after the flow has finished its execution and note the parameters in the request Url. the flow execution should be restarted and the execution Url parameter should have the expected value. ■ ? Can you remember how the execution parameter value should change when a new flow execution is started? 281",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Flow scope: This is the scope that lasts until the flow ends. • View scope: This is the scope associated with each view-state. • Request scope: This is the scope matching a single request • Flash scope: This the scope allocated when a flow starts; it is cleaned automatically after each view is rendered and destroyed when the flow ends. • Conversation scope: This is a global execution scope; all subflows share this scope. It gets allocated when a top-level flow starts and it is destroyed when the top-level flow ends. ■ ! the conversation-scoped objects are stored in the http session and should generally be serializable to account for typical session replication. 282 Chapter 7 ■ Spring Web FloW Flow Variables The scope of a variable can be determined contextually. For example, when the explicit definition of a variable is directly under the <flow/> element, the scope for that variable is the flow scope. When the explicit definition of a variable is under the <view-state/> element, the scope of that variable is view scope. But when using EL expressions and Java code, the scope needs to be specified explicitly. When using <var/> to define variables, you have to keep in mind that if the objects are complex and require other properties to be injected, they must either have a constructor, setters annotated with @Autowired, or both depending on the chosen configuration. <!-- newPerson-flow.xml --> <flow ...> <var name=\"identityCardProcessor\" class=\"com.pr.webflow.IdentityCardProcessor\"/> ... </flow> // com.pr.webflow.IdentityCardProcessor.java public class IdentityCardProcessor implements Serializable { private IdentityCardManager identityCardManager; @Autowired public IdentityCardProcessor( IdentityCardManager identityCardManager){...} } // or public class IdentityCardProcessor implements Serializable { private IdentityCardManager identityCardManager @Autowired public void setIdentityCardManager( IdentityCardManager identityCardManager){...} } Explicit variables are most often used as data models for views. They are used to pass as arguments to business services invoked by the flow; such an implementation is depicted in Figure 7-10. Figure 7-10. Explicit flow variable usages example 283 Chapter 7 ■ Spring Web FloW ■ ?",
    "answer": "From what has been covered so far, can you tell to which scope the person variable in the previous code sample belongs? Explicit variables can be defined as view-scoped objects too. In this case, the variable is created when the view-state is entered and is destroyed when the transition to the next view-state occurs. They can be used as data models for a single view. They are often updated using AJAX requests before being used for the expression conditioning the transition to the next state; such an implementation is depicted in Figure 7-11. Figure 7-11. Explicit flow variable in view scope usages example In the previous examples, you can see that performing the transition depends on the result of the evaluation of the expression in the <evaluate /> element. The expression in that element is a standard EL expression that can be evaluated directly by the EL; it does not need to be enclosed in delimiters such as #{ }. The delimiters are not needed when the expression is a string that represents a method call or property access, and using them will throw an IllegalArgumentException. The delimiters are only needed when the argument string is a template EL expression that implies mixing literal text with one or more standard expressions, as in the redirect link for the end state in previous examples. <flow ...> <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/#{person.id}\" /> </flow> Conversation Variables The conversation scope is the widest web flow scope. Variables defined within this scope are available to subflows too. The conversation variables are similar to global variables and have the same disadvantages. Conversation variables introduce a dependency between top-level flows and their subflows; that’s why the recommendation is to not use them if a different option exists. When working with subflows, input/output parameters can be used to avoid conversation variables. A variable can be assigned to the conversation scope using the <evaluate /> element. 284",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The first request lasts between the transition from the current state until entering the next state. • The second lasts from the moment before the view is rendered to the end of rendering the same state. You can consider the flash scope as an extension of the request scope in the Web Flow context, because the request scope is not quite useful when using web flow, as is explained later in this section. Attributes placed in request scope exist for the life of the current request into the flow execution. When the request ends, any attributes in request scope goes out of scope. Variables should be assigned the request scope when their values are refetched every time a state is redisplayed. If the data can be cached, the view scope would be more appropriate for the variable. ■ ! the request scope can be useful when creating a sports betting site. the application should have a web flow defined, through which the user can place a bet. a request variable should be used to extract the most recent results of games being played, so the user can be informed in real time of his winning chances. Also, data with request scope can be used in cases where it is needed only to initialize the next view; but it should not be displayed by it. ■ ! Consider the example of a betting site: only the list of games currently being played should be displayed, so a specific time interval value can be stored in a variable and used as criteria for selection. To implement the previously mentioned cases, the flow scope can be used, and the games the user can bet on can be retrieved using AJAX calls. Request scope is pretty useless, considering that usually a developer is interested in sharing the data between the two requests implied by a web flow state. 285 Chapter 7 ■ Spring Web FloW Figure 7-12 is a simple diagram with the duration of the flash scope and the request scope depicted to make their differences in the context of a flow execution more obvious. Figure 7-12. Comparison between request and flash scope In Figure 7-12, you can clearly see the two requests implied by a flow state. One of them is the user request to start the flow with URL /person/newPerson. Accessing this URL makes the web flow engine send a request to /persons/newPerson?",
    "answer": "execution=e1s1. The request to this web flow resource is the second request. The two arrows under the REQUEST bubble show exactly how long the attributes in the request scope is available. And under the FLASH bubble, you can see the longer arrow, which depicts how long the attributes in the flash scope are available. The execution points— :on-entry, on-render, and so forth—are covered in the next section. Actions Now that web flow scopes have been covered, it is time to introduce actions. Actions execute behavior at specific points within the flow. There are several points where you can execute actions:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "on flow start: The <evaluate /> element is declared as a child of the <on-start /> element that marks the start of a flow execution. This action is executed only once, when the flow execution starts. <flow ...> <on-start> <evaluate expression=\"...\"/> </on-start> </flow> 286 Chapter 7 ■ Spring Web FloW • on state entry: The <evaluate /> element is declared as a child of the <on-entry /> element that marks the entry in a state. (A view state in the following example). This action is executed only once, when entering the state. <flow ...> <view-state ...> <on-entry> <evaluate expression=\"...\"/> </on-entry> </view-state> </flow> • on view render: The <evaluate /> element is declared as a child of the <on-render /> element that marks the moment immediately before a view is rendered. The action is executed on every browser refresh. <flow ...> <view-state ...> <on-render> <evaluate expression=\"...\"/> </on-render> </view-state> </flow> • on transition execution: The <evaluate /> element is declared as a child of the <transition /> element. Actions imply evaluating expressions and the results are assigned to variables that have a specific scope assigned. The <evaluate /> action element used in the following example can be used to evaluate an expression and assign the result a specific scope. It can prevent a transition if an exception is thrown or false is returned as a result when the expression is evaluated. How exceptions are handled in the web flow context is covered later in the chapter. Only one <evaluate /> expression is allowed. <flow ...> <view-state ...> <transition on=\"confirm\" to=\"nextStep\"> <evaluate expression=\"...\"/> </transition> </view-state> </flow> • on state exit: The <evaluate /> element is declared as a child of the <on-exit/> element that marks the exit of a state. (A view state in the following example). This action is executed only once, when exiting the state. <flow ...> <view-state ...> <on-exit> <evaluate expression=\"...\"/> </on-exit> </view-state> </flow> 287 Chapter 7 ■ Spring Web FloW • on flow end: The <evaluate /> element is declared as a child of the <on-end /> element that marks the end of a flow execution. This action is executed only once, when the flow execution ends. <flow ...> ... <on-end> <evaluate expression=\"...\"/> </on-end> </flow> The examples presented so far were simplified to set the focus on the syntax when defining your actions. The following example is a concrete one that you will use in the practice exercises: <flow ...> <!-- newPerson-flow.xml --> <view-state id=\"enterPersonInfo\"> <on-render> <evaluate expression=\"hospitalManager.findAll()\" result=\"flowScope.hospitalList\" /> </on-render> <transition on=\"proceed\" to=\"reviewPerson\" /> </view-state> </flow> The <evaluate /> element can also be used to resolve properties on beans and even perform conversions. The actions are usually expressed in Spring EL,4 but Unified EL Standard and OGNL are supported too. Using this type of syntax makes the actions more concise for executing behavior and easier to read from a development point of view. A Spring EL expression has the following template: <variable_name>.property_or_method The variable_name is resolved against the current flow context. Variables referring to data scopes (flowScope, viewScope, requestScope, etc.) should only be used when assigning a new variable to one of the scopes. To resolve a flow variable, reserved variables are searched first, then the variable is searched within each flow scope, starting with request and expanding the scope gradually: flash, view, flow, conversation. If the variable is not found, the flow application context is searched for a bean matching the variable name. Let’s look at a few examples to make usage of Spring EL expressions with web flows easier to understand: • flowScope.person: The person variable is resolved in flow scope • person: The person variable is searched in all scopes • hospitalManager.findAll(): The findAll method is called on the hospitalManager variable (in this book’s examples, hospitalManager is actually a bean). • hospitalManager.findByCode(hospitalCode): Calling a bean method and using the hospitalCode variable as an argument. 4See http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions. html#expressions-language-ref. 288 Chapter 7 ■ Spring Web FloW When using Spring EL to write expressions, a few reserved variables can be used without any prior manual initialization (Spring takes care of initializing them). • scope-specific variables: requestScope, flashScope, viewScope, flowScope, conversationScope • environment-specific variables: flowExecutionUrl, flowRequestContext, requestParameters, externalContext, messageContext, resourceBundle, currentEvent, currentUser • externalContext.sessionMap is used to access HTTP session contents. (No sessionScope variable exists in the context of a flow definition.) Some of these variables can be used in view template files also; in JSP, all scope variables are accessible, flowExecutionUrl is the URL of the current page, flowRequestContext is the RequestContext. Additional variables are available: pageScope, requestParameters, sessionScope, and so forth. So far, only the <evaluate /> element has been used, but there are alternatives more suitable in particular cases. The <set /> action element is used to set the value of a variable, but it does not prevent a transition and can be used multiple times within a transition element. For example, if you just want to view the details on a person after it was selected from a list; there is nothing to evaluate, you just want view some data. The <set /> element is more suitable for this case: <flow ...> <!-- reviewPerson-flow.xml --> <view-state id=\"reviewPersonInfo\"> <on-render> <evaluate expression=\"personManager.getByDateOfBirth(dob)\" result=\"viewScope.persons\" result-type=\"dataModel\" /> </on-render> <transition on=\"select\" to=\"viewPerson\"> <set name=\"flowScope.person\" value=\"persons.selectedRow\" /> </transition> </view-state> </flow> When using <set />, a scope must be specified when creating a new variable, as there is no default. In the following example, the firstName variable is assigned to the flowScope scope. <set name=\"flowScope.firstName\" value=\"requestParameters.firstName\"/> When updating an existing variable, or one of its properties, the scope is no longer required and the algorithm presented previously is used to perform scope resolution. <set name=\"person.firstName\" value=\"requestParameters.firstName\"/> 289 Chapter 7 ■ Spring Web FloW Request Parameters In the previous code sample, the requestParameters system variable was used. This variable contains all the URL parameters for the current request. These parameters are not in the requestScope, and if they are needed further in the execution flow, they need to be assigned to a proper scope; otherwise, they will be lost when the current request ends. <view-state id=\"reviewPersonInfo\"> <transition on=\"cancel\" to=\"cancelled\"> <evaluate expression= \"personManager.delete(requestParameters.personId)\"> </transition> </view-state> ■ ?",
    "answer": "to test your understanding, look at the following code snippet: <view-state id=\"practiceInfo\"> <on-entry> <set name=\"flashScope.var1\" value=\"var1\" > <set name=\"requestScope.var2\" value=\"var2\" > <on-entry> <on-render> <set name=\"requestScope.var3\" value=\"var3\" > <set name=\"flashScope.var4\" value=\"var4\" > <set name=\"requestScope.var5\" value=\"var5\" > </on-render> </view-state> try to determine which of the following affirmations is true and which is not, and why.5 1. var2 is available after the view is rendered. 2. var2 can be used to initialize the view, but is lost when the view is rendered. 3. var1, var3, var4, and var5 are available after the view is rendered. 4. var1 is lost if the view is refreshed. 51. False. This variable is defined in the first requestScope and a state has two requests. Rendering the view is done in the second request. 2. True. As explained earlier. 3. True. var1 and var4 are defined in flashScope; var3 and var5 are defined in the scope of the rendering requestScope. 4. True. var1 is lost because it is defined when entering the state, and if the page is reloaded, entering the page is done only once. So when the page is reloaded, the flash scope is cleaned and var1 is lost. 290",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Boolean: Always evaluates to \"yes\" or \"no\". • String: The name of the event to trigger. • Enumerated types: The enumerated values is converted to String using the toString() method. The toString method must be defined in such a way that it returns acceptable values to transition on. Look at the following example; depending on the result of the evaluation of the getDecision(...) method, the transition is done to a different state. //ActionEnum.java public enum ActionEnum { EDIT_ACCOUNT(\"accountEditState\"), DELETE_ACCOUNT(\"accountDeleteState\"), CREATE_ACCOUNT(\"accountCreateState\"); private String value; ActionEnum(String value) { this.value = value; } public String getValue() { return value; } @Override public String toString() { return value; } } //DecisionBean.java @Component public class DecisionBean implements Serializable { public ActionEnum getDecision(int decisionId) { switch (decisionId){ case 0: return ActionEnum.EDIT_ACCOUNT; case 1: return ActionEnum.DELETE_ACCOUNT; case 2: return ActionEnum.CREATE_ACCOUNT; } throw new IllegalArgumentException(\"Option not supported!\"); } } 305 Chapter 7 ■ Spring Web FloW //account-flow.xml <flow...> <action-state id=\"accountDecision\"> <evaluate expression=\"decisionBean.getDecision(requestParameters.decisionId)\" /> <transition on=\"EDIT_ACCOUNT\" to=\"edit\"/> <transition on=\"DELETE_ACCOUNT\" to=\"delete\"/> <transition on=\"CREATE_ACCOUNT\" to=\"create\"/> </action-state> <view-state id=\"edit\" ... > .. </view-state> <view-state id=\"delete\" ... > .. </view-state> < view-state id=\"create\" ... > .. </view-state> </flow> • org.springframework.webflow.execution.Event: The transition will use the id of the event object converted to String. • Any other value that evaluates to \"success\". ■ ! When using an <evaluate /> expression inside a transition, a transition will occur if the result is any of the true(Boolean), “yes”, “true”(String), “success”. enumerated types are converted to a String using its toString() method and the previous rule applies. any other object is treated as “success”. <view-state id=\"enterPersonInfo\" model=\"person\"> ... <transition on=\"proceed\" to=\"enterIdentityCardInfo\" > <evaluate expression=\"personService.isNewPerson(person)\"/> <!-- Must return \"true\", \"yes\", \"success\" or an object--> </transition> </view-state> 306 Chapter 7 ■ Spring Web FloW So far, actions have been used in quite a simple manner and used to invoke methods on existing beans. These actions can be categorized as No action because they are used to invoke business services directly. The concept of “No action” might be confusing. The reason such a category exists is to categorize actions that are not defined by action classes. <!-- newPerson-flow.xml--> <action-state id=\"checkDuplicate\"> <evaluate expression=\"personService.isNewPerson(person)\"/> <transition on=\"success\" to=\"enterIdentityCardInfo\"/> <!-- Transition always occurs --> </action-state> // PersonService.java @Service(\"personService\") public class PersonService { @Autowired PersonManager personManager; public boolean isNewPerson(Person person) { String pnc = PncBuilder.build(person); Person existingPerson = personManager.getByPnc(pnc); return existingPerson == null; } } But when the logic of an action becomes complicated, and even needs access to the flow context, actions can be implemented in different ways. The most simple way is to create a POJO (a bean), pass the flow context as an argument, and then invoke its methods by the flow. These are called the POJO actions. ■ ! to mark poJo actions, developers usually create their own annotation and set it to be component- scanned. in the personal records Manager project, the annotation is called @WebFlowAction. @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface WebFlowAction { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any */ String value() default \"\"; } 307 Chapter 7 ■ Spring Web FloW For Spring to scan for this annotation, you have to add it to the configuration: @Configuration @EnableWebMvc @ComponentScan(basePackages = {\"com.pr, com.pr.persons, com.pr.hospitals, com.pr.validator\"}, includeFilters = @ComponentScan.Filter( value = WebFlowAction.class, type = FilterType.ANNOTATION )) @ImportResource({\"classpath:spring/app-service-config.xml\", \"classpath:spring/db-config.xml\"}) public class MvcConfig extends WebMvcConfigurerAdapter { ... } So, the following code can be written using a POJO action in the following manner: <!-- newPerson-flow.xml--> <action-state id=\"checkDuplicate\"> <evaluate expression= \"personAction.isNewPerson(requestContext)\" /> <transition on=\"success\" to=\"enterIdentityCardInfo\"/> </action-state> //PersonAction.java import com.pr.WebFlowAction; import org.springframework.webflow.execution.RequestContext; @WebFlowAction public class PersonAction { public String isNewPerson(RequestContext context) { Person person = (Person) context.getFlowScope().get(\"person\"); String pnc = PncBuilder.build(person); Person existingPerson = personManager.getByPnc(pnc); if (existingPerson == null) { return \"success\"; } else{ throw new DuplicatePersonException(existingPerson); } } } Notice how the context is declared as a parameter and set as an argument by the developer in the web flow action definition. They way that exceptions are handled in a web flow execution is covered later. 308 Chapter 7 ■ Spring Web FloW Another type of actions are the plain actions. For each action, a class is created that implements the org.springframework.webflow.execution.Action interface or extends the Spring-provided implementation, the org.springframework.webflow.action.AbstractAction class. The implementation provided by Spring provides some methods that can be used to generate events. For example, this class implements the org.springframework.beans.factory.InitializingBean interface (covered in Chapter 2) to receive an init callback when deployed within a Spring bean factory and exposes hooks to execute pre- (doPreExecute (RequestContext context)) and post- (doPostExecute(RequestContext context)) action execution. The Action interface exposes only one method, named execute. Implementations of this interface are usually used to create singleton beans instantiated and managed by a Spring web application context. The request context is no longer declared as an argument in the flow definition, as an action defined this way is handled by Spring, which knows the argument to call the action method with. The advantages of using plain actions is that they can easily be parametrized with mocks and stubs in test environments. Also, action proxies may also be generated at runtime for delegating to POJO business operations that have no dependency on the Spring Web Flow API, which helps with decoupling components inside an application. They can be used to simplify a flow definition when an action is simple enough, because there is no need for a SpEL in the evaluate element or a method call; the name of the action component is enough for Spring to know what to do. package org.springframework.webflow.execution; public interface Action { public Event execute(RequestContext context) throws Exception; } The previous example can be written using a plain action too, and the code will look as follows: <!-- newPerson-flow.xml --> <action-state id=\"checkDuplicate\"> <evaluate expression=\"personAction\" /> <transition on=\"success\" to=\"enterIdentityCardInfo\"/> </action-state> //PersonAction.java import org.springframework.webflow.execution.Action; ... @WebFlowAction public class PersonAction implements Action { @Autowired PersonManager personManager; @Override public Event execute(RequestContext context) throws Exception { Person person = (Person) context.getFlowScope().get(\"person\"); String pnc = PncBuilder.build(person); Person existingPerson = personManager.getByPnc(pnc); if (existingPerson == null) { return new Event(this, \"success\"); } else{ \\\\ how an exception is handled in webflow context is covered \\\\later in the chapter throw new DuplicatePersonException(existingPerson); } } } 309 Chapter 7 ■ Spring Web FloW The context is automatically passed as an argument by Spring. The most complex type of actions are the MultiActions. They are implemented by extending the org. springframework.webflow.action.MultiAction class, an extension of AbstractAction that provides multiple helper methods for returning events. All action methods must have the same signature as the execute method from the previous example; the context is also automatically passed as argument by Spring. • success(), error(), yes(), no() • result(), result(String), error(Exception) The code in the previous example does not differ much when implemented with MultiAction, but it is added here to underline the differences between the two implementations: <!-- newPerson-flow.xml --> <action-state id=\"checkDuplicate\"> <evaluate expression=\"personAction.isNewPerson\" /> <transition on=\"success\" to=\"enterIdentityCardInfo\"/> </action-state> //PersonAction.java import org.springframework.webflow.action.MultiAction; ... @WebFlowAction public class PersonAction extends MultiAction { @Autowired PersonManager personManager; public Event isNewPerson(RequestContext context) throws Exception { Person person = (Person) context.getFlowScope().get(\"person\"); String pnc = PncBuilder.build(person); Person existingPerson = personManager.getByPnc(pnc); if (existingPerson == null) { return success(); } else{ throw new DuplicatePersonException(existingPerson); } } } In the previous examples, the same behavior was implemented using all types of actions, but technically, each type of action implementation is suitable to a certain case. • No action: Easy to use: just plug in a business method call in the web flow definition. The main disadvantage here is the tight coupling between business logic and the flow definition, and the fact that business method calls can make your web flow definition look crowded. It is proper for usage in simple web flows in simple applications. • POJO action: Can be used to glue the flow logic with the business login in a decoupled way and provides a flexible way to solve business layer exceptions; but the disadvantage is that the flow definitions might become more complex. 310 Chapter 7 ■ Spring Web FloW • Plain action: There are not many cases when this should be used, except of course, for explanatory exercises when teaching Spring Web Flow. • MultiAction: Offers all the advantages of a POJO action, and the code for the implementation class might become quite complex. It is recommended to use POJO actions and MultiActions, if possible, while taking into account the complexity of the flow definition vs. the complexity of the action class. For any classes used to implement actions, the RequestContext is needed to obtain access to contextual information about the executing request. A new instance of this object is created every time there is a start, signalEvent(resume flow), or refresh to reconstruct the last viewed selection when the user requests a different response. • getFlowScope(): Returns a map that can be used to get/set flowScope attributes. • getRequestScope(): The same as getFlowScope(), but for the requestScope. • getActiveFlow(), getCurrentState(), getFlowExecutionURL(): Access information about the flow itself; typically used for auditing and debugging applications. • getMessageContext(): This can be used when an exception is thrown during an action execution on order to display an internationalized message regarding the error. • getExternalContext(): Accesses information about the calling context. Decision States The decision state type is an alternative for an action state type; when based on an evaluated expression, there are multiple possibilities of transitioning. As you have seen so far with action-state, the only outcome is the transition to a \"success\" view-state or the reload of the current view-state to display an error message. The decision state allows for branching of the transition process by using a practical if/then/else syntax, which allows an easier transitioning control. Similar to if/then/else statements in Java, the condition returns a Boolean value that determines the next state to go. When more conditions are required, an action state is more suitable. <!-- newPerson-flow.xml --> <decision-state id=\"checkDuplicate\"> <if test=\"personService.isNewPerson(person)\" then=\"enterIdentityCardInfo\" else=\"reviewExistingPerson\"/> </decision-state> A new view-state has been introduced in this example, reviewExistingPerson; it allows the user to inspect the person already in the system to verify that the existing person is the one he tried to insert. A decision state can be used in the final proposed flow to implement in this chapter, which is to check if a person’s age is greater than 18 so that an account can be created; else, end the execution: <!-- newPerson-flow.xml --> <decision-state id=\"checkAdult\"> <if test=\"personService.isAdult(person)\" then=\"enterAccountInfo\" else=\"end\"/> </decision-state> 311 Chapter 7 ■ Spring Web FloW //PersonService.java import java.time.*; ... @Service(\"personService\") public class PersonService { // using Java 8 classes to determine age public boolean isAdult(Person person){ Date input = person.getDateOfBirth(); Instant instant = input.toInstant(); ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault()); LocalDate birthday = zdt.toLocalDate(); long yearsDelta = birthday.until(LocalDate.now(), ChronoUnit.YEARS); return yearsDelta>=18; } } Exception Handling In the previous examples, the DuplicatePersonException exception class was mentioned. This class was introduced to throw an exception when the user tries to add an existing person to the system and to exemplify exception handling in the context of web flows. public class DuplicatePersonException extends RuntimeException { private Person person; public DuplicatePersonException(Person person) { super(\"The person already exists in the system.\"); this.person = person; } public Person getPerson() { return person; } } When exceptions are raised in the context of a flow execution, they can be taken care of in a few ways: • Let the exception propagate and define the web flow in such a way that an exception will cause a transition to an exception view-state. <transition on-exception=\"com.pr.problem.DuplicatePersonException\" to=\"errorEndState\" /> 312 Chapter 7 ■ Spring Web FloW • Handle any exception globally; define a state in which any other state will transition into when an exception is thrown. <flow> ... <global-transitions> <transition on-exception=\"com.pr.problem.DuplicatePersonException\" to=\"errorEndState\" /> </global-transitions> </flow> • Use an <exception-handler bean=\"flowExceptionHandler\"/> element as a child element to any state type. The bean set by the bean attribute of this element is a bean of type org.springframework.webflow.engine.FlowExecutionExceptionHandler. It is recommended to avoid this option, as it can leave the flow in an invalid state when used incorrectly. The most simple way to create a flow executor handler is to extend the TransitionExecutingFlowExecutionExceptionHandler class that extends the previously mentioned interface. The following code snippet is the equivalent of the <global-transition /> element defined previously. import org.springframework.webflow.engine.support. TransitionExecutingFlowExecutionExceptionHandler; public class PersonFlowExceptionHandler extends TransitionExecutingFlowExecutionExceptionHandler { public PersonFlowExceptionHandler() { super.add(DuplicatePersonException.class, \"errorStateId\"); } } • Catch the exception in an Action class and return an error event. //PersonAction.java @WebFlowAction public class PersonAction extends MultiAction { @Autowired PersonManager personManager; public Event isNewPerson(RequestContext context) throws Exception { Person person = (Person) context.getFlowScope().get(\"person\"); String pnc = PncBuilder.build(person); Person existingPerson = personManager.getByPnc(pnc); if (existingPerson == null) { return success(); } else { return error(); } } } 313 Chapter 7 ■ Spring Web FloW ■ ! before continuing further, take a look at the 12-pr-webflow-actions2-practice module project. this project is expected to create a new Person instance, add all the details for it, and also insert a bank account into the system. to do this, all the elements presented until now are used: actions, action-states, decision-states, and also exception handling. the flow in Figure 7-18 requires a Hospital instance to be selected to create a Person instance. but what if the Hospital instance does not already exist in the system and has to be created first?",
    "answer": "adding extra logic to do this will make the definition of the flow complicated and will connect the person and hospital logic. the proper way to do this is to add a subflow with the specific purpose of creating a new hospital instance. Figure 7-18. Add person and account flow definition 314",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "The IBAN7 field is mandatory and is considered to be 10 to 30 characters long, all digits. An exception is thrown if the data introduced by the user does not match this restriction. • The bank field is mandatory and a string representing a bank name is required. • The status field represents the status of the account and is also mandatory. • The amount field is the amount of money being held by the banking account; this field is not mandatory. In the following list, they steps of the execution and resources are presented to you, in the order you have to use them in the newPerson-flow.xml definition: • The enterPersonInfo view-state is the same as in the previous code sample; the initial state of the flow where a form is displayed to the user for basic personal information to be provided. All fields but middleName are mandatory and must be validated; the hospital drop-down list must be populated when the view-state is rendered. The event name that causes the transition to the next step is called next and the next state is called isNewPerson. • The contents of the view-state definition are missing and must be implemented to behave as described previously. (TODO 41) After the implementation is done you should see the view as in Figure 7-19. 7See https://en.wikipedia.org/wiki/International_Bank_Account_Number. 315 Chapter 7 ■ Spring Web FloW Figure 7-19. The enterPersonInfo view • The isNewPerson is a decision state using the result returned by calling the personService.isNewPerson(person) method as a condition. The method is defined in the com.pr.servicePersonService class, and a bean of this type named personService is already defined. If the evaluation returns true, transitioning is done to the enterIdentityCardInfo state, otherwise to the reviewExistingPerson state. To test the transition to the reviewExistingPerson state, insert a person born on October 1, 1935 at General Hospital. The content of this decision-state definition is missing and must be implemented to behave as described earlier. (TODO 42) • The enterIdentityCardInfo is a view state that displays to the user a form requesting identification information: values for the fields in the identityCard object. All information is mandatory. The event to transition to the next state, confirmAdult, is called save. The transition is done after evaluation of the personBuilder.savePersonEntity(person, identityCard) method, and saving the result in flowScope.existingPerson, because this flow variable is later used to create an account. 316 Chapter 7 ■ Spring Web FloW • The content of this view-state definition is missing and must be implemented to behave as described earlier. (TODO 43) After the implementation is done you should see the view as in Figure 7-20. Figure 7-20. The enterIdentityCardInfo view • The reviewExistingPerson is a view-state that displays the basic information of an existing person in the system, with the same personal numerical code as the Person instance that the user is trying to create. The data to populate the view is extracted at rendering time by calling personManager.getByPnc(person.pnc). The personManager id one of the data management beans presented in Chapter 2. It is defined in the 01-pr-service module project. The result of calling this method is saved in the flowScope.existingPerson, because this flow variable is later used to create an account. From this state, the user can transition to the confirmAdult state by using the event named continue. 317 Chapter 7 ■ Spring Web FloW • The content of this view-state definition is missing and must be implemented to behave as described earlier. (TODO 44) After the implementation is done you should see the view as in Figure 7-21. Figure 7-21. The reviewExistingPerson view • The confirmAdult state is an action-state that evaluates the personActions. isAdult expression. The class providing the implementation for this is com. pr.PersonActions; it is a class extending the MultiAction class presented earlier. On success, transition is done to the enterAccountInfo, and on error, transition is done to end, because obviously the Person instance does not represent an adult so a bank account cannot be added for this instance, thus this is where the flow execution ends. (TODO 45) The content of this action-state definition is missing and must be implemented to behave as described earlier. • The enterAccountInfo is a view state that displays a form requesting minimum information for a bank account. The IBAN of the account must be unique in the system. If you want to test the validation for this field, just insert the value US1301101250000000012300695. Using the add event, if the information introduced is valid, a transition is done to the end state that displays the created person and banking information existing for it in the system. 318 Chapter 7 ■ Spring Web FloW • The content of this view-state definition is missing and must be implemented to behave as described earlier. (TODO 46) After the implementation is done you should see the view as in Figure 7-22. Figure 7-22. The enterAccountInfo view • error is a view-state used to display explicit content of the exceptions thrown in the application. It was implemented this way so that while resolving this exercise, you have a practical way to debug your problems, if you have any. In a real production application, the error view is simpler and more user-friendly. • cancel is an end-state that the flow transitions into any time the user presses the Cancel button in any view. • end is an end-state that redirects the user to a view with all the existing data for that person in the system. • The <global-transaction /> element has two transition elements: one for the cancel scenario, when any the flow transitions to cancel, and one for any exception that is being thrown in the flow transition to the error state. • When your implementation is correct and the data you inserted is valid, a new person should be created in the system and a new bank account should be added for it, and after the flow execution, you should be redirected to a view that displays the information, which looks similar to the one shown in Figure 7-23. 319 Chapter 7 ■ Spring Web FloW Figure 7-23. The view that the flow should redirect to after a successful execution IMpOrtaNt OBSerVatIONS the bind=\"false\" attribute is needed, so the form is not validated before transitioning to the cancel state, as validation errors will prevent the transition. <global-transitions> <transition on=\"cancel\" to=\"cancel\" bind=\"false\" /> <transition on-exception=\"java.lang.Exception\" to=\"error\" /> </global-transitions> When using web flows, the exception handling is the most undocumented part of Spring Web Flow. Unless a web flow exception handler is used, or action states that return error events and add the exception object to the flowScope, catching and treating exceptions is very tricky. Developers are basically forced into writing the code. that’s why all web flow exceptions in this project cause a transition to the error view that uses JSp scriptlets to display a very detailed stacktrace that help developers reading this book to easily identify the mistakes in the code and configuration. the exception can be retrieved using the request. as mentioned, this view is only to be used for development purposes; for production, a more user-friendly view implementation should be used. 320 Chapter 7 ■ Spring Web FloW <!-- webapp/WEB-INF/error.jsp --> <div class=\"error\"> <% Exception exception = (Exception) request.getAttribute(\"flowExecutionException\"); Exception cause = (Exception) request.getAttribute(\"rootCauseException\"); %> ... <% exception.printStackTrace(new java.io.PrintWriter(out)); %> ... <% if (cause != null) { %> <h3>Cause: <%=cause.getMessage()%></h3> <p> <% cause.printStackTrace(new java.io.PrintWriter(out)); %> </p> <%} %> </div> in case you insert data that is invalid, you can use the browser back button to go back to the previous state and change the information. to prevent browsing back to a state previous to a transition with the back button, the history attribute of the transaction element can be used: <transition on=\"confirm\" to=\"end\" history=\"discard\"> <!-- or invalidate all previous visited views in the browser history --> <transition on=\"confirm\" to=\"end\" history=\"invalidate\"> the default value for this attribute is preserve, which allows returning to a state before the execution of the transition and the data for the state is still accessible. discard prevents backtracking to the state, meaning that all information related to the state is discarded and using the browser back button results in a 500 http internal server error. invalidate prevents backtracking to the state, as well as any previously entered view-state, and pressing the browser back button has the same effect as the previous case. the proposed solution for this project can be found in the 12-pr-webflow-actions2-solution project. 321 Chapter 7 ■ Spring Web FloW Subflows A subflow is a flow that is being invoked by another flow. It has its own scope and the parent flow execution is suspended while the subflow is being executed. The conversation scope is the only scope that is shared between the parent flow and the subflows, as depicted in Figure 7-7. The subflow must be defined in the application in the same manner as any flow; it has its own views and language resources, because it is essentially a flow. A subflow is launched from a special state in a parent flow called subflow-state. In the following example, the newPerson flow calls the newHospital subflow. <!-- newPerson-flow.xml--> <flow ...> <view-state id=\"enterPersonInfo\" model=\"person\"> <binder>...</binder> <transition on=\"next\" to=\"isNewPerson\" /> <transition on=\"addHospital\" to=\"newHospital\"/> </view-state> <subflow-state id=\"newHospital\" subflow=\"hospitals/newHospital\" > <output name=\"hospital\"/> <transition on=\"saveHospital\" to=\"enterPersonInfo\"> <evaluate expression=\"hospitalManager.save(hospital)\" result=\"flashScope.hospital\" /> <set name=\"flashScope.hospitalMessage\" value=\"hospital.msg.success\" /> </transition> <transition on=\"cancel\" to=\"enterPersonInfo\" /> </subflow-state> </flow> The subflow in the previous example allows the user to insert a new Hospital instance in the system so that it can be used when the person is created, if the state transitioning into is saveHospital. The id of the subflow-state is the id of this state inside the newPerson flow definition. The subflow attribute is used to link this flow invocation with the flow definition, and contains the path inside the WEB-INF, where the flow definition and resources can be found. In the previous case, the flow definition file is located at /WEB-INF/ hospitals/newHospital/newHospital-flow.xml. Once registered with the FlowDefinitionRegistry, the subflow can be referred from any flow using its logical name, which is composed of the location and the flow name as a value for the subflow attribute: \\\\WebFlowConfig.java @Configuration public class WebFlowConfig extends AbstractFlowConfiguration { ... @Bean public FlowDefinitionRegistry flowRegistry() { return getFlowDefinitionRegistryBuilder(flowBuilderServices()) .setBasePath(\"/WEB-INF\") .addFlowLocation(\"/persons/newPerson/newPerson-flow.xml\") .addFlowLocation(\"/hospitals/newHospital/newHospital-flow.xml\") .build(); } } 322 Chapter 7 ■ Spring Web FloW <subflow-state id=\"newHospital\" subflow=\"hospitals/newHospital\" > <!-- hospitals = directory for Hospital specific resources --> <!-- newHospital = flow name--> The key values used for transitions inside the parent flow are the ids of end-states in the subflow: <!-- newHospital-flow.xml--> <flow ..> <var name=\"hospital\" class=\"com.pr.ents.Hospital\"/> <view-state id=\"enterHospitalInfo\" model=\"hospital\"> <binder> <binding property=\"name\" required=\"true\"/> <binding property=\"code\" required=\"true\"/> <binding property=\"address\"/> <binding property=\"location\" required=\"true\"/> </binder> <transition on=\"save\" to=\"saveHospital\"/> <transition on=\"cancel\" to=\"cancel\" bind=\"false\" /> </view-state> <end-state id=\"saveHospital\"> <output name=\"hospital\" value=\"hospital\"/> </end-state> <end-state id=\"cancel\"/> </flow> The flashScope.hospitalMessage variable is used to display a message telling the user that the Hospital instance was saved correctly and can be used. Although the conversation scope is accessible to the parent flow and subflows, global variables usage is discouraged, because it reduces the readability of the code, so that passing parameters between the parent flow and the subflow is more appropriate. The <output name=\"hospital\"/> is an output parameter designed to return the Hospital instance created by the newHospital flow to the parent flow; it is assigned the flashScope (see the evaluate element marked with (1) in the following code snippet). There are also input parameters, required or not, to provide a parent flow variable value to the subflow. In the previous case, there is nothing needed, but assuming that you would need to send a Person instance as a manager for the hospital we are trying to create, the preceding definitions will change a little. The instance given as parameter has the flowScope in both of the flows because it is defined right under the <flow /> element. 323 Chapter 7 ■ Spring Web FloW <!-- newPerson-flow.xml--> <flow ...> <var name=\"person\" class=\"com.pr.ents.Person\"/> <view-state id=\"enterPersonInfo\" model=\"person\"> <binder>...</binder> <transition on=\"next\" to=\"isNewPerson\" /> <transition on=\"addHospital\" to=\"newHospital\"/> </view-state> <subflow-state id=\"newHospital\" subflow=\"hospitals/newHospital\" > <input name=\"manager\" value=\"person\"/> <output name=\"hospital\"/> <transition on=\"saveHospital\" to=\"enterPersonInfo\"> (1) <evaluate expression=\"hospitalManager.save(hospital)\" result=\"flashScope.hospital\" /> <set name=\"flashScope.hospitalMessage\" value=\"hospital.msg.success\" /> </transition> <transition on=\"cancel\" to=\"enterPersonInfo\" /> </subflow-state> </flow> <!-- newHospital-flow.xml--> <flow ...> <input name=\"manager\" required=\"true\"/> <var name=\"hospital\" class=\"com.pr.ents.Hospital\"/> <view-state id=\"enterHospitalInfo\" model=\"hospital\"> ... </view-state> </flow> When subflows are involved, unit testing is quite tricky; that’s why it is recommended to mock or stub them when the focus of the testing is on the parent flow. By overriding the configureFlowBuilderContext method from AbstractXmlFlowExecutionTests, a mock definition for the subflow can be added to the context: import org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests; public class NewPersonFlowTest extends AbstractXmlFlowExecutionTests { ... @Override protected void configureFlowBuilderContext (MockFlowBuilderContext builderContext) { 324 Chapter 7 ■ Spring Web FloW // setup newHospital subflow Flow newHospital = new Flow(\"newHospital\"); State start = new State(newHospital, \"newHospital\") { @Override protected void doEnter(RequestControlContext context) throws FlowExecutionException { // empty } }; newHospital.setStartState(start); builderContext.registerSubflow(newHospital); } ... } Unfortunately, even as this book is being written, testing subflows is still cumbersome and there are a lot of bugs opened and unresolved.8 When the scope is to test the subflows too, the getModelResources method of AbstractXmlFlowExecutionTests must be overridden. Add the subflow definition to the flow resources being tested: import org.springframework.webflow.engine.Flow; import org.springframework.webflow.test.MockExternalContext; import org.springframework.webflow.test.MockFlowBuilderContext; import org.springframework.webflow.test.execution.AbstractXmlFlowExecutionTests; public class NewPersonFlowTest extends AbstractXmlFlowExecutionTests { ... @Override protected FlowDefinitionResource getModelResources(FlowDefinitionResourceFactory resourceFactory) { FlowDefinitionResource flowDefinitionResources = new FlowDefinitionResource2; flowDefinitionResources0 = resourceFactory.createResource (\"src/main/webapp/WEB-INF/persons/newPerson/newPerson-flow.xml\"); flowDefinitionResources1 = resourceFactory.createResource (\"src/main/webapp/WEB-INF/hospitals/newHospital/newHospital-flow.xml\"); return flowDefinitionResources; } ... } 8A bug related to mocking subflows; still open and unresolved since version 2.0.6. See https://jira.spring.io/browse/SWF-1079. 325 Chapter 7 ■ Spring Web FloW ■ ! Considering that the subflows are not a topic for the exam, there is no practice project with configurations missing, but a project was created that you can run and inspect to see the subflow to add a Hospital instance running: 13-pr-webflow-subflow-solution. ■ ?",
    "answer": "as a proposed exercise, if you want to test your understanding of subflows, you can try to turn the creating of an Account instance into a subflow. Flow Definition Inheritance Flow definitions can be organized in hierarchies in a way similar way to bean definitions. Organizing them in hierarchies allows global transitions, common states, and actions to be shared among parent and children flows. The child flow and the parent flow are both registered in the same flow registry. There are a few things regarding flow definition inheritance that are interesting and worth covering. One of them is that multiple inheritance is supported, because inheritance between web flow definitions is more like a composition; basically, a child flow definition inherits all configuration elements form its parents, and elements with the same id are merged. Multiple parents are specified using comma as a separator: <flow ... parent=\"parentFlow1, parentFlow2\" /> ... </flow> Parent flow definitions can also be abstract. In this case, these flows cannot be instantiated and executed; their purpose in the code is to wrap up common definition elements for multiple child flow definitions, to respect the DRY principle.9 <flow ... abstract=\"true\" /> ... </flow> Flow inheritance is analogous to bean definition inheritance. It is more a composition than inheritance, as parent and child are merged together to create a new flow. Another interesting thing is that flow definition inheritance can be selective, meaning there is a way that only certain state definitions can be inherited, instead of the whole parent flow definition: <flow ... parent=\"parentFlowName\"/> <view-state id=\"childState\" parent=\"parentFlowName#stateId\"> </flow> The restriction here is that the child flow can inherit only from one parent when restrictions are defined at the state level. Also, the child state definition type must be one and the same with the parent state definition. In the preceding example, the state element with stateId must be of type view-state in the parent too; otherwise, the web flow configuration is invalid. 9Don’t Repeat Yourself. 326",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Authentication (user identification) and authorization (managing access to resources); comprehensible and extensible support is provided. • It is easy to configure. • It is highly customizable. • Protection against session fixation, clickjacking, cross-site request forgery, and other type of attacks is provided via simple and flexible configurations. • It can be integrated with the Servlet API. Of course, there are more. You can read more about them on the official page of this project.10 There are five security concepts that you have to familiarize yourself with and understand to use Spring Security: • Credentials are identification keys that an entity presents to the application to confirm their identity( a password or a token). • Principal represents an authenticated entity that was recognized by the application based on its credentials. • Authentication is the process that determines if the credentials of an entity are valid. • Authorization is the process that determines if a principal is allowed access to a resource or performs a certain action. The decision process is often based on roles. The following are the most common roles: • GUEST, usually can just view data • MEMBER (or USER), can insert data • ADMIN, can insert and delete data • Secured item is a resource that is being secured. 10Spring Security page at http://spring.io/spring-security. 327 Chapter 7 ■ Spring Web FloW The Spring Security version used in the book is 4.0.2.RELEASE and it is compatible with Spring 4. In the Gradle configuration of the 14-pr-web-security-practice module project, notice that the following libraries have been added: springSecurityVersion = '4.0.2.RELEASE' ... securityConfig : \"org.springframework.security:spring-security-config: $springSecurityVersion\", securityWeb : \"org.springframework.security:spring-security-web: $springSecurityVersion\", securityTaglibs: \"org.springframework.security:spring-security-taglibs: $springSecurityVersion\", ... } Why Spring Security Is Awesome The spring-security-config module provides security namespace parsing code and is needed when using XML configuration. As some developers still prefer to use XML configuration, the minimum configuration needed in XML is explained in the book alongside the Java Configuration. The spring-security-web provides filters and related web-security infrastructure beans. This library is needed for web-based authentication. The spring-security-taglibs provides security tags that can be used to secure elements in JSP pages. The main reason why Spring Security is preferred when developing web applications is portability. Spring Security does not need a special container to run in; it can be deployed as a secured archive (WAR or EAR) and can run in stand-alone environments. For example, a secured web application archived as a WAR can be deployed on a JBoss or an Apache Tomcat application server. And as long as the underlying method of storing credentials is configured, the application will run exactly the same in any of these application servers. When it comes to authentication and credential storage, Spring Security is very flexible. All common authentication mechanisms are supported (Basic, Form, OAuth, X.509, cookies, single sign-on). Regarding support storage for credentials databases, Spring Security supports anything—LDAP, properties file, custom DAOs, and even beans, among many others.11 Configuring Spring Security is easy. A common practice is to define a separate file when using XML and a separate configuration class when using Java Configuration. Infrastructure beans can be used to customize the following: • How a principal is defined • Where authentication information is stored • How authorization decisions are made • Where security constraints are stored As we have seen so far when using Spring, anything can be done by keeping components as decoupled as possible. Spring Security respects the principle of separation of concerns (SoC). Restrictions are applied using an interceptor-based approach. It was mentioned at the beginning of the book that AOP is used when securing resources. Also, authentication and authorization are decoupled; changing the authentication method and credentials support does not affect authorization. 11A full list of authentication technologies that Spring Security integrates with; it can be found at http://docs. spring.io/spring-security/site/docs/current/reference/htmlsingle/#what-is-acegi-security. 328 Chapter 7 ■ Spring Web FloW Spring Security is consistent. The authentication purpose is to create a security context with the principal’s information; it does not depend on the mechanism used. The authorization process has the same purpose, regardless of the resource type: consult resource properties, consult the principal’s role, and decide to grant or deny access. The way Spring Security works and the core components are depicted in Figure 7-24. Figure 7-24. Spring Security anatomy The following explains the flow described in Figure 7-24: 1. The user makes a login request. (Introduces credentials in a login form and submits it.) 2. The user logs into the application and the Authentication Manager populates the security information of the user into the security context. 3. When the user makes resource requests (requests to view a page, starts a flow, requests a document) after logging in, the security interceptor intercepts them before they invoke a protected/secured resource. 4. The Security Interceptor then retrieves the user information from the context. 5. The Access Decision Manager polls a list of voters to return a decision regarding the rights the authenticated user has on system resources 6. The Spring Interceptor consults the resource attributes that are configured in the application. 7. Access is granted or denied to the resource based on the user rights (5) and the resource attributes (6). 329 Chapter 7 ■ Spring Web FloW Spring Security XML Configuration When using XML to configure Spring Security, any tag can be used by adding the security namespace to the Spring configuration file at http://www.springframework.org/schema/ security/spring-security.xsd. The recommended practice is to have a separate configuration file that contains only the security-related configurations. To log in to the Personal Records Manager application, a separate file should be created, named security-config.xml. This file should define the users and credentials needed to access the application and which resources these users can access: <!-- security-config.xml --> <beans xmlns:sec=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\"> <!-- styling&internationalization resources do not need to be secured --> <sec:http pattern=\"/images/*\" security=\"none\"/> <sec:http pattern=\"/styles/*\" security=\"none\"/> <sec:http pattern=\"/resources/*\" security=\"none\"/> <sec:http auto-config=\"true\"> <sec:intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <sec:intercept-url pattern=\"/persons/newPerson\" access=\"ROLE_ADMIN\"/> <sec:intercept-url pattern=\"/**\" access=\"ROLE_USER, ROLE_ADMIN\"/> <sec:form-login login-page=\"/auth\" authentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <sec:logout logout-url=\"/j_spring_security_logout\" logout-success-url=\"/home /> </sec:http> <sec:authentication-manager> <sec:authentication-provider> <sec:user-service> <sec:user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <sec:user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <sec:user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </sec:user-service> </sec:authentication-provider> </sec:authentication-manager> </beans> 330",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "hasRole('role') checks whether the principal has the given role. • hasAnyRole('role1', 'role2', ?",
    "answer": ") checks whether the principal has any of the given roles.",
    "source": "extracted",
    "confidence": 0.58
  },
  {
    "question": "isAuthenticated() allows access for authenticated or remembered principals. • permitAll allows unauthenticated users access to a resource. In the previous example, this is used to make sure that the login form is accessible so a user can insert his credentials for authentication to take place. • Expressions can be aggregated hasRole('ROLE_ADMIN') and hasRole('ROLE_MANAGER'). 332 Chapter 7 ■ Spring Web FloW The preceding configuration is relative to the beans namespace. Considering that the configuration file contains only security tags, the file could be created relative to the security namespace, and so the sec prefix would not be necessary, which makes the file more readable: <?",
    "answer": "xml version=\"1.0\" encoding=\"UTF-8\"?> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <http pattern=\"/images/*\" security=\"none\"/> <http pattern=\"/styles/*\" security=\"none\"/> <http pattern=\"/resources/*\" security=\"none\"/> <http auto-config=\"true\" use-expressions=\"true\"> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ROLE_ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('ROLE_USER, ROLE_ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> <authentication-manager> <authentication-provider> <user-service> <user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </user-service> </authentication-provider> </authentication-manager> </beans:beans> Spring Security 4 has introduced a few critical changes that need coverage in this book; because by the time this book is published, Spring Security 4 might be a subject on the exam. 333",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "First you must enable CSRF generation in your security-config.xml file by adding a <csrf /> configuration element and a repository to generate the value for it. Modify the logout element appropriately; the third bullet in this list tells you why. <beans:beans .../> <beans:bean id=\"tokenRepo\" class=\"org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository\"> <beans:property name=\"sessionAttributeName\" value=\"_csrf\"/> </beans:bean> <http auto-config=\"true\" use-expressions=\"true\"> <csrf token-repository-ref=\"tokenRepo\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" invalidate-session=\"true\" logout-success-url=\"/\"/> </http> ... </beans:beans>",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Second, you must add a hidden parameter in every form that you are interested in protecting form cross-site request forgery. <form action=\"<c:url value='/login'/>\" method=\"post\"> <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/> <table> <tr> <td> <label for=\"username\"> <spring:message code=\"login.username\"/> </label> </td> <td> <input type='text' id='username' name='username' value='<c:out value=\"${user}\"/>'/> </td> 336 Chapter 7 ■ Spring Web FloW </tr> <tr> <td> <label for=\"password\"> <spring:message code=\"login.password\"/> </label> </td> <td><input type='password' id='password' name='password'/></td> </tr> <tr> <td colspan=\"2\"> <button type=\"submit\"> <spring:message code=\"login.submit\"/> </button> </td> </tr> </table> </form> • And last, logging out becomes a pain when CSRF is enabled, because you need to log out using a POST request. Thus, you cannot just use a link build like this (like in Spring Security 3): <a href=\"<spring:url value=\"/j_spring_security_logout\"/>\"> <spring:message code=\"menu.logout\"/> </a> You need to add a logout form to the page and submit it using JavaScript: <spring:url value=\"/logout\" var=\"logoutUrl\" /> <form action=\"${logoutUrl}\" id=\"logout\" method=\"post\"> <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/> </form> <a href=\"#\" onclick=\"document.getElementById('logout').submit();\"> <spring:message code=\"menu.logout\"/> </a> Also, as we’ve been mentioning logout, you probably noticed the extra attributes of the <logout /> element; their names are quite obvious, and if specified at logout, the specific resources are cleaned accordingly: <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" invalidate-session=\"true\" logout-success-url=\"/\"/> 337 Chapter 7 ■ Spring Web FloW Also, a handler can be used instead of the logout-success-url that takes care of redirecting to the proper page and eventually cleaning up any resources: <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" success-handler-ref=\"logoutSuccessHandler\"/> To view the token Spring Security has generated, you can use Firebug to view the contents of your login request. You should see something similar to what is depicted in Figure 7-25. Figure 7-25. Spring Security CSRF token ■ ! another simplification change that can be done to this file is provided by a new feature introduced in Spring Security 4 that allows access expressions to be specified without the ROLE_ prefix in front of them; thus, the preceding configuration becomes this: <http auto-config=\"true\" use-expressions=\"true\"> <csrf disabled=\"true\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?",
    "answer": "auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> 338",
    "source": "extracted",
    "confidence": 0.99
  },
  {
    "question": "The logout link must be visible only when a user is authenticated; the following is the syntax to do this: <!-- layout.jsp, tiles main template file --> <sec:authorize access=\"isAuthenticated()\"> <li> <!-- we are using Security for with CSRF enabled --> <spring:url value=\"/logout\" var=\"logoutUrl\" /> <form action=\"${logoutUrl}\" id=\"logout\" method=\"post\"> <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/> </form> <a href=\"#\" onclick=\"document.getElementById('logout').submit();\"> <spring:message code=\"menu.logout\"/> </a> </li> </sec:authorize> So basically, the same expressions used when configuring Spring Security are used for the access attribute. • The NewPerson link must be visible only to users with the ADMIN role: <!-- templates/layout.jsp --> <sec:authorize access=\"hasRole('ADMIN')\"> <li> <!--menuTab is a tiles attribute --> <c:if test=\"${menuTab eq 'newPerson'}\"> <strong> <a href=\"<c:url value=\"/persons/newPerson\"/>\"> <spring:message code=\"menu.new.person\"/> </a> </strong> </c:if> <c:if test=\"${menuTab != 'newPersons'}\"> <a href=\"<c:url value=\"/persons/newPerson\"/>\"> <spring:message code=\"menu.new.person\"/> </a> </c:if> </li> </sec:authorize> 346 Chapter 7 ■ Spring Web FloW And another tag was used to display information about the user being logged in: <!-- layout.jsp, tiles main template file --> <div class=\"footer\"> <sec:authorize access=\"isAuthenticated()\"> <p><spring:message code=\"user.loggedin\"/>: <sec:authentication property=\"principal.username\"/> </p> </sec:authorize> <p><spring:message code=\"footer.text\"/></p> </div> Using the Spring Tag library and intercept-url definitions, access to resources can be centralized in the Spring Security configuration file or class, because the access attribute can be replaced with the url attribute that is set with URLs that are intercepted by Spring Security. <!-- layout.jsp, tiles main template file --> <sec:authorize access=\"hasRole('ADMIN')\"> //New Person link </sec:authorize> // can be written as <sec:authorize url=\"/persons/newPerson\"> //New Person link </sec:authorize> Securing Methods Spring Security uses AOP to secure method calls. The Spring Security namespace can be used to configure method security using XML. But the most commonly used and easy-to-understand way to secure methods is through annotations. Spring Security provides its own annotations, but JSR-250 annotations are supported too. Samples for all ways of securing methods are covered. Assuming you want to secure all action methods involved in the newPerson flow, this is how it is done using XML: <!-- security-config.xml --> <security:global-method-security> <security:protect-pointcut expression=\"execution(* com.pr..*Actions.*(..))?",
    "answer": "access=\"hasRole('ROLE_ADMIN')\" /> </security:global-method-security> Of course, method security must be enabled, which can be done by adding the following element in the security configuration file: <!-- security-config.xml --> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" 347",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "It requires a mandatory FlowBuilderServices bean as an argument so it can be instantiated. • It is a container of flow definitions. Question 6: What can you say about the following code snippet?",
    "answer": "<button id=\"newPersonButton\" name=\"_eventId_proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button>",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "two • three • none, because it uses session Question 8: What can be said about the following web flow configuration class?",
    "answer": "@Configuration public class WebFlowConfig { ... }",
    "source": "extracted",
    "confidence": 0.49
  },
  {
    "question": "Each view state has a corresponding view. • Decisions states are more complex view states. 360 Chapter 7 ■ Spring Web FloW Question 15: Consider the following flow definition: <view-state id=\"enterIdentityCardInfo\" model=\"identityCard\"> <binder> ... </binder> <transition on=\"save\" to=\"confirmAdult\"> <evaluate expression=\"personBuilder.savePersonEntity(person, identityCard)\" result=\"flowScope.existingPerson\" /> </transition> </view-state> Which of the following is true?",
    "answer": "enterIdentityCardInfo in this case.",
    "source": "extracted",
    "confidence": 0.35
  },
  {
    "question": "on state entry • on view render • on transition execution • during transition execution • on state exit • on flow end • after flow end Question 26: Which of the following Spring expressions are valid?",
    "answer": "sessionMap.mostUsed)\"result=\"viewScope.hospitals\" />",
    "source": "extracted",
    "confidence": 0.52
  },
  {
    "question": "Boolean, always just “yes” or “no” • Any value that evaluates to “success” • Any String that can be matched to a trigger event name 363 Chapter 7 ■ Spring Web FloW Question 28: Select the way in which a developer can define an action. • Extend the Action class • Extend the MultiAction class • Add call business methods directly in the web flow definition Question 29: What can be said about authentication and authorization?",
    "answer": "changes in the authorization configuration as well.",
    "source": "extracted",
    "confidence": 0.51
  },
  {
    "question": "They are fully decoupled; changing configuration for authentication will not affect authorization. • They are both synonyms for application security. Question 30: What is needed to configure Spring Security with Spring MVC using Java Configuration?",
    "answer": "a class annotated with @Configuration.",
    "source": "extracted",
    "confidence": 0.38
  },
  {
    "question": "Provide a faster, practical, and more accessible way to start development with Spring • Provide a default set of customized infrastructure beans, which can be easily overridden if a specific configuration is required • Provide a large set of features common to large classes of projects (embedded servers, security, metrics, etc.) • Offer the option of dropping any XML configuration or the necessity of generating code When developing web applications, a container is necessary. Usually, an application server or a web server is necessary to run a web application. A web server like Apache HTTP, for example, is dedicated to sending HTML to the client and forwarding requests to application servers. It handles only static resources. An application server, like Apache Tomcat is built around a web server and is dedicated to the efficient execution of program and routines; it supports different types of applications, load balancing, transaction demarcation, and so forth; and it is specifically designed to handle dynamic resources. Apache TomEE is a full-blown Java EE container and an application server based on Apache Tomcat. This type of application server is also called an enterprise server because it is designed to support complex applications like ERPs.1 1Enterprise resource planning (ERP) is business-management software. It is typically a suite of integrated applications (see https://en.wikipedia.org/wiki/Enterprise_resource_planning). 367 Chapter 8 ■ Spring Boot and WeBSoCket The Jetty server was used in the examples in this book. Jetty is an embedded server. Application/web servers are separate applications that you install, start up, maybe customize the configuration, and deploy your artifact on. An embedded server does not need all that. An embedded HTTP server is software that implements the HTTP protocol; it can be embedded into the application that you are developing. It is limited to handling HTTP requests and can be plugged in with the default configuration, or it can be customized. Up until now, the Jetty embedded server was plugged in at runtime by using the Gradle Gretty plugin. Using Spring Boot, this is no longer needed. All that is needed is to configure the spring-boot-starter-jetty as a compile-time dependency for the application. Usage and Configuration A simple sample for this case is the 08-chapter-01-solution project, a module of book-code. If you open the project, you will notice the following: • A new version element was added in the ext element of the Gradle configuration of the build.gradle file (the book-code parent project): springBootVersion = '1.2.7.RELEASE' • In the same file, a new dependencies array named boot was added: boot = [ springBootPlugin: \"org.springframework.boot:spring-boot-gradle-plugin: $springBootVersion\", starterWeb : \"org.springframework.boot:spring-boot-starter-web: $springBootVersion\", starterJetty : \"org.springframework.boot:spring-boot-starter-jetty: $springBootVersion\", actuator : \"org.springframework.boot:spring-boot-starter-actuator: $springBootVersion\", yaml : \"org.yaml:snakeyaml:1.16\" ] • The Gradle configuration file for 08-chapter-01-solution has the following contents: apply plugin: 'spring-boot' buildscript { repositories { mavenCentral() } dependencies { classpath boot.springBootPlugin } } dependencies { compile (boot.starterWeb){ (*)exclude module : \"spring-boot-starter-tomcat\" } compile boot.starterJetty, boot.actuator, boot.yaml testCompile misc.junit } 368 Chapter 8 ■ Spring Boot and WeBSoCket And this is all. The Gradle Gretty plugin, was replaced by the Spring-Boot plugin that is needed for running Spring Boot applications. The default web runtime that Spring Boot uses (Tomcat) was excluded, and spring-boot-starter-jetty was added as a dependency using the variable assigned to the boot.starterJetty library. This is enough to develop and run a simple web application. ■ ! the spring-boot-starter-actuator added using the boot.actuator variable is not really necessary in the examples for the book, but you need to know that this library exists. it should be used when you want to add production-ready features like metrics and monitoring to your application. also, if you look in the log after the application starts, you will see a few lines that look like this: Mapped \"{[/]}\" onto public java.lang.String com.book.web. HelloWorldController.index() Mapped \"{[/error],produces=[text/html]}\" onto public o.s.web.servlet. ModelAndView Mapped \"{[/beans],methods=[GET]}\" onto public java.lang.Object Mapped \"{[/trace],methods=[GET]}\" onto public java.lang.Object Mapped \"{[/metrics/{name:.*}],methods=[GET]}\" onto public java.lang.Object o.s.boot.actuate.endpoint.mvc.MetricsMvcEndpoint.value(java.lang.String) apped \"{[/health]}\" onto public java.lang.Object o.s.boot.actuate.endpoint.mvc.HealthMvcEndpoin t.invoke(java.security.Principal) these are a set of reStful endpoints added to the application to provide access to management services provided by Spring Boot. try accessing http://localhost:8080/metrics or http://localhost:8080/health after the application starts with the default configuration (otherwise, the port and the contextPath might be different) and check out the data returned to you by Spring Boot. the YaML dependency is covered later. The core class of this application is the com.book.Application class: [commandchars=+ package com.book; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; @SpringBootApplication public class Application { public static void main(String args) { ApplicationContext ctx = SpringApplication.run(Application.class, args); assert(ctx!=null); } } 369 Chapter 8 ■ Spring Boot and WeBSoCket If you run this class, you get a web application run on Jetty that is available at http://localhost:8080/. The most important element in this class is the @SpringBootApplication annotation. Spring Boot code is available to the public, and if you look for the annotation code on GitHub, this is what you will find: package org.springframework.boot.autoconfigure; ...// import statements @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Configuration @EnableAutoConfiguration @ComponentScan public @interface SpringBootApplication { /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class<?",
    "answer": "> exclude() default {}; } When placed on a class, this annotation has the following effect:",
    "source": "extracted",
    "confidence": 0.91
  },
  {
    "question": "It indicates that this a configuration class that can be used to instantiate beans via @Bean annotated methods (because this annotation is itself annotated with @Configuration). • It triggers component scanning on the package in which the class is defined (because of the @ComponentScan annotation). • It automatically adds @EnableWebMvc when spring-webmvc is in the classpath. This is ensured by the spring-boot-starter-web being a dependency of this project. This marks the application as a web application, so Spring Boot knows to set up a DispatcherServlet. • The @EnableAutoConfiguration annotation does exactly what the name of the annotation says: it enables the autoconfiguration of a Spring context. So Spring Boot wraps up a configuration by basically guessing which beans are necessary, given the little configuration there is. Autoconfiguration is quite intelligent and if some custom configuration is provided, the provided beans override the default ones that Spring Boot comes with. The scope of this annotation is enriched, starting with Spring Boot 1.3.0, which wasn’t yet released when this book was written, but the code is available on GitHub.2 The preceding main method uses the SpringApplication.run convenient method to launch an application. Thus, no XML was needed anywhere to create this web application. This method returns the created ApplicationContext instance. The created context is autowired into the HelloWorldController, 2View the code at https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/ src/main/java/org/springframework/boot/autoconfigure/SpringBootApplication.java 370 Chapter 8 ■ Spring Boot and WeBSoCket which is a simple REST controller used to display all the beans in the context. In the spirit of keeping things simple, a complex configuration involving a view resolver was avoided, because the scope of this module is to show the power of Spring Boot and what exactly it does in the background. The autowired context is used to create an HTML string that is rendered when accessing http://localhost:8080/ and shows the name of all the beans created by Spring Boot or defined in the application; thus, you can analyze what Spring Boot is doing in the background. The simple controller looks like this: @RestController public class HelloWorldController { @Autowired ApplicationContext ctx; @RequestMapping(\"/\") public String index() { StringBuilder sb = new StringBuilder(\"<html><body>\"); sb.append(\"Hello there dear developer, here are the beans you were looking for: </br>\"); String beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) { sb.append(\"</br>\").append(beanName); } sb.append(\"</body></htm>\"); return sb.toString(); } } This is roughly what you see in the browser: Hello there dear developer, here are the beans you were looking for: actuatorMetricRepository application applicationContextIdFilter auditEventRepository auditListener autoConfigurationAuditEndpoint basicErrorController beanNameHandlerMapping beanNameViewResolver beansEndpoint characterEncodingFilter configurationPropertiesReportEndpoint counterService ... healthEndpoint healthMvcEndpoint helloWorldController ... 371 Chapter 8 ■ Spring Boot and WeBSoCket Of course, the list is incomplete here—just a small snippet is depicted. You have to run the application yourself to see the complete list. ■ ! and you can view the same list of beans in JSon format if you access the actuator service available at http://localhost:8080/beans. Also, if you want to know where the implementation for these beans comes from, just look at the dependencies for your project in Gradle view in Intellij IDEA. You should see something similar to what is depicted in Figure 8-1, but the list will be way bigger. Figure 8-1. Transitive dependencies added by Spring Boot to a web application project So far, only the default configuration inferred by Spring Boot has been presented. This application is roughly similar to the one in the official tutorial at https://spring.io/guides/gs/spring-boot/; but in this book, things are spiced up a little. 372 Chapter 8 ■ Spring Boot and WeBSoCket Customizing Spring Boot There are a few ways that Spring Boot configuration can be externalized” • use properties files • use YAML files • use environment variables • use command-line variables (when a Spring Boot command-line interface is installed) In the previous example, the controller and the configuration class were in the same package, and by default, the configuration class annotated with SpringBootApplication scans only the current package and its subpackages. This can be changed by annotating the same class with @ComponentScan and specifying different package groups. In the 08-chapter-02-solution module, the Application was moved to the com.book.init package, and HelloWorldController was moved to com.book.web, as depicted in Figure 8-2. Figure 8-2. Spring Boot with beans and configuration in different packages The new configuration class code looks like this: package com.book.init; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Import; 373 Chapter 8 ■ Spring Boot and WeBSoCket @SpringBootApplication @ComponentScan(basePackages = {\"com.book.*\"}) //or @ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"}) public class Application { public static void main(String args) { SpringApplication.run(Application.class, args); } } But what if you want the application to be available on a different port and in a different context path?",
    "answer": "There are a few ways to do this. The simplest way is to create a customized bean class that implements the org.springframework. boot.context.embedded.EmbeddedServletContainerCustomizer interface and provides a concrete implementation for the customize method: package com.book.init; import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer; import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer; import org.springframework.stereotype.Component; /**",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Created by iuliana.cosmina on 9/23/15. */ @Component public class CustomizationBean implements EmbeddedServletContainerCustomizer { @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); container.setContextPath(\"/boot\"); } } By adding this bean to the configuration, the application can now be accessed at http://localhost:8083/boot. Another way to do this is by using a customized factory bean for JettyEmbeddedServletContainerFactory. Aside from port and contextPath, some settings for the optimization of the embedded Jetty server used to run the application can be provided. The @Bean annotated method that declares this bean can be added to any configuration class that is taken into consideration by Spring Boot. package com.book.init; import org.eclipse.jetty.server.Server; import org.eclipse.jetty.util.thread.QueuedThreadPool; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.embedded.jetty. JettyEmbeddedServletContainerFactory; import org.springframework.boot.context.embedded.jetty. JettyServerCustomizer; 374 Chapter 8 ■ Spring Boot and WeBSoCket import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * Created by iuliana.cosmina on 9/27/15. */ @Configuration public class JettyFactoryConfig { @Bean public JettyEmbeddedServletContainerFactory jettyServletContainerFactory(@Value(\"${server.port:8085}\") final String port, @Value(\"${jetty.threadPool.maxThreads:200}\") final String maxThreads, @Value(\"${jetty.threadPool.minThreads:8}\") final String minThreads, @Value(\"${jetty.threadPool.idleTimeout:60000}\") final String idleTimeout) { final JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory(Integer.valueOf(port)); factory.setContextPath(\"/boot\"); factory.addServerCustomizers(new JettyServerCustomizer() { @Override public void customize(final Server server) { // Customize the connection pool used by Jetty to handle //incoming HTTP connections final QueuedThreadPool threadPool = server.getBean(QueuedThreadPool.class); threadPool.setMaxThreads(Integer.valueOf(maxThreads)); threadPool.setMinThreads(Integer.valueOf(minThreads)); threadPool.setIdleTimeout(Integer.valueOf(idleTimeout)); } }); return factory; } } By adding this bean to the configuration, the application can now be accessed at http://localhost:8085/boot. Values for the customizations can be provided, directly as done before, but they also can be provided using properties files or YAML files. In order to provide the configuration via a properties file, a file named application.properties has to be created and applied to the application from the outside, or it can be packaged in the jar. If multiple profiles are used, multiple files can be added. Their naming matches the application-{profile}.properties template. SpringApplication looks for an application.properties file in the following locations, and adds them to the Spring environment: • a /config directory under the current directory • the current directory • a classpath /config package • the classpath root 375 Chapter 8 ■ Spring Boot and WeBSoCket Being a resource file, application.properties must be located during development under src/main/resources. The preceding list is ordered by precedence, so Spring Boot looks for property files by traversing the list from top to bottom. The first properties file found is taken into consideration, and it does not matter if the subsequent locations have a properties file defined. The default name of the properties file is application.properties. Spring Boot looks for it, unless it was changed by setting the environment variable named spring.config.name. The location of the file can also be provided as the value for the environment variable named spring.config.location. So if the 08-chapter-02-solution application is packaged into a runnable jar called boot.jar, the application could be run from the command line with the following arguments: #Spring Boot will search in the classpath for a file named boot.properties $ java -jar boot.jar --spring.config.name=boot #Spring Boot will read the properties the specified file $ java -jar boot.jar --spring.config.location=/Users/myuser/config/default.properties In the preceding example, the file is saved under book-code/08-chapter-02-solution/src/main/ resources and has the following contents: #application.properties app.port=8084 app.context=/boot These property values are injected using the @Value annotation into a customization bean that is picked up and used by Spring Boot. The application is then accessed at http://localhost:8084/boot. package com.book.init; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer; import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer; import org.springframework.stereotype.Component; @Component public class PropertiesConfBean implements EmbeddedServletContainerCustomizer { @Value(\"${app.port}\") private Integer value; @Value(\"${app.context}\") private String contextPath; @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(value); container.setContextPath(contextPath); } } 376 Chapter 8 ■ Spring Boot and WeBSoCket The EmbeddedServletContainerCustomizer interface is used for customizing autoconfigured embedded servlet containers. Any beans of this type are instantiated and used to initialize the configuration of the embedded server before the container itself is started. Without an EmbeddedServletContainerCustomizer bean, the contents of application.properties look different, because they must match the standard property names3 that Spring Boot looks for, as follows: #application.properties server.port=8084 server.context-path=/boot When the snakeyaml library is in the classpath, YAML files can be used instead of properties files. YAML is a well-known format within the Ruby community. It is a superset of JSON, and as such, it is a very convenient format for specifying hierarchical configuration data. In the previous example, if the application.properties file is replaced by application.yml, with the following contents, the behavior will be exactly the same, because the internal org.springframework.beans.factory.config. YamlPropertiesFactoryBean converts the contents of the YAML file into the properties in the initial application.properties file. #application.yml app: port:8082 context:/boot ■ ! Both application.properties and application.yml can be used in the same project, because for bigger projects, the configuration list could be quite large and migration could be a long duration process; it is convenient to be able to do the migration gradually. Be careful not to have the same properties defined in both files, because if this happens, properties defined in application.properties take precedence. YAML properties can be used in a different way. A class can be designed to have its fields initialized from a YAML file. The following AppSettings class is such a class. package com.book.init; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.context.properties.ConfigurationProperties; import javax.annotation.PostConstruct; import javax.validation.constraints.NotNull; @ConfigurationProperties(prefix=\"app\") public class AppSettings { private static Logger logger = LoggerFactory.getLogger(AppSettings.class); @NotNull private Integer port; 3The property names standard list for application.properties or application.yml is at http://docs.spring.io/ spring-boot/docs/current/reference/htmlsingle/#common-application-properties. 377 Chapter 8 ■ Spring Boot and WeBSoCket @NotNull private String context; public Integer getPort() { return port; } public void setPort(Integer port) { this.port = port; } public String getContext() { return context; } public void setContext(String context) { this.context = context; } public AppSettings() { } @PostConstruct public void check() { logger.info(\"Initialized {} {}\", port, context); } } The annotation that allows this is @ConfigurationProperties, which marks a class to be used for initialization with property values by the Spring DataBinder utilities. The advantage here is that usage of the @Value annotation and hard-coding the property names is avoided. Validators can also be added on the fields (notice the @NotNull annotations). The prefix attribute is used to refer to the parent element in the YAML file. This bean is then autowired into the YamlConfBean, which uses its properties as needed. package com.book.init; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer; import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer; import org.springframework.stereotype.Component; @Component public class YamlConfBean implements EmbeddedServletContainerCustomizer { @Autowired private AppSettings appSettings; 378 Chapter 8 ■ Spring Boot and WeBSoCket @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(appSettings.getPort()); container.setContextPath(appSettings.getContext()); } } For Spring Boot to know to create and initialize a bean of type AppSettings, a modification must be made to the Application class. The @EnableConfigurationProperties (AppSettings.class) annotation must be added to the class definition at the same level as @SpringBootApplication. If the class name (AppSettings in this case) is not specified in the annotation, Spring Boot will scan, create, and initialize beans of all classes annotated with ConfigurationProperties. package com.book.init; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.ComponentScan; @SpringBootApplication @ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"}) @EnableConfigurationProperties(AppSettings.class) public class Application { public static void main(String args) { SpringApplication.run(Application.class, args); } } When using Spring Boot, a Spring ASCII banner is printed in the console at application startup, like the one shown in Figure 8-3. Figure 8-3. Spring Boot console banner 379 Chapter 8 ■ Spring Boot and WeBSoCket This too can be customized. The instructions can be found in the official documentation at http://docs.spring.io/spring-boot/docs/1.2.6.RELEASE/reference/htmlsingle/#boot-features-banner. A banner.txt file needs to be created under the resources directory; a text-to-ASCII generator should be used to create the desired banner. The one presented in module 08-chapter-03-solution is shown in Figure 8-4. Figure 8-4. Apress Spring Boot console banner Importing Additional Configuration Elements If an application is migrated to Spring Boot, a lot of the configuration classes and even XML configuration elements can be imported into the Spring Boot configuration class. Additional configuration classes can be imported using the @Import annotation or by adding a @ComponentScan to the Spring Boot core initialization class (the one with the main method in it) and setting the basePackages attribute value with the package name where the class can be found, which ensures that Spring automatically picks up all Spring components, including @Configuration classes. XML configuration can be imported using the @ImportResource annotation, as the Spring Boot initialization class is nothing more than a more complex @Configuration class. if you are using a Unix system, you can also test the examples attached to the chapter using the curl command. Just open a console and execute: curl localhost:8080/boot #modify port or contextPath accordingly in the console, you should see an output similar to what you see in the browser. 380 Chapter 8 ■ Spring Boot and WeBSoCket Running Spring Boot Applications The main difference between using Spring Boot and developing web applications in the typical way is that when the Gradle spring-boot plugin is used, a web archive (*.war) is no longer created, because there is no need for it. The war file is strictly a deployable file that needs to be run using a web server or an application server. Spring Boot can be used to have an embedded server in the application. So when the Gradle spring-boot plugin is used instead of a war, an executable Java archive (*.jar) is created. The created archive can be found under the [project_root]/build/libs and can be executed just like any jar. In the 08-chapter-03-solution.gradle configuration file, there is the line jar.archiveName = \"boot.jar\", which is used to specify the name of the final archive. Without it, the name of the resulting jar would be 08-chapter-03-solution.jar, which is long and unpractical. To build the project, create the jar and then execute the application. The following lines can be executed in the console (shell or command prompt): #this will work only if you have Gradle installed on the system $ gradle clean build $ java -jar build/libs/boot.jar But what if we want the result to be a web archive that should be deployed on an application server or a web server?",
    "answer": "That can be done too, in three simple steps: 1. Modify the application to provide a Servlet initializer for the servlet environment. This is done by making the class annotated with @SpringBootApplication to extend the Spring Boot convenient class org.springframework.boot.context. web.SpringBootServletInitializer and overriding its configure method: @SpringBootApplication @ComponentScan(basePackages = {\"com.book.init\", \"com.book.web\"}) @EnableConfigurationProperties(AppSettings.class) public class Application extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(Application.class); } public static void main(String args) { SpringApplication.run(Application.class, args); } } 2. Leave all the Spring Boot components as dependencies, but use the Gradle war plugin. (Basically, replace apply plugin: 'spring-boot' with apply plugin: 'war'.) 381",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "@EnableWebSocketMessageBroker enables WebSocket message handling using a message broker. AbstractWebSocketMessageBrokerConfigurer is a Spring convenient class implementing the WebSocketMessageBrokerConfigurer interface to provide empty method bodies for optional methods that are now needed for a minimal configuration of a WebSocket application. 390 Chapter 8 ■ Spring Boot and WeBSoCket • The configureMessageBroker() method implementation is used to configure a message broker. The config.enableSimpleBroker(\"/topic\") enables a simple memory-based message broker used to filter destinations prefixed with \"/topic\" targeting the broker. The config.setApplicationDestinationPrefixes(\"/app\") method designates the prefix for messages that need to be handled by methods annotated with @MessageMapping. • The registerStompEndpoints() registers the \"/mirc\" STOMP endpoint, and enables and configures the SockJS fallback options. The subsequent chained method calls are used to configure streaming details. Streaming transports save responses on the client side and do not free the memory occupied by delivered messages, so the connection needs to be recycled from time to time. WebSocket communication is based on HTTP Streaming, which works by pushing content continuously to browser. The memory usage is kept accumulated in browser. Basically, the browser needs to close and reconnect the streaming channel to release memory. So there are a limited number of bytes that can be sent before the HTTP streaming connection is closed. The default value set by SockJS is 128K; the .setStreamBytesLimit(512 * 1024) call sets it to 512K. The number of server-to-client messages that can be cached in a session waiting for the next HTTP request polling is also limited. The default is 100 and it is set by the web server; the .setHttpMessageCacheSize(1000) call sets it to 1000. The number of milliseconds after an inactive client is disconnected is 5 seconds and it is set by the web server, but the .setDisconnectDelay(30 * 1000) call sets it to 30. To use all of these elements, the spring-websocket and spring-messaging libraries must be added as dependencies. When using Spring Boot, only the spring-boot-starter-websocket dependency is necessary. Spring Boot adds all the necessary dependencies. Aside from this, the entry point of the application is the com.init.Application class, which is a typical boot-up Spring Boot class. package com.book.init; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; @SpringBootApplication @ComponentScan(basePackages = {\"com.book.init, com.book.ws\"}) public class Application { public static void main(String args) { SpringApplication.run(Application.class, args); } } 391 Chapter 8 ■ Spring Boot and WeBSoCket WebSocket Client Application As depicted in Figure 8-5, client applications for a Spring WebSocket server application can be written in any programming language for which a WebSocket implementation or Socket-compatible implementation exists. For the example in this section, the simplest way to create a client application is the plain old HTML and JavaScript pair. [STEP 5] Creating a browser client application is easy, and for the scope of this book, it is part of the same application and deployed on the same embedded container. The application is a JavaScript client that sends and receives messages from the server. The module project for this section can be found under the book-code project and it is called 08-chapter-04-solution. The module is a Spring Boot WebSocket project organized as follows: • The sources for the WebSocket server-application can be found under src/main/java. The configuration classes are placed in the com.book.init package. All classes involved in WebSocket communication are placed under the com.book.ws package. • The sources for the JavaScript client application can be found under src/main/ resources/static. The client application can be accessed at index.html. The functions that get called on specific HTML events are all gathered in the index.js file. The JavaScript external libraries used in the project are under the static/ext directory. • jQuery is used to simplify the development of the JavaScript code used to handle HTML user events. • SockJS is used to emulate WebSocket and provides a WebSocket-like API. • The STOMP library is used to help create STOMP messages. The structure of the full Spring Boot WebSocket project is depicted in Figure 8-6. 392 Chapter 8 ■ Spring Boot and WeBSoCket Figure 8-6. The 08-chapter-04-solution project structure The client application when no client is connected is depicted in Figure 8-7. Figure 8-7. The client application before connection 393 Chapter 8 ■ Spring Boot and WeBSoCket Here is the static front-end that is written in HTML and represented by the index.html file: <!DOCTYPE html> <html> <head> <title>WebSocket mIRC-like sample application</title> <script src=\"ext/sockjs-0.3.4.js\"></script> <script src=\"ext/stomp.js\"></script> <script src=\"ext/jquery-2.1.4.js\"></script> <script src=\"index.js\"></script> <link rel=\"stylesheet\" href=\"css/general.css\"> </head> <body> <noscript><h2 style=\"color: #ff0000\">Seems your browser doesn’t support JavaScript! Websocket relies on Javascript being enabled. Please enableJavascript and reload this page!</h2></noscript> This is a simple mirc-like web chat application, no authentication is necessary, just provide a name and start chatting!</h4> <div class=\"header\"> Name : <input id=\"name\" type=\"text\"/> <input id=\"connection\" type=\"button\"/> </div> <div class=\"chatDiv\"> <textarea class=\"chat\"></textarea> </div> <div class=\"footer\"> <input id=\"content\" type=\"text\"/> <input id=\"send\" type=\"button\" value=\"Send\"/> </div> </body> </html> The following describes the four JavaScript functions in index.js: • setConnected(boolVal): The argument is a boolean value. The method is called with true when connecting to the server application and with false when disconnecting. The same button is used for connecting and disconnecting. The label on the button changes depending on the current state of the application. When the application is accessed for the first time, a name is required to connect to the application. function setConnected(connected) { \\\\ set label for the connect/disconnect button connected ?",
    "answer": "$(\"#connection\").attr(\"value\", \"Disconnect\") : $(\"#connection\").attr(\"value\", \"Connect\"); \\\\ disable name textfield so the name cannot be modified \\\\ after connecting $(\"#name\").prop(\"disabled\", connected); 394",
    "source": "extracted",
    "confidence": 1.0
  }
]