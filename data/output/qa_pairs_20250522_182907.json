[
  {
    "question": "Write a program to find the sum of the entire array result using java 8 streams?",
    "answer": "Write a program to find even numbers from a list of integers and multiply by 2 using stream java 8? Write a program to find the occurrence of each word in a given string in java? Write a Program to find a common element from three integer ArrayList. eg. arr1, arr2, and arr3. Write a program to convert string to integer in java without any API? Write a program to find the first occurrence of a character in a string in java? Write a program to find the missing number in an Array in java. Write a Program to Find a possible combination of the given string “GOD”? Write a program for valid parenthesis in java? Write a program to find duplicates in an ArrayList. Write a program for the Quick sort algorithm. Write a program to check the minimum number of occurrences of a character in a given string in java. Write a program of an array, it must multiply the array, leaving itself aside, and that multiplication should be kept in that array position in Java. Can you write down a Spring boot rest API for addition of two integers? How to count every character in string using java 8? Check the unique String program? Write a program to Find spikes in a stock of integer array? Find the output of below program? CHAPTER 14: SCENARIO-BASED Thread-Pool Based Scenario: Rest-API & Database-based-scenario Database-based-scenario:1 Database-based-scenario:2 Microservice-based-scenario Inheritance Scenario-Based How to create a custom HashMap of size 2GB? Design an application where you are getting millions of requests how will you design it. Suppose you have an application where the user wants the order history to be generated, and that history pdf generation take almost 15 minutes how will you optimise this solution. How this can be reduced. CHAPTER 15: JAVA FEATURES FROM JAVA 8 TILL JAVA 21 WITH EXAMPLE Java 8 Features Java 9 Features Java 10 Features Java 11 Features Java 12 Features Java-13 Features Java-14 Features Java 15 Features: Java 16 Features Java 17 Features Java 18 Features Java 19 Features Java 20 Features Java 21 Features CHAPTER 16: KAFKA Explain the producer & consumer-based architecture of Kafka. How to persist data directly from Kafka topic.is it possible or not? What is offset in Kafka? What is consumer offset? How to configure the Kafka details? How to determine the replication factor? Which annotation is used to enable Kafka? CHAPTER 17: MISCELLANEOUS What is the difference between a container and a virtual machine? Differences between Dockerization and Virtualisation? What is a pod in Kubernetes? Can we write j-units for static methods? How to resolve this Mockito exception “Mockito cannot mock this class”? What is binary search tree? OVERVIEW Welcome to the Ultimate Guide for Mastering Java Developer Interviews! Whether you're just starting out in Java development or have been at it for up to 10 years, this book is here to help you prepare for your dream job. It's designed to be your go-to companion. Inside, you'll find a handpicked collection of important interview questions based on my own experiences. But it's not just questions – I've also included detailed and relevant answers to each one. This guide covers a wide range of topics to make sure you're well- prepared. From the basics like Object-Oriented Programming and Core Java to more advanced topics like Java-8, Spring Framework, Spring-Boot, Microservice architecture, Memory Management in Java, REST principles, Design Patterns, System Design, SQL and Hibernate-JPA, and various Coding and Programming Questions – it's all covered! I've even included Scenario-Based Interview Questions to test your problem-solving skills in practical situations. And there's a section on Miscellaneous topics to make sure you're knowledgeable in all the essential areas. The book also explores Multithreading, an area often focused on in interviews to assess your concurrent programming skills. By the end of this guide, you'll walk into your interview with confidence and expertise. The knowledge you gain here will set you apart from the competition. So, embrace this opportunity and start your journey toward interview success with enthusiasm. Best of luck! Best Regards, Ajay Rathod HOW TO PREPARE FOR A JAVA DEVELOPER INTERVIEW I will be sharing my preparation strategy for techies who want to hunt for their next tech job. Over the course of three months, I extensively prepared for a Java developer role. This preparation helped me clear many interviews, including those with BIG FOUR companies. Developers with 0–10 years of experience can apply this strategy. Disclaimer: This article is not intended for FAANG companies; I am referring to general tech companies ranging from MNCs to small- scale and large-scale entities within the Indian Job Market. In this article, I will elaborate on interview preparation and share my strategies on how to maximize your chances of being selected for an interview. Typical Interview Format Technical Round 1 (L1 round) Technical Round 2 (L2 round) Manager Round HR round Usually, if you can clear the technical rounds, you are well on your way to receiving an offer letter, as the manager and HR rounds primarily involve discussions. Hence, our focus should be on preparing for the technical rounds. Technical Round Preparation Steps The interview typically begins with an introduction, and the interviewer may inquire about the project you have been working on. Step 1: Know Your Current Project Inside and Out a. Understand the functionality of the project, including its purpose and the problems it solves for customers. Essentially, you should have a comprehensive overview of your project's functions. b. Familiarize yourself with the project's architecture and technical stack. You can also delve deeper to comprehend the end-to-end flow. c. Discuss the technical stack used in the project. For instance, specify the front-end framework (e.g., Angular, React), the backend technology (e.g., Java, Python), and the database (e.g., PostgreSQL, Dynamo DB). d. Gain insight into the CI/CD model employed. Many developers are unaware of the deployment process, so this is a crucial aspect to understand. Thoroughly studying the aforementioned project-related aspects will empower you to steer the interview in your favor. Remember, your responses often guide the interview. Step 2: Java Developer Competencies As a Java Developer, you should be well-versed in the following topics, which will significantly enhance your likelihood of being selected. Object-Oriented Programming principles, including SOLID principles (prepare for inheritance puzzles) Multithreading and Concurrency (prepare for Executor framework and concurrency API) Collection framework (Comprehend the internal workings of each collection data structure, such as HashMap, ConcurrentHashMap, HashSet) Serialization (Understand its functioning) Design Patterns (Familiarize yourself with at least 4–5 design patterns, including creational, behavioral, and structural patterns) Garbage Collection Java Generics Java 8 (Stream and Functional Programming—prepare to write Java 8 code for stream operations) SQL Queries (Be ready to write queries involving JOINS and employee tables, such as retrieving the highest salary) Coding Practice (Solve a variety of Array and String problems) Memory Management (Stay informed about memory management changes in Java 8 and above) Proficiency in the aforementioned areas is crucial for interview success. Candidates are typically evaluated based on their practical knowledge and ability to write programs and SQL queries using Java. These skills significantly contribute to interview performance. Remember, diligent preparation and a strong grasp of these concepts will greatly improve your chances of excelling in your Java Developer interview. Good luck! HOW I MASTERED JAVA IN DEPTH FOR TECHNICAL INTERVIEWS AND TRIPLED MY SALARY Learning Java in-depth for Java Developer Technical interviews was a transformative journey, driven by my personal experience. As I share my takeaways, you'll discover how this process enriched my knowledge and significantly boosted my earnings. With the high demand for Java professionals in the market, my insights can benefit Java Developer professionals seeking to excel in their current or future roles. Initial Steps: From Junior Java Developer to Depth Mastery Starting as a Junior Java developer, I heavily relied on internet searches for coding solutions. A mentor's guidance would have been invaluable, but I lacked that privilege. My quest for a new job led to rejection due to my superficial knowledge. Key Lessons:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the types of Functional interfaces?",
    "answer": "There are several types of functional interfaces in Java 8, each with a specific purpose. Some of the most commonly used functional interfaces include: Consumer<T>: Represents an operation that takes a single input argument and returns no result. This interface is typically used to perform some operation on an object, such as printing it to the console. Supplier<T>: Represents a supplier of results. This interface is typically used to create a new object or retrieve a value from a data source. Predicate<T>: Represents a predicate (boolean-valued function) of one argument. This interface is typically used to test a condition and return a boolean value. Function<T, R>: Represents a function that takes an argument of type T and returns an argument of type R. This interface is typically used to transform an object from one type to another. UnaryOperator<T>: Represents an operation on a single operand that produces a result of the same type as its operand. It is a specialization of Function for the case where the operand and result are of the same type. BinaryOperator<T>: Represents an operation upon two operands of the same type, producing a result of the same type as the operands. BiConsumer<T, U>: Represents an operation that accepts two input arguments and returns no result. BiFunction<T, U, R>: Represents a function that takes two arguments and produces a result. BiPredicate<T, U>: Represents a predicate (boolean-valued function) of two arguments. Runnable: Represents a command that can be executed. These are some of the most common functional interfaces, but there are many others in the Java standard library, each with its own specific use case. What is Method Reference in Java 8? In Java 8, a method reference is a shorthand notation for a lambda expression that simply invokes an existing method. The basic syntax for a method reference is: ClassName::methodName For example, if you have a class called \"MyClass\" with a method called \"myMethod\", you could use a method reference to invoke that method like this: MyClass::myMethod You can also use method references with constructors and array constructors. The basic syntax for a constructor reference is: ClassName::new For example, if you have a class called \"MyClass\", you could use a constructor reference to create a new instance of that class like this: MyClass::new And the basic syntax for a array constructor reference is: TypeName[]::new For example, if you want to create an array of integers, you could use an array constructor reference like this: int[]::new Method references can be used in situations where a lambda expression would be used to invoke an existing method, such as when passing a method as an argument to a higher-order function. What is Optional in java? In Java, the Optional class is a container object which may or may not contain a non-null value. It is introduced in Java 8 as a part of the java.util package. It is used to represent a value that may not be present, and to prevent null pointer exceptions. The main methods of the Optional class are: of(T value): Creates an Optional instance with the given non-null value. ofNullable(T value): Creates an Optional instance with the given value, which can be null. empty(): Creates an empty Optional instance. isPresent(): Returns true if the Optional contains a value, false otherwise. get(): Returns the contained value, if present. If the Optional is empty, it throws a NoSuchElementException. orElse(T other): Returns the contained value if present, otherwise returns the given default value. orElseGet(Supplier<? extends T> supplier): Returns the contained value if present, otherwise returns the result of the given supplier function. orElseThrow(Supplier<? extends X> exceptionSupplier): Returns the contained value if present, otherwise throws the exception provided by the given supplier function. ifPresent(Consumer<? super T> consumer): If a value is present, invoke the specified consumer with the value, otherwise do nothing. It is best practice to use Optional when the return type of a method can return null as it forces to handle the null case explicitly. For example, Optional<String> optional = Optional.ofNullable(null); if(optional.isPresent()) { System.out.println(optional.get()); } else { System.out.println(\"No value\"); } In this example, the value of the optional is null, so the output would be \"No value\". What are the Intermediate and terminal operations in java 8? In Java 8, the Stream API is used to process collections of data in a functional manner. The Stream API provides two types of operations: intermediate and terminal. Intermediate operations are operations that are performed on a stream, but do not produce a final result. They are used to transform the elements of a stream in some way, and return a new stream that contains the transformed elements. Examples of intermediate operations include filter, map, and flatMap. Terminal operations are operations that produce a final result or a side-effect. They are used to consume the elements of a stream and produce a final result, such as a count, a sum, or a list. Examples of terminal operations include forEach, reduce, and collect. Intermediate operations are lazy, meaning that they are not executed until a terminal operation is called. This allows multiple intermediate operations to be chained together, with the result of one operation being passed as the input to the next. For example, List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .filter(n -> n % 2 == 0) .map(n -> n * 2) .reduce(0, Integer::sum); In this example, filter is an intermediate operation that filters the stream of numbers to keep only even numbers. map is an intermediate operation that transforms each number in the stream by doubling it. reduce is a terminal operation that sums the numbers in the stream and returns the result. It is important to note that once a terminal operation is called, the stream is considered consumed and it can't be reused. What is parallel processing in Java-8, and what are its uses? Parallel processing in Java 8 refers to the ability to perform operations on a stream in parallel, using multiple threads. The Java 8 Stream API provides the parallel() method, which can be used to create a parallel stream from an existing sequential stream. A parallel stream automatically splits the data into smaller chunks and assigns each chunk to a separate thread for processing. The results from each thread are then combined to produce the final result. Parallel processing can be useful for improving the performance of certain types of operations, such as filtering and mapping, on large data sets. It can also be used to perform complex computations in parallel, such as reducing a large data set to a single value. For example, List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); int sum = numbers.parallelStream().mapToInt(Integer::intValue).sum(); In this example, the parallelStream() method is used to create a parallel stream of the numbers, and the mapToInt() and sum() methods are used to calculate the sum of the numbers in parallel. It's important to note that parallel processing may not always be beneficial and it is dependent on the size of data and nature of operation. It's always good to check the performance of the operation in both parallel and sequential mode and compare the results. What is the difference between Flat and flat-map methods in Java-8? flatMap is a method in Java Streams that is used to convert a stream of collections or arrays into a single flattened stream. In contrast, the flat method is not a standard method in Java Streams. Here is an example of using flatMap to flatten a stream of collections: List<List<Integer>> nestedList = Arrays.asList( Arrays.asList(1, 2), Arrays.asList(3, 4), Arrays.asList(5, 6) ); List<Integer> flattenedList = nestedList.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); System.out.println(flattenedList); // Output: [1, 2, 3, 4, 5, 6] In this example, we start with a List of List objects. We use the flatMap method to convert each inner List into a stream of integers, and then concatenate all the streams into a single stream of integers. Finally, we collect the resulting stream into a new List object. The flat method, on the other hand, is not a standard method in Java Streams. It may be implemented as a custom method or library method, but its behavior would depend on the implementation. What is default method its use? A default method is a method defined in an interface that has a default implementation. Default methods were introduced in Java 8 to allow interfaces to be extended without breaking existing implementations. Prior to Java 8, interfaces could only contain method signatures, which meant that any class that implemented an interface was required to provide an implementation for all of its methods. This could be problematic when you wanted to add new methods to an existing interface, because it would break all of the existing implementations. With default methods, you can provide a default implementation for a method in an interface, which means that classes that implement the interface are not required to provide their own implementation. If a class does not provide its own implementation for a default method, it will use the default implementation defined in the interface. Default methods are useful for extending existing interfaces without breaking existing implementations. They can also be used to provide a common implementation for a method that is applicable to all classes that implement the interface. For example, consider an interface for a collection of items: public interface Collection<T> { void add(T item); boolean contains(T item); int size(); default boolean isEmpty() { return size() == 0; } } This interface defines three methods for adding items to the collection, checking if an item is contained in the collection, and getting the size of the collection. It also defines a default method, isEmpty(), that returns true if the size of the collection is 0. Classes that implement this interface are not required to provide their own implementation for isEmpty(), because a default implementation is already provided in the interface. However, they can override the default implementation if they need to provide a different behaviour. What is default and static methods in Java-8? Default and static methods are two new features that were introduced in Java 8. Default methods allow you to add new methods to interfaces without breaking existing code. This is done by providing a default implementation of the method in the interface. Classes that implement the interface can override the default implementation, or they can simply use the default implementation. example of a default method: public interface Animal { default void eat() { System.out.println(\"I am eating.\"); } } Any class that implements the Animal interface will have access to the eat() method, even if the class does not explicitly implement the eat() method. Static methods are methods that can be declared in interfaces. Static methods belong to the interface itself, not to any specific instance of the interface. Static methods can be called without creating an instance of the interface. public interface Animal { static void makeSound() { System.out.println(\"I am making a sound.\"); } } The makeSound() method can be called without creating an instance of the Animal interface: Animal.makeSound(); // prints \"I am making a sound.\" Default and static methods can be used to improve the design of Java applications in a number of ways. For example, default methods can be used to add new functionality to existing interfaces, and static methods can be used to provide utility methods that are available to all classes that implement a particular interface. What are the memory changes that happened in java8? The following are some of the memory changes that happened in Java 8: Metaspace: Java 8 introduced Metaspace to replace PermGen. Metaspace is a region of memory that is used to store class metadata, such as class names, field and method names, and method bytecode. Metaspace is part of the native memory heap, which means that it is not limited by the maximum heap size. G1 garbage collector: Java 8 introduced the G1 garbage collector as the default garbage collector. The G1 garbage collector is a concurrent garbage collector, which means that it can collect garbage while the application is still running. This can improve the performance of applications that have large heaps. CompressedOops: Java 8 introduced CompressedOops, which is a technique that can reduce the memory footprint of Java objects. CompressedOops works by compressing object pointers from 64 bits to 32 bits on 64-bit platforms. This can reduce the memory footprint of Java objects by up to 50%. String deduplication: Java 8 introduced String deduplication, which is a technique that can reduce the memory footprint of String objects. String deduplication works by storing a single copy of each unique String object in memory. This can reduce the memory footprint of String objects by up to 50%. Overall, the memory changes in Java 8 have made Java applications more memory-efficient. This is important for applications that run on devices with limited memory, such as mobile devices and embedded systems. What is the new Java 8 changes in HashMap? Java 8 made the following changes to HashMap: New hash function for Strings: Java 8 introduced a new hash function for Strings that is more resistant to hash collisions. This can improve the performance of HashMap when it is used to store Strings. Treeification: Java 8 added a new feature called \"treeification\" to HashMap. Treeification automatically converts a linked list of entries in a bucket to a red-black tree when the number of entries in the bucket exceeds a certain threshold. This can improve the performance of HashMap when there are a large number of hash collisions. ConcurrentHashMap: Java 8 introduced a new concurrent implementation of HashMap called ConcurrentHashMap. ConcurrentHashMap is designed to be safe for concurrent access by multiple threads. Why are the variable inside lambda function final in java? Variables inside lambda functions are final in Java because it helps to prevent concurrency problems. Lambda functions are often used to capture variables from the surrounding scope. If these variables were not final, then it would be possible for multiple threads to modify the variables at the same time, which could lead to unexpected results. int x = 0; Runnable runnable = () -> { x++; // This would cause a concurrency problem if multiple threads were executing this lambda function at the same time. }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); If the x variable were not final, then it is possible that both threads would increment the x variable at the same time, and the final value of x would be unpredictable. By making variables inside lambda functions final, Java can ensure that these variables cannot be modified by multiple threads at the same time. This helps to prevent concurrency problems and makes Java code more robust. Here is an example of how to use a lambda function without causing a concurrency problem: int x = 0; Runnable runnable = () -> { // This is safe because the variable x is final. int y = x + 1; System.out.println(y); }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); In this example, the x variable is final, so it cannot be modified by multiple threads at the same time. This ensures that both threads will read the same value for the x variable, and the output of the program will be predictable. Overall, making variables inside lambda functions final is a good practice that can help to prevent concurrency problems and make Java code more robust. CHAPTER 6: SPRING-FRAMEWORK What is dependency injection? Dependency injection is a design pattern used in software development that involves separating the creation of an object from its dependencies. It allows for a more flexible and testable code by decoupling the components of a software system. In simple terms, dependency injection is a technique for providing the dependencies of an object from the outside, rather than having the object itself create or find them. This is achieved by injecting the dependencies into the object's constructor or by using a dedicated dependency injection framework. By using dependency injection, software components become more modular and reusable. Changes to one component can be made without affecting the other components of the system, making it easier to maintain and extend the software. Additionally, it promotes better testing practices, as dependencies can be easily mocked or replaced during testing. Overall, dependency injection is an important tool for creating well- structured and maintainable software systems. What are the types of dependency injection and what benefit we are getting using that? Dependency injection : Dependency injection (DI) is a design pattern that allows objects to be supplied with their dependencies, rather than having to create them themselves. There are several types of dependency injection, each with its own benefits: Constructor injection: In this type of injection, the dependencies are passed to the constructor of the class when it is instantiated. This ensures that the class always has the required dependencies and can be useful for enforcing class invariants. Setter injection: In this type of injection, the dependencies are passed to setter methods of the class after it has been instantiated. This allows the class to be reused in different contexts, as the dependencies can be changed at runtime. Field injection: In this type of injection, the dependencies are injected directly into the fields of the class. This can be useful for simple classes with a small number of dependencies. Method injection: In this type of injection, the dependencies are passed to a method of the class after it has been instantiated. This allows the class to be reused in different contexts, as the dependencies can be changed at runtime. Each type of dependency injection has its own benefits, and the choice of which one to use will depend on the specific requirements of the application. Constructor injection is useful when a class needs to be in a specific state when it is created. It makes the class more robust and less susceptible to bugs caused by incomplete initialization. Setter injection allows the class to be reusable, as the dependencies can be changed at runtime, making it easy to test the class with different dependencies. Field injection is the simplest way of injecting dependencies and it doesn't require any additional methods or constructors. Method injection allows the class to be reusable, as the dependencies can be changed at runtime and it can be used to configure objects that need to be initialized with specific values. Overall, dependency injection allows for more flexible and maintainable code by decoupling the implementation of a class from the creation and management of its dependencies. This makes it easier to test, understand, and evolve the code over time. Which type of dependency injection do you prefer? The preferred type of dependency injection depends on the specific use case and the requirements of the application. Here are some benefits and considerations for each type of dependency injection: Constructor injection: Preferred when a bean has a mandatory dependency that must be provided at instantiation. Constructor injection ensures that all dependencies are provided and valid at instantiation. Constructor injection makes the code more readable and self- explanatory. Constructor injection makes the code more testable, as the dependencies are explicit. Setter injection: Preferred when a bean has optional dependencies that can be provided later. Setter injection allows the bean to be instantiated without all of its dependencies. Setter injection makes the code more readable and self-explanatory. Setter injection makes the code more testable, as the dependencies are explicit. Field injection: Preferred when a bean has a mandatory dependency that must be provided at instantiation. Field injection is less verbose than constructor injection. Field injection can make the code more difficult to read and understand. Field injection can make the code more difficult to test, as the dependencies are not explicit. Ultimately, the choice of which type of dependency injection to use depends on the specific requirements of your application and your team's coding style. How does inversion of control works inside the Spring Container? Inversion of Control (IoC) is a design pattern that allows control to be transferred from the application code to an external container. In the context of a Java application, this container is often referred to as an IoC container or a dependency injection (DI) container. IoC containers are responsible for creating and managing objects, and they do this by relying on a set of configuration rules that define how objects are created and wired together. Here's how IoC works inside an IoC container: Configuration: In order to use an IoC container, you need to configure it with a set of rules that define how objects should be created and wired together. This configuration is typically done using XML or Java annotations. Object creation: When your application requests an object from the container, the container uses the configuration rules to create a new instance of the requested object. Dependency injection: The container injects any required dependencies into the newly created object. These dependencies are typically defined in the configuration rules. Object lifecycle management: The container manages the lifecycle of the objects it creates. This means that it's responsible for creating, initializing, and destroying objects as required by the application. Inversion of control: By relying on the container to create and manage objects, the application code no longer has direct control over the object creation process. Instead, the container takes on this responsibility, and the application code simply requests the objects it needs from the container. Overall, the IoC container is responsible for managing object creation and lifecycle management, while the application code is responsible for defining the rules that govern how objects are created and wired together. This separation of concerns allows for greater flexibility and modularity in the application, as the application code can be easily modified without affecting the underlying object creation and management processes. What is the difference Between BeanFactory and ApplicationContext? In Spring Framework, both the BeanFactory and the ApplicationContext are used to manage the lifecycle and dependencies of beans, but they have some key differences. BeanFactory: BeanFactory is the root interface for accessing a Spring container. It is the basic container providing only configuration management, without advanced features like internationalization or event propagation. BeanFactory is lightweight and suitable for simple applications, but it does not provide some advanced features like internationalization, event handling, and AOP support. ApplicationContext: The ApplicationContext interface is a sub- interface of BeanFactory. It provides additional features such as support for internationalization (I18N) messages, application-layer specific contexts such as the WebApplicationContext for use in web applications, and the ability to publish application events to interested event listeners. It also provides support for AOP and can automatically publish events to listeners. In summary, the BeanFactory is a more lightweight and simple container, while the ApplicationContext is a more advanced container that provides additional features such as internationalization, event handling, and AOP support. If your application needs only the basic functionality of a container, the BeanFactory may be a better choice, while if your application needs more advanced features, the ApplicationContext may be a better choice. What is difference between application context and bean context? In Spring Framework, both the application context and bean context represent the context in which Spring-managed beans live. However, there are some key differences between these two concepts: Scope: The application context is the top-level context for a Spring application, and it manages the lifecycle of all beans within the application. The bean context, on the other hand, is a child context that is created for a specific set of beans, typically defined within a module or subsystem of the application. Configuration: The application context is responsible for configuring the entire application, and it can be configured using XML, annotations, or Java code. The bean context, on the other hand, is typically configured using XML or annotations, and it only contains the configuration for the beans within that context. Lifecycle: The application context is responsible for managing the lifecycle of the entire application, including starting up and shutting down the application. The bean context, on the other hand, only manages the lifecycle of the beans within that context. Accessibility: The application context is accessible throughout the entire application, while the bean context is only accessible within the context in which it is created. In summary, the application context is the top-level context that manages the entire Spring application, while the bean context is a child context that manages a specific set of beans within the application. The application context is responsible for configuring and managing the lifecycle of the entire application, while the bean context only manages the beans within its scope. What is the Spring bean lifecycle? In Spring Framework, a bean is an object that is managed by the Spring IoC container. The lifecycle of a bean is the set of events that occur from its creation until its destruction. The Spring bean lifecycle can be divided into three phases: instantiation, configuration, and destruction. Instantiation: In this phase, Spring IoC container creates the instance of the bean. Spring Framework supports several ways of instantiating a bean, such as through a constructor, a static factory method, or an instance factory method. Configuration: In this phase, Spring IoC container configures the newly created bean. This includes performing dependency injection, applying any bean post- processors, and registering any initialization and destruction call-backs. Destruction: In this phase, Spring IoC container destroys the bean instance. It is the last phase of the Spring bean lifecycle. In addition to these three phases, Spring Framework also provides several callbacks that allow developers to specify custom initialization and destruction logic for a bean. These callbacks include: @PostConstruct: Invoked after the bean has been constructed and all dependencies have been injected init-method: Specifies a method to be called after the bean has been constructed and all dependencies have been injected destroy-method: Specifies a method to be called just before the bean is destroyed. @PreDestroy: Invoked before the bean is destroyed. The Spring bean lifecycle is controlled by the Spring IoC container, which creates, configures, and manages the lifecycle of the beans. Developers can take advantage of the bean lifecycle callbacks to add custom initialization and destruction logic to their beans, making it easier to manage the lifecycle of their objects and ensuring that resources are properly. What are bean scopes? What are prototype and request bean scopes? In Spring Framework, a bean scope defines the lifecycle and the visibility of a bean within the Spring IoC container. Spring Framework provides several built-in bean scopes, each with a specific purpose and behaviour. The following are the most commonly used bean scopes in Spring Framework: singleton: This is the default scope for a bean. A singleton bean is created only once per Spring IoC container and is shared by all the clients that request it. prototype: A prototype bean is created every time it is requested by a client. This scope is useful for beans that are stateful, and the state should not be shared between clients. request: A request-scoped bean is created for each HTTP request and is only available to the beans that are involved in handling that request. session: A session-scoped bean is created for each HTTP session and is only available to the beans that are involved in handling that session. application: An application-scoped bean is created for the entire lifetime of the web application, and is available to all beans throughout the application. websocket: A websocket-scoped bean is created for the duration of a WebSocket session, and is available to all beans that are involved in handling that session. It's important to note that the scope of a bean affects the lifecycle and visibility of that bean within the Spring IoC container. By choosing the appropriate scope for a bean, developers can control how and when the bean is created and how it interacts with other beans in the application. What is the stateless bean in spring? name it and explain it. A stateless bean in Spring Framework is a bean that does not maintain any state between method invocations. This means that the bean does not store any information about the previous invocations, and each method call is handled independently. Stateless beans are typically used for services that perform actions or calculations, but do not maintain any state between invocations. This can include services that perform mathematical calculations, access external resources, or perform other tasks that do not require the bean to maintain state. Stateless beans can be implemented as singleton beans, and multiple clients can share the same instance of the bean. Since stateless beans do not maintain any state, they can be easily scaled horizontally by adding more instances of the bean to handle the increased load. Stateless beans also have the advantage of being simpler and easier to reason about, since they do not have to worry about maintaining state between invocations. Additionally, since stateless beans do not maintain any state, they can be easily serialized and replicated for high availability and scalability. How is the bean injected in spring? In Spring, a bean is injected (or wired) into another bean using the Dependency Injection (DI) pattern. DI is a design pattern that allows a class to have its dependencies provided to it, rather than creating them itself. Spring provides several ways to inject beans into other beans, including: Constructor injection: A bean can be injected into another bean by passing it as a constructor argument. Spring will automatically create an instance of the dependent bean and pass it to the constructor. public class BeanA { private final BeanB beanB; public BeanA(BeanB beanB) { this.beanB = beanB; } } Setter injection: A bean can be injected into another bean by passing it as a setter method argument. Spring will automatically call the setter method and pass the dependent bean. public class BeanA { private BeanB beanB; @Autowired public void setBeanB(BeanB beanB) { this.beanB = beanB; } } Field injection: A bean can be injected into another bean by annotating a field with the @Autowired annotation. Spring will automatically set the field with the dependent bean. public class BeanA { @Autowired private BeanB beanB; } Interface injection: A bean can be injected into another bean by implementing an interface. Spring will automatically set the field with the dependent bean. public class BeanA implements BeanBUser { @Autowired private BeanB beanB; } It's important to note that, you can use any combination of the above methods, but you should choose the appropriate one depending on your use case. Also, Spring uses a technique called Autowiring to automatically wire beans together, Autowiring can be done by type, by name, or by constructor. By default, Spring will try to autowire beans by type, but if there are multiple beans of the same type, it will try to autowire by name using the bean's name defined in the configuration file. How to handle cyclic dependency between beans? Let’s say for example: Bean A is dependent on Bean B and Bean B is dependent on Bean A. How does the spring container handle eager & lazy loading? A cyclic dependency between beans occurs when two or more beans have a mutual dependency on each other, which can cause issues with the creation and initialization of these beans. There are several ways to handle cyclic dependencies between beans in Spring: Lazy Initialization: By using the @Lazy annotation on one of the beans involved in the cycle, it can be initialized only when it is actually needed. @Lazy @Autowired private BeanA beanA; Constructor injection: Instead of using setter or field injection, you can use constructor injection, which will make sure that the dependencies are provided before the bean is fully initialized. public class BeanA { private final BeanB beanB; public BeanA(BeanB beanB) { this.beanB = beanB; } } Use a proxy: A proxy can be used to break the cycle by delaying the initialization of one of the beans until it is actually needed. Spring AOP can be used to create a proxy for one of the beans involved in the cycle. Use BeanFactory: Instead of injecting the bean directly, you can use BeanFactory to retrieve the bean when it's actually needed. public class BeanA { private BeanB beanB; @Autowired public BeanA(BeanFactory beanFactory) { this.beanB = beanFactory.getBean(BeanB.class); } } It's important to note that, the best way to handle cyclic dependencies will depend on the specific requirements of your application. Therefore, you should carefully analyze the problem and choose the approach that best suits your needs. What method would you call a before starting/loading a Spring boot application? In Spring Boot, there are several methods that can be called before starting or loading a Spring Boot application. Some of the most commonly used methods are: main() method: The main() method is typically the entry point of a Spring Boot application. It is used to start the Spring Boot application by calling the SpringApplication.run() method. @PostConstruct method: The @PostConstruct annotation can be used to mark a method that should be called after the bean has been constructed and all dependencies have been injected. This can be used to perform any necessary initialization before the application starts. CommandLineRunner interface: The CommandLineRunner interface can be implemented by a bean to run specific code after the Spring Application context has been loaded. ApplicationRunner interface: The ApplicationRunner interface can be implemented by a bean to run specific code after the Spring Application context has been loaded and the Application arguments have been processed. @EventListener : The @EventListener annotation can be used to register a method to listen to specific Application events like ApplicationStartingEvent, ApplicationReadyEvent and so on. It's important to note that the choice of method will depend on the specific requirements of the application, such as whether the method needs to be called after the application context has been loaded or after specific Application events. How to handle exceptions in the spring framework? There are several ways to handle exceptions in the Spring Framework: try-catch block: You can use a try-catch block to catch and handle exceptions in the method where they occur. This approach is useful for handling specific exceptions that are likely to occur within a particular method. @ExceptionHandler annotation: You can use the @ExceptionHandler annotation on a method in a @Controller class to handle exceptions that are thrown by other methods in the same class. This approach is useful for handling specific exceptions in a centralized way across multiple methods in a controller. @ControllerAdvice annotation: You can use the @ControllerAdvice annotation on a class to define a global exception handler for multiple controllers in your application. This approach is useful for handling specific exceptions in a centralized way across multiple controllers. HandlerExceptionResolver interface: You can implement the HandlerExceptionResolver interface to create a global exception handler for your entire application. This approach is useful for handling specific exceptions in a centralized way across the entire application. ErrorPage: You can define an ErrorPage in your application to redirect to a specific page when a certain exception occurs. This approach is useful for displaying a user-friendly error page when an exception occurs. @ResponseStatus annotation: You can use the @ResponseStatus annotation on an exception class to define the HTTP status code that should be returned when the exception is thrown. How does filter work in spring? In Spring Framework, a filter is a component that can be used to pre-process and post-process requests and responses in a web application. Filters are executed before and after the request is handled by the controller. They can be used for various purposes such as: Logging and auditing Authentication and Authorization Encoding and Decoding Compression Caching A filter in Spring can be implemented as a class that implements the javax.servlet.Filter interface. This interface defines three methods: init(FilterConfig), doFilter(ServletRequest, ServletResponse, FilterChain), and destroy(). The init() method is called when the filter is first initialized, the doFilter() method is called for each request, and the destroy() method is called when the filter is being taken out of service. To use a filter in a Spring application, you can register the filter using FilterRegistrationBean or @WebFilter annotation. Once a filter is registered, it can be mapped to a specific URL pattern or servlet. The doFilter() method of a filter is where the actual processing takes place. The method is passed a ServletRequest, a ServletResponse, and a FilterChain object. The FilterChain object represents the chain of filters that are executed for a particular request. The doFilter() method can choose to pass the request and response to the next filter in the chain by calling the doFilter() method on the FilterChain object, or it can choose to handle the request itself and not pass the request and response to the next filter. In summary, filters are a powerful way to add pre-processing and post-processing to requests and responses in a Spring web application. They can be used for various purposes such as logging, authentication, encoding, compression, and caching. A filter is a class that implements the javax.servlet.Filter interface, it can be registered using FilterRegistrationBean or @WebFilter annotation, and it can be mapped to a specific URL pattern or servlet. What is the Spring-MVC flow? Spring MVC is a popular web framework for building Java web applications. It provides a Model-View-Controller architecture that separates the application logic into three components: the model, the view, and the controller. The Spring MVC flow involves the following steps: Client sends a request: The user sends a request to the Spring MVC application through a browser or any other client application. DispatcherServlet receives the request: The DispatcherServlet is a central controller in the Spring MVC architecture. It receives the request from the client and decides which controller should handle the request. HandlerMapping selects the appropriate controller: The HandlerMapping component maps the request URL to the appropriate controller based on the URL pattern configured in the Spring configuration file. Controller processes the request: The controller handles the request and performs the necessary processing logic. It may interact with the model component to retrieve data or update the data. Model updates the data: The model component manages the data and provides an interface for the controller to retrieve or update the data. ViewResolver selects the appropriate view: The ViewResolver component maps the logical view name returned by the controller to the actual view template. View renders the response: The view template is rendered to generate the response. It may include data from the model component. DispatcherServlet sends the response: The DispatcherServlet sends the response back to the client through the appropriate view technology, such as JSP, HTML, or JSON. The Spring MVC flow is a cyclical process, as the client may send additional requests to the application, and the cycle repeats. Can singleton bean scope handle multiple parallel requests? A singleton bean in Spring has a single instance that is shared across all requests, regardless of the number of parallel requests. This means that if two requests are processed simultaneously, they will share the same bean instance and access to the bean's state will be shared among the requests. However, it's important to note that if the singleton bean is stateful, and the state is shared among requests, this could lead to race conditions and other concurrency issues. For example, if two requests are trying to modify the same piece of data at the same time, it could lead to data inconsistencies. To avoid these issues, it's important to make sure that any stateful singleton beans are designed to be thread-safe. One way to do this is to use synchronization or other concurrency control mechanisms such as the synchronized keyword, Lock or ReentrantLock classes, or the @Transactional annotation if the bean is performing database operations. On the other hand, if the singleton bean is stateless, it can handle multiple parallel requests without any issues. It can be used to provide shared functionality that doesn't depend on the state of the bean. In conclusion, a singleton bean can handle multiple parallel requests, but it's important to be aware of the state of the bean and to ensure that it's designed to be thread-safe if it has shared state. Tell me the Design pattern used inside the spring framework. The Spring Framework makes use of several design patterns to provide its functionality. Some of the key design patterns used in Spring are: Inversion of Control (IoC): This pattern is used throughout the Spring Framework to decouple the application code from the framework and its components. The IoC container is responsible for managing the lifecycle of beans and injecting dependencies between them. Singleton: A singleton pattern is used to ensure that there is only one instance of a bean created in the Spring IoC container. The singleton pattern is used to create a single instance of a class, which is shared across the entire application. Factory: The factory pattern is used in Spring to create objects of different classes based on the configuration. Spring provides a factory pattern to create beans, which is based on the factory method design pattern. Template Method: The template method pattern is used in Spring to provide a common structure for different types of operations. Spring provides several template classes such as JdbcTemplate, Hibernate Template, etc. that provide a common structure for performing database operations. Decorator: The decorator pattern is used in Spring to add additional functionality to existing beans. The Spring AOP (Aspect-Oriented Programming) module uses the decorator pattern to add additional functionality to existing beans through the use of proxies. Observer: The observer pattern is used in Spring to notify other beans of changes to the state of a bean. Spring provides the ApplicationEvent and ApplicationListener interfaces, which can be used to implement the observer pattern. Command: The command pattern is used in Spring to encapsulate the execution of a particular piece of code in a command object. This pattern is used in Spring to create reusable and testable code. Façade: The façade pattern is used in Spring to simplify the interface of a complex system. The Spring Framework uses the façade pattern to provide a simplified interface for interacting with its components. These are just a few examples of the design patterns used in Spring, there are many more. Spring framework makes use of these patterns to provide a consistent and simple way to build applications, making it easier to manage complex systems. Is singleton bean scope thread-safe? By default, a singleton bean in Spring is thread-safe, as only one instance of the bean is created and shared among all requests. However, it's important to note that the thread-safety of a singleton bean depends on the implementation of the bean and the way it's being used. If the singleton bean is stateless, it can handle multiple parallel requests without any issues, as it does not maintain any state. If the singleton bean is stateful, and the state is shared among requests, it could lead to race conditions and other concurrency issues if not designed properly. For example, if two requests are trying to modify the same piece of data at the same time, it could lead to data inconsistencies. To avoid these issues, it's important to make sure that any stateful singleton beans are designed to be thread-safe by using synchronization or other concurrency control mechanisms such as the synchronized keyword, Lock or ReentrantLock classes, or the @Transactional annotation if the bean is performing database operations. In summary, a singleton bean is thread-safe by default, but the thread-safety of a singleton bean depends on the implementation of the bean and the way it's being used. If the bean is stateless it can handle multiple parallel requests without issues, if it's stateful it should be designed to be thread-safe in order to handle multiple parallel requests correctly. How do factory design patterns work in terms of the spring framework? In Spring, the factory design pattern is used to create objects of different classes based on the configuration. The Spring IoC container uses the factory pattern to create beans, which is based on the factory method design pattern. The factory method is a design pattern that provides a way to create objects of different classes based on a factory interface. In Spring, the IoC container acts as the factory, and the factory interface is represented by the BeanFactory or ApplicationContext interfaces. The IoC container is responsible for creating and managing the lifecycle of beans. When you define a bean in the configuration, the IoC container will use the factory pattern to create an instance of the bean. The IoC container will then manage the lifecycle of the bean, including injecting dependencies, initializing the bean, and destroying the bean when it is no longer needed. Here's an example of how you can define a bean in Spring using the factory design pattern: @Configuration public class MyConfig { @Bean public MyService myService() { return new MyService(); } } In this example, the myService() method is annotated with @Bean. This tells Spring to create an instance of the MyService class when the IoC container is created. The IoC container will use the factory pattern to create the instance and manage its lifecycle. Another way to use factory pattern in spring is to use FactoryBean interface, which allows you to create beans that are created by a factory method, it's a factory of bean. The FactoryBean interface defines a single method, getObject(), which returns the object that should be exposed as the bean in the Spring application context. In summary, the factory design pattern is used in the Spring Framework to create objects of different classes based on the configuration. The Spring IoC container acts as the factory, and the factory interface is represented by the BeanFactory or ApplicationContext interfaces, creating and managing the lifecycle of beans, and also can be used by implementing FactoryBean interface to create beans in a factory method. How the proxy design pattern is used in spring? The proxy design pattern is used in Spring to add additional functionality to existing objects. The Spring Framework uses the proxy pattern to provide AOP (Aspect-Oriented Programming) functionality, which allows you to add cross-cutting concerns, such as logging, security, and transaction management, to your application in a modular and reusable way. In Spring, AOP proxies are created by the IoC container, and they are used to intercept method calls made to the target bean. This allows you to add additional behaviour, such as logging or security checks, before or after the method call is made to the target bean. AOP proxies are created using one of three proxy types: JDK dynamic proxies, CGLIB proxies, or AspectJ proxies. JDK dynamic proxies: This is the default proxy type in Spring, and it is used to proxy interfaces. CGLIB proxies: This proxy type is used to proxy classes, and it works by creating a subclass of the target bean. AspectJ proxies: This proxy type uses the AspectJ library to create proxies, and it allows you to use AspectJ pointcuts and advice in your application. Spring uses the proxy pattern to provide AOP functionality by generating a proxy object that wraps the target bean. The proxy object will intercept method calls made to the target bean, and it will invoke additional behavior, such as logging or security checks, before or after the method call is made to the target bean. Here's an example of how you can use Spring AOP to add logging to a bean: @Aspect @Component public class LoggingAspect { @Before(\"execution(* com.example.service.*.*(..))\") public void logBefore(JoinPoint joinPoint) { log.info(\"Started method: \" + joinPoint.getSignature().getName()); } } In this example, the LoggingAspect class is annotated with @Aspect and @Component to make it a Spring bean. The @Before annotation is used to specify that the logBefore() method should be executed before the method call is made to the target bean. The logBefore() method uses the JoinPoint argument to log the name of the method that is being called. In summary, the proxy design pattern is used in Spring to add additional functionality to existing objects by intercepting method calls made to the target bean and invoke additional behavior before or after the method call using AOP functionality. The proxy objects are generated by the IoC container using one of three proxy types: JDK dynamic proxies, CGLIB proxies, or AspectJ proxies. What if we call singleton bean from prototype or prototype bean from singleton How many objects returned? When a singleton bean is called from a prototype bean or vice versa, the behavior depends on how the dependency is injected. If a singleton bean is injected into a prototype bean, then each time the prototype bean is created, it will receive the same instance of the singleton bean. This is because the singleton bean is only created once during the startup of the application context, and that same instance is then injected into the prototype bean each time it is created. On the other hand, if a prototype bean is injected into a singleton bean, then each time the singleton bean is called, a new instance of the prototype bean will be created. This is because prototype beans are not managed by the container, and a new instance is created each time a dependency is injected. Here's an example to illustrate this: @Component @Scope(\"singleton\") public class SingletonBean { // code for singleton bean } @Component @Scope(\"prototype\") public class PrototypeBean { @Autowired private SingletonBean singletonBean; // code for prototype bean } In this example, when a prototype bean is created and injected with the singleton bean, it will receive the same instance of the singleton bean each time it is created. However, if the singleton bean is created and injected with the prototype bean, it will receive a new instance of the prototype bean each time it is called. It's important to note that mixing singleton and prototype scopes in a single application context can lead to unexpected behavior and should be avoided unless necessary. It's best to use one scope consistently throughout the application context. What is the difference between Spring boot and spring? why choose one over the other? Here are some reasons to choose Spring Framework: You need a comprehensive set of features and capabilities for your application. You want to build a modular application where you can pick and choose only the components that you need. You need a high degree of flexibility and customization in your application. Here are some reasons to choose Spring Boot: You want to quickly set up a stand-alone Spring application without needing to do a lot of configuration. You want to take advantage of pre-configured dependencies and sensible defaults. You want to easily deploy your application as a self-contained executable JAR file. Overall, both Spring and Spring Boot are powerful frameworks that can be used to build enterprise-level applications. The choice between them depends on the specific needs of your application and the level of flexibility and customization that you require. How can you create a prototype bean? A prototype bean in Spring can be created by setting the \"scope\" attribute of the bean definition to \"prototype\". This tells the Spring framework to create a new instance of the bean each time it is requested from the application context, instead of returning a single shared instance as is the case with a singleton-scoped bean. Here's an example of how you can create a prototype bean using XML configuration: <bean id=\"prototypeBean\" class=\"com.example.PrototypeBean\" scope=\"prototype\"> <!-- property definitions go here --> </bean> And here's an example using Java configuration: @Configuration public class AppConfig { @Bean(name=\"prototypeBean\") @Scope(\"prototype\") public PrototypeBean prototypeBean() { return new PrototypeBean(); } } In both cases, each time you request the prototype bean from the application context, you will get a new instance of the PrototypeBean class. What is Method overloading and method overriding? Where it has been used in the spring framework? Method overloading and method overriding in the Spring Framework: Method overloading and method overriding are used extensively in the Spring Framework. For example, the @Autowired annotation can be used to autowire dependencies into a Spring bean. The @Autowired annotation can be overloaded to support different types of dependencies, such as field dependencies, constructor dependencies, and setter dependencies. Another example of method overloading in the Spring Framework is the getBean() method of the ApplicationContext interface. The getBean() method can be overloaded to accept different types of parameters, such as the bean name, the bean type, and the bean qualifiers. Method overriding is also used extensively in the Spring Framework. For example, the AbstractBeanDefinitionReader class defines a loadBeanDefinitions() method that is overridden by different bean definition readers, such as the ClassPathBeanDefinitionScanner class and the XmlBeanDefinitionReader class. If I want my class should not be extended and the instance cannot be created by other classes then how to declare class?",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "How to ensure that token has not been tampered with?",
    "answer": "To make sure that a JWT token has not been tampered with, you need to check its signature. The signature of a JWT token is created by taking the encoded header, the encoded payload, a secret, and the algorithm specified in the header, and signing that. The signature is then added to the JWT token as the third part. When the token is received by the server, the server will decode the token to retrieve the header and payload, and then it will re-create the signature using the same secret and algorithm specified in the header. If the re-created signature matches the signature in the token, it means that the token has not been tampered with. But if the re- created signature does not match the signature in the token, it means that the token has been tampered with. It's important to note that, keeping the secret key safe is important to the security of the JWT token, it should be stored in a secure location and should be rotated regularly. Also, JWT tokens should be used over an SSL/TLS-secured connection to prevent man-in-the-middle attacks, and you should also validate the claims within the JWT token, such as expiration time, audience, and issuer. How to use @ControlAdvice for the exception handler? @ControllerAdvice is a Spring annotation that is used to create a global exception handler for your application. It can be used to apply the same exception handling logic across multiple controllers. It can be used to centralize the handling of exceptions that are thrown by multiple controllers in your application. When you use @ControllerAdvice on a class, Spring will automatically detect it and use it as a global exception handler. You can then use the @ExceptionHandler annotation on a method inside the @ControllerAdvice class to specify the type of exception that the method should handle. Here is an example of how you can use @ControllerAdvice and @ExceptionHandler to create a global exception handler: @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(CustomException.class) public ResponseEntity<ErrorResponse> handleCustomException(CustomException ex) { ErrorResponse error = new ErrorResponse(\"Error\", ex.getMessage()); return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST); } } In the example above, the @ControllerAdvice annotation is used to indicate that this class is a global exception handler. The @ExceptionHandler annotation is used to specify that the handleCustomException method should handle CustomException exceptions. The method takes the CustomException object as an argument and returns a ResponseEntity object with a custom error response. You can also use @ControllerAdvice to handle exceptions thrown by methods in a specific package. You can do this by providing a basePackages or value attribute on the @ControllerAdvice annotation, like this: @ControllerAdvice(basePackages = \"com.example.myapp.controllers\") This will only apply the exception handling logic to controllers in the specified package, while all other controllers will not be affected by this. You can use @ControllerAdvice in combination with @RestControllerAdvice to handle exceptions thrown by rest controllers specifically, or with @ExceptionHandler on a method inside a controller to handle specific exceptions for a specific controller. How to handle exceptions in Spring boot applications? What are the best practices for doing so? In Spring Boot, you can handle exceptions in several ways, here are a few options: Global Exception Handling: You can create a global exception handler class that handles exceptions that are thrown by any controller in the application. You can use the @ControllerAdvice annotation to create a global exception handler and the @ExceptionHandler annotation to specify which exceptions the handler should handle. @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ResponseEntity<Object> handleException(Exception ex) { // handling logic return new ResponseEntity<>(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } } Local Exception Handling: You can handle exceptions within the controller methods where they occur. You can use the try-catch block or the @ExceptionHandler annotation to handle exceptions locally. @RestController public class EmployeeController { @GetMapping(\"/employees/{id}\") public Employee getEmployeeById(@PathVariable Long id) { try { return employeeService.getEmployeeById(id); } catch (EmployeeNotFoundException ex) { throw new ResponseStatusException(HttpStatus.NOT_FOUND, ex.getMessage()); } } } Custom Exception Handling: You can create custom exceptions that extend the built-in exceptions, and then handle them in the global or local exception handlers. @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"Employee not found\") public class EmployeeNotFoundException extends RuntimeException { } How to use a custom exception handler in Spring Boot? In Spring Boot, you can use a custom exception handler to handle specific exceptions that may be thrown by your application. To create a custom exception handler, you will need to create a class that implements the HandlerExceptionResolver interface or extends the AbstractHandlerExceptionResolver class and override the resolveException method. Here's an example of a custom exception handler class: @ControllerAdvice public class CustomExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(CustomException.class) public final ResponseEntity<ErrorResponse> handleCustomException(CustomException ex, WebRequest request) { ErrorResponse error = new ErrorResponse(ex.getMessage(), request.getDescription(false)); return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST); } } The @ControllerAdvice annotation is used to indicate that the class is a global exception handler. The @ExceptionHandler annotation is used to specify the type of exception that this method should handle. The CustomException in the example above is a custom exception that you have defined in your application. The handleCustomException method takes the CustomException object and the WebRequest object as arguments, and returns a ResponseEntity object with a custom error response. You can also create a class that extends ResponseEntityExceptionHandler which is a convenient base class for handling exceptions and providing responses. Then in your configuration class, you should register your custom exception handler with Spring by using the @Autowired annotation. @Configuration public class RestConfiguration { @Autowired private CustomExceptionHandler customExceptionHandler; @Bean public HandlerExceptionResolver handlerExceptionResolver() { return customExceptionHandler; } } With this, your custom exception handler will be registered and used by Spring to handle exceptions in your application. Write an endpoint in spring boot for getting and saving employees with syntax. In Spring Boot, you can create endpoints for getting and saving employees using controllers and services. Here's an example of how you could create these endpoints: EmployeeController: This class defines the REST endpoints for getting and saving employees. @RestController @RequestMapping(\"/employees\") public class EmployeeController { private final EmployeeService employeeService; public EmployeeController(EmployeeService employeeService) { this.employeeService = employeeService; } @GetMapping public List<Employee> getAllEmployees() { return employeeService.getAllEmployees(); } @GetMapping(\"/{id}\") public Employee getEmployeeById(@PathVariable Long id) { return employeeService.getEmployeeById(id); } @PostMapping public Employee saveEmployee(@RequestBody Employee employee) { return employeeService.saveEmployee(employee); } } The @RestController annotation is used to indicate that the class is a controller and will handle HTTP requests. The @RequestMapping annotation is used to map the endpoint to a specific URL. The @GetMapping and @PostMapping annotations are used to indicate that the methods handle GET and POST requests, respectively. The @PathVariable annotation is used to extract a path variable from the URL, and the @RequestBody annotation is used to extract the body of a POST request. EmployeeService: This class defines the business logic for getting and saving employees. @Service public class EmployeeService { private final EmployeeRepository employeeRepository; public EmployeeService(EmployeeRepository employeeRepository) { this.employeeRepository = employeeRepository; } } CHAPTER 8: MICROSERVICE What is Microservice? Microservice, aka Microservice Architecture, is an architectural style that structures an application as a collection of small autonomous services, modelled around a business domain. In Microservice architecture, each service is self-contained and implements a single business capability. Features of Microservice: Decoupling - Services within a system are largely decoupled, so the application as a whole can be easily built, altered, and scaled. Componentization - Microservice are treated as independent components that can be easily replaced and upgraded. Business Capabilities - Microservice are very simple and focus on a single capability. Autonomy - Developers and teams can work independently of each other, thus increasing speed. Continuous Delivery - Allows frequent releases of software through systematic automation of software creation, testing, and approval. Responsibility - Microservice do not focus on applications as projects. Instead, they treat applications as products for which they are responsible. Decentralized Governance - The focus is on using the right tool for the right job. That means there is no standardized pattern or any technology pattern. Developers have the freedom to choose the best useful tools to solve their problems. Agility - Microservice support agile development. Any new feature can be quickly developed and discarded again. What is the advantage of Microservice over monolithic architecture? Challenges of monolithic architecture Inflexible - Monolithic applications cannot be built using different technologies. Unreliable - If even one feature of the system does not work, then the entire system does not work. Unscalable - Applications cannot be scaled easily since each time the application needs to be updated, the complete system has to be rebuilt. Blocks Continuous Development - Many features of an application cannot be built and deployed at the same time. Slow Development - Development in monolithic applications takes a lot of time to be built since each and every feature has to be built one after the other. Not Fit for Complex Applications - Features of complex applications have tightly coupled dependencies. What is the disadvantage of Microservice architecture Complexity: The overall architecture can become complex, especially when dealing with the coordination of many small services. Increased operational overhead: Managing and deploying many small microservices can increase operational overhead, such as monitoring and testing. Network latency: Communication between microservices can add network latency and reduce performance if not properly optimized. Inter-service dependencies: Inter-service dependencies can become complex and difficult to manage, especially when dealing with many small services. Difficulties in testing: Testing can become more complex and time-consuming with a large number of microservices. Under what circumstances is the Microservice architecture are not preferable to you? While microservices have several benefits, there are some circumstances in which they may not be the best option. Here are some situations in which microservices might not be preferable: Small projects: Microservices architecture is generally recommended for large and complex systems. If your project is small and simple, then it might not be worth the added complexity of implementing a microservices architecture. Limited resources: Implementing a microservices architecture can require a significant investment of resources, including time, money, and expertise. If you don't have access to the necessary resources, it might not be feasible to use a microservices architecture. High latency: Since microservices communicate with each other over a network, there can be latency issues. If low latency is critical to your application, then a monolithic architecture might be a better choice. Interdependent services: If your services are heavily interdependent, then implementing a microservices architecture might not provide significant benefits. It could lead to additional complexity and overhead without delivering much value. Development team experience: A microservices architecture requires specialized knowledge and experience to design and implement effectively. If your development team is not experienced in microservices, it might not be the best option. What are the design principles of Microservice? Modularity: Services should be self-contained and should have a single, well-defined purpose. Scalability: Services should be able to scale independently to handle increasing load. Decentralization: The system should be decentralized, allowing for loosely-coupled services. High Availability: Services should be designed to be highly available to ensure system reliability. Resilience: Services should be designed to handle failures gracefully. Data Management: Services should manage their own data and should not share a common database. Statelessness: Services should be stateless to allow for easy scaling and caching. Independent Deployment: Services should be deployable independently of other services. Observability: The system should have built-in monitoring and logging capabilities to allow for visibility into system behaviour. Automation: Deployment, testing, and scaling should be automated as much as possible. Do you know the 12-factor methodology to build a Microservice? The 12-factor methodology is a set of guidelines for building scalable, maintainable, and easily deployable software-as-a-service (SaaS) applications. It's particularly relevant for building Microservice -based applications, since Microservice represent a distributed system and can benefit from the principles of the 12-factor methodology. Here are the 12 factors: Codebase: One codebase per app, with multiple deploys. Dependencies: Explicitly declare and isolate dependencies. Config: Store config in the environment. Backing services: Treat backing services as attached resources. Build, release, run: Strictly separate build and run stages. Processes: Execute the app as one or more stateless processes. Port binding: Export services via port binding. Concurrency: Scale out via the process model. Disposability: Maximize robustness with fast start-up and graceful shutdown. Dev/prod parity: Keep development, staging, and production as similar as possible. Logs: Treat logs as event streams. Admin processes: Run admin/management tasks as one-off processes. By following the principles of the 12-factor methodology, you can build microservices that are scalable, maintainable, and easily deployable. This can help you to deliver high-quality applications that meet the needs of your customers and users. Why are Microservice stateless? Microservice are designed to be stateless for several reasons: Scalability: Stateless Microservice can be easily scaled horizontally by adding more instances, without having to worry about preserving state across instances. This makes it easier to handle increased traffic and load balancing. Resilience: Stateless microservices can fail without affecting the system as a whole, since they don't rely on stored state. When a stateless microservice fails, another instance can simply take its place, preserving the overall health of the system. Portability: Stateless microservices can be deployed to any environment without having to worry about preserving state. This makes it easier to move microservices between environments, such as between development and production, or between data centres. Simplicity: Stateless microservices are simpler to implement, maintain, and test, since they don't have to manage state. This makes it easier to build, deploy, and manage a system made up of many microservices. In summary, stateless microservices provide greater scalability, resilience, portability, and simplicity compared to stateful microservices. However, there may be cases where stateful microservices are necessary, for example, when dealing with user sessions or long-running transactions. In these cases, it's important to carefully manage state and ensure that stateful microservices are still scalable, resilient, and portable. What is the advantage of Microservice using Spring Boot Application + Spring Cloud? Advantages of Microservice over Spring Boot Application + Spring Cloud: Improved Scalability: Microservice architecture allows for better scalability by allowing services to be developed, deployed and scaled independently. Faster Time-to-Market: By breaking down a monolithic application into smaller, self-contained services, development teams can work in parallel and iterate more quickly. Resilience: Microservice provide improved resilience by allowing services to fail independently without affecting the entire system. Better Resource Utilization: Microservice allow for better resource utilization as services can be deployed on the best-suited infrastructure. Increased Flexibility: Microservice architecture provides increased flexibility as new services can be added or existing services can be updated without affecting the entire system. Improved Maintainability: Microservice provide improved maintainability by reducing the complexity of the overall system and making it easier to identify and fix problems. Technology Heterogeneity: Microservice architecture enables technology heterogeneity, allowing for the use of different technologies for different services. Improved Team Collaboration: Microservice architecture can improve team collaboration by breaking down a monolithic application into smaller, self-contained services that can be developed by smaller, cross-functional teams. How to share a database with multiple microservices? When implementing a microservices architecture, sharing a database between multiple microservices can be a common approach. Here are some guidelines on how to do it effectively: Design the database schema with the microservices in mind: To ensure that the database can be effectively shared between multiple microservices, it's important to design the schema with the microservices architecture in mind. This means creating tables and columns that are specific to the microservices that will be using them, and avoiding dependencies that would create coupling between microservices. Use a database migration tool: To manage the changes in the database schema over time, it's important to use a database migration tool. This will allow you to apply changes to the database schema in a controlled way, ensuring that all microservices are compatible with the new schema. Implement a database access layer: To abstract the database access logic from the microservices, it's recommended to implement a database access layer. This layer should handle all database operations and provide a simple interface for the microservices to interact with. Use a shared database instance: To ensure that all microservices are accessing the same data, it's important to use a shared database instance. This can be a single database server or a cluster of servers, depending on the requirements of the system. Implement data isolation: To ensure that one microservice does not unintentionally modify data that belongs to another microservice, it's recommended to implement data isolation. This can be done by using different database schemas or database instances for each microservice, or by using row-level security features to restrict access to specific data. Monitor database performance: When sharing a database between multiple microservices, it's important to monitor the performance of the database. This can be done by monitoring query execution times, database locks, and resource usage to ensure that the database is performing optimally and not causing performance issues for the microservices. Regulatory requirements: Some industries have strict regulations around data privacy and security. Implementing a microservices architecture might not be feasible if it does not meet the regulatory requirements of your industry. Do you know Distributed tracing? What is its us? Yes, distributed tracing is a technique used in distributed systems to track and monitor the flow of a request or transaction across multiple services or microservices. It is a way to gain visibility into complex, distributed architectures and to diagnose performance and reliability issues. Distributed tracing involves instrumenting each service in a distributed system to generate and propagate a unique identifier for each incoming request or transaction. This identifier is typically called a \"trace ID\", and it is used to tie together all the individual spans or segments that make up a single transaction. As a transaction flows through the different services and components of a distributed system, each component records information about its part of the transaction in a \"span\" or \"segment\". Each span includes information such as timing data, error codes, and other relevant metadata. The spans are then collected and correlated across all the services that participated in the transaction, creating a trace of the entire transaction across the distributed system. Distributed tracing is used to understand the performance of a distributed system, to diagnose issues with specific transactions, and to identify the root causes of failures or errors. By correlating the spans across different services, it is possible to visualize the entire flow of a request and to pinpoint bottlenecks, errors, or other issues. Distributed tracing tools typically provide visualization tools, alerting mechanisms, and other features to help operators and developers understand the health and performance of their distributed systems. Distributed tracing can be implemented using open-source tools like Jaeger, Zipkin, and OpenTelemetry, or via commercial products from cloud providers and third-party vendors. How distributed tracing is done in Microservice? Distributed tracing is a technique used to track the flow of a request as it travels across multiple Microservice in a distributed system. It helps to understand the performance and behaviour of a Microservice architecture by providing visibility into the interactions between Microservice. Here are the steps involved in distributed tracing in Microservice: Instrumentation: Each Microservice is instrumented with tracing information, typically by adding trace headers to the requests sent between Microservice. This information can include a unique trace identifier, the name of the Microservice, and timing information. Propagation: The trace information is propagated along with each request as it flows between Microservice. This allows the trace information to be captured and recorded by each Microservice that handles the request. Collection: The trace information is collected by a tracing system, which can be a standalone component or integrated into a log management or monitoring tool. Analysis: The collected trace information is analysed to gain insights into the performance and behaviour of the Microservice. This can include identifying bottlenecks, tracking the flow of requests through the system, and measuring the response time of individual Microservice. Visualization: The results of the analysis can be visualized in a way that helps to understand the relationships between microservices and identify any issues or inefficiencies. Distributed tracing can be performed using dedicated tracing tools, such as Zipkin, Jaeger, or Appdash, or integrated into existing monitoring and log management tools, such as ELK or Datadog. How to connect internal and external services in microservices. There are various designs that can be used to connect internal and external services in a microservice architecture, depending on the specific requirements of the system. Some common patterns are: API Gateway: An API gateway acts as a single entry point for all external requests, forwarding them to the appropriate microservice for handling. The gateway can also perform tasks such as authentication, rate limiting, and caching. Service Discovery: In this pattern, Microservice register themselves with a central registry, and clients use the registry to find the location of the Microservice they need to interact with. This can be done using a technology such as DNS or a dedicated service discovery tool like Eureka or Consul. Load Balancer: A load balancer distributes incoming requests to multiple instances of a Microservice, improving reliability and scalability. Load balancing can be performed by a dedicated load balancing tool, or it can be built into the API gateway. Circuit Breaker: A circuit breaker is a pattern that helps prevent cascading failures in a Microservice architecture by adding resilience to communication between Microservice. The circuit breaker acts as a proxy between the client and the Microservice, monitoring the health of the Microservice and failing over to a backup instance if necessary. Event-Driven Architecture: In this pattern, Microservice communicate with each other using events, rather than direct requests. This can help decouple Microservice and reduce the coupling between them. These patterns can be combined and customized as needed to create a suitable solution for your specific use case. Which Microservice design pattern have you used so far and why? Service Registry: A Service Registry is a centralized directory that microservices can use to locate each other's endpoints. It helps with service discovery, load balancing, and failover, and makes it easier to manage a distributed system. Examples of service registries include Consul and Eureka. Circuit Breaker: A Circuit Breaker is a pattern that can help to prevent cascading failures in a distributed system. It monitors requests to a service and can \"trip\" the circuit when too many requests fail or when the service becomes unresponsive. When the circuit is tripped, subsequent requests can be immediately rejected or diverted to a fallback mechanism. API Gateway: An API Gateway is a centralized entry point for a set of microservices. It can handle authentication, rate limiting, request routing, and other cross-cutting concerns. The API Gateway helps to simplify the client-side by providing a unified interface to a set of Microservice. Event-Driven Architecture: An Event-Driven Architecture is a pattern that involves using events to communicate between microservices. Instead of tightly coupling services through synchronous REST APIs, events can be used to decouple services and to provide more flexibility and scalability. CQRS: CQRS (Command Query Responsibility Segregation) is a pattern that involves separating the responsibility of handling read and write operations into separate services. It can help to simplify the design of a system by separating concerns and reducing complexity. It can also help to improve performance by allowing read and write operations to be optimized separately. Each of these patterns can help to improve the scalability, reliability, and maintainability of a microservice architecture. The choice of pattern will depend on the specific requirements and constraints of the system being developed. Which design patterns are used for database design in Microservice? Common design patterns used for database design in Microservice are: Database per Service: Each service has its own database, allowing for a high degree of independence and autonomy. Shared Database: A shared database is used by multiple services to store data that is commonly used across the system. Event Sourcing: The state of the system is stored as a series of events, allowing for better scalability and fault tolerance. Command Query Responsibility Segregation (CQRS): Queries and commands are separated, allowing for improved scalability and performance. Saga: A long-running transaction is broken down into smaller, autonomous transactions that can be executed by different services. Materialized View: A pre-computed view of data is used to provide fast access to commonly used data. API Composition: APIs are composed to provide a unified view of data from multiple services. Read Replicas: Read replicas are used to offload read requests from the primary database, improving performance and scalability. What is the SAGA Microservice pattern? SAGA is a Microservice Pattern: The Saga pattern is a design pattern used in distributed systems to manage long-running transactions involving multiple services. It is a way to ensure that these transactions maintain data consistency and integrity even in the face of failures and errors. In the Saga pattern, a transaction is divided into a series of smaller, more granular sub-transactions, also known as \"saga steps\", each of which can be executed independently by a single service. Each sub- transaction updates its own local data and sends messages to other services to trigger their corresponding sub-transactions. If a sub-transaction fails, the Saga pattern uses a compensating action to undo the changes made by the previous steps and maintain consistency across the entire transaction. This can be thought of as a kind of \"rollback\" mechanism for distributed transactions. The Saga pattern can be implemented in different ways depending on the specific system and requirements. One common approach is to use a choreography-based saga, where each service is responsible for executing its own sub-transactions and communicating with other services directly. Another approach is to use an orchestration-based saga, where a central coordinator service is responsible for executing and coordinating the different sub-transactions. The Saga pattern can be a powerful tool for managing long-running distributed transactions, but it also comes with some trade-offs. It can be more complex to implement than simpler transaction models, and it can require careful design and testing to ensure that it can handle all possible failure scenarios. However, in complex distributed systems where data consistency is critical, the Saga pattern can be a valuable tool for maintaining data integrity and avoiding data inconsistencies. Explain the CQRS concept? Command Query Responsibility Segregation (CQRS) is a design pattern that separates read and write operations in a system. This means that the operations that retrieve data (queries) are separated from the operations that update data (commands). The main idea behind CQRS is to improve performance by allowing the read and write operations to be optimized and scaled independently. The read operations can be optimized for read-heavy workloads, while the write operations can be optimized for write- heavy workloads. By separating read and write operations, CQRS also provides a higher degree of isolation and can simplify the implementation of complex business logic. Additionally, CQRS can improve the ability to handle concurrent access to data, allowing for better scalability and fault tolerance. CQRS is often used in Microservice architectures and event-driven systems, where different parts of the system can have different requirements for read and write operations. Which Microservice pattern will you use for read-heavy and write-heavy applications? For read-heavy applications, you may use the CQRS (Command Query Responsibility Segregation) pattern. This pattern separates the responsibilities of reading and writing data into separate microservices. The write-side microservice is responsible for handling updates and writes to the database, while the read-side microservice is responsible for serving up data for queries. By separating these responsibilities, you can scale each microservice independently based on the needs of your application. For example, you can scale up the read-side microservice to handle increased read traffic, or scale down the write-side microservice to handle lower write traffic. For write-heavy applications, you may use the Event Sourcing pattern. This pattern involves storing every change to the state of your application as an event. Each microservice can subscribe to these events and update its own state accordingly. This allows multiple microservices to collaborate and ensures that all changes are captured and recorded. In both cases, you can also consider using a message queue to handle asynchronous communication between the microservices, and a cache to improve performance for read-heavy applications. Explain the Choreography pattern in Microservice? Choreography in Microservice refers to the way in which services communicate and coordinate with each other without the need for a central authority or central point of control. Instead, each service is responsible for handling its own behaviour and communicating with other services as needed. In a choreographed system, services exchange messages or events to coordinate their behaviour. For example, one service might send an event to another service indicating that a certain action has taken place, and the receiving service can respond as necessary. The main advantage of choreography is that it provides a more decentralized and flexible system, where services can evolve and change independently. This can lead to improved scalability, as services can be added or removed without affecting the entire system. Additionally, choreography can improve reliability, as a failure in one service does not affect the rest of the system. Choreography is often used in event-driven systems and is an alternative to the centralized coordination provided by a central authority, such as a service registry or a centralized API gateway. What are the types of fault tolerance mechanisms in Spring Microservice? Spring framework provides several mechanisms for implementing fault tolerance in Microservice: Circuit Breaker: The Spring Cloud Netflix Hystrix library provides a circuit breaker implementation. The circuit breaker acts as a proxy between a Microservice and its dependencies. It monitors the health of the dependencies and opens the circuit if a certain number of failures occur within a defined time window. This prevents further failures and allows the Microservice to degrade gracefully. Load Balancing: Spring Cloud Netflix Ribbon provides client-side load balancing. It allows a Microservice to distribute incoming requests across multiple instances of a dependent Microservice. This helps to increase availability and resilience, since the Microservice can still function even if one of its dependencies fails. Retry: Spring Retry provides declarative control of retry behaviour. It allows a Microservice to automatically retry a failed request to a dependent Microservice, with configurable parameters such as maximum number of retries and back off policies. Timeouts: Spring Cloud Hystrix provides timeout functionality for dependent Microservice. It allows a Microservice to specify a timeout for a request, and fail fast if the dependent Microservice does not respond within the defined timeout period. Monitoring and Management: Spring Boot provides built-in support for monitoring and management of Microservice. This includes monitoring of application health, metrics, and logs, as well as management of the application lifecycle, such as starting and stopping the application. By using these fault tolerance mechanisms, you can build robust and resilient Microservice with Spring framework. This can help you to deliver high-quality applications that are able to withstand failures and handle high levels of traffic and load. What is circuit breaker pattern? What are examples of it? The Circuit Breaker pattern is a design pattern used to prevent failures in a distributed system by adding a layer of protection between the calling service and the called service. The Circuit Breaker acts as a switch that can be opened or closed based on the health of the called service. Here's a simple example of how you can implement the Circuit Breaker pattern in the Spring framework: Create a Circuit Breaker class that implements the HystrixCircuitBreaker interface: @Service public class MyCircuitBreaker implements HystrixCircuitBreaker { @Autowired private MyService myService; @HystrixCommand(fallbackMethod = \"defaultResponse\") public String callService() { return myService.doSomething(); } public String defaultResponse() { return \"Default Response\"; } } In this example, we use the @HystrixCommand annotation to wrap the call to the MyService class in a circuit breaker. If the call to MyService fails, the defaultResponse method will be called as a fallback. Configure the Hystrix Circuit Breaker in your Spring configuration: @Configuration @EnableCircuitBreaker public class CircuitBreakerConfig { @Bean public MyCircuitBreaker myCircuitBreaker() { return new MyCircuitBreaker(); } } In this example, we enable the Circuit Breaker pattern using the @EnableCircuitBreaker annotation. When the callService method is called, the Hystrix Circuit Breaker will monitor the health of the MyService class and, if necessary, open the circuit and fall back to the defaultResponse method. This helps to prevent failures from propagating throughout the system and causing widespread disruption. Explain the annotations used to implement circuit breaker in spring boot? In Spring Boot, circuit breakers can be implemented using the spring-cloud-starter-circuitbreaker library, which provides support for several different circuit breaker implementations, including Hystrix. To use the circuit breaker in Spring Boot, you can use the following annotations: @HystrixCommand: This annotation is used to wrap a method with a circuit breaker. When the circuit breaker trips, the method will return a fallback response instead of the normal response. @HystrixProperty: This annotation is used to configure the properties of the circuit breaker, such as the timeout and the number of failures before the circuit breaker trips. Here is an example of how to use the @HystrixCommand and @HystrixProperty annotations to implement a circuit breaker in Spring Boot: @Service public class MyService { @HystrixCommand(fallbackMethod = \"fallback\", commandProperties = { @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"2000\"), @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"5\"), @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\"), @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"5000\") }) public String callDependency() { // Call the dependent service } public String fallback() { // Return a fallback response } } Which library have you used to implement circuit breaker in spring boot? There are several libraries and frameworks available for implementing circuit breakers in various programming languages. Some of the popular ones include: Hystrix (Java): A library developed by Netflix, it is one of the most popular circuit breaker implementations for Java. Resilience4j (Java): An lightweight, easy-to-use library for fault tolerance in Java. Polly (.NET): A library for .NET that provides support for circuit breakers, timeouts, and retries. Ruby Circuit Breaker (Ruby): A library for Ruby that implements the circuit breaker pattern. Go-Hystrix (Go): A Go implementation of the Hystrix library, providing circuit breaker functionality for Go applications. Elixir Circuit Breaker (Elixir): An implementation of the circuit breaker pattern for Elixir applications. These libraries provide a convenient and easy-to-use way to implement circuit breakers in your applications, allowing you to improve the resilience and fault tolerance of your system. How to call methods Asynchronously, in the spring framework how can we do that? In the Spring framework, you can call methods asynchronously using the @Async annotation. The @Async annotation marks a method as being executed asynchronously by a task executor. Here's an example of how you can use the @Async annotation: @Service public class MyService { @Async public CompletableFuture<String> doSomethingAsync() { // Perform some task asynchronously return CompletableFuture.completedFuture(\"Task completed\"); } } In order to use the @Async annotation, you need to configure a task executor in your Spring configuration. Here's an example: @Configuration @EnableAsync public class AsyncConfig { @Bean(name = \"taskExecutor\") public Executor taskExecutor() { return Executors.newFixedThreadPool(10); } } In this example, we create a task executor using a FixedThreadPool with a pool size of 10. When the doSomethingAsync method is called, it will be executed asynchronously by the task executor. The CompletableFuture returned by the method can be used to retrieve the result of the asynchronous task when it becomes available. How to call another microservice asynchronously? To call another microservice asynchronously, you can use a message queue. The basic flow is: One microservice produces a message and sends it to a message queue. Another microservice consumes the message from the queue and performs the desired action. The message queue acts as a buffer between the two microservices, allowing them to communicate asynchronously. This approach has several benefits: Loose coupling: Microservices can communicate with each other without having to know the details of the other microservice's implementation. Scalability: The message queue can be scaled independently of the microservices, allowing for improved scalability. Resilience: If one microservice fails, the message queue can hold the messages until the other microservice is able to process them. There are several message queues available, such as RabbitMQ, Apache Kafka, and ActiveMQ, and you can choose the one that best fits your needs. To use a message queue, you need to write code to produce and consume messages from the queue. How to communicate between two microservices? There are several ways to communicate between two microservices: HTTP/REST: The most common way of communication between microservices is through REST APIs over HTTP. Microservices can expose a RESTful API that other microservices can use to request data or perform actions. Message Queueing: Microservices can communicate with each other asynchronously through a message queue such as RabbitMQ or Apache Kafka. Microservices can publish messages to the queue and other microservices can subscribe to the queue and receive messages. Event-Driven Architecture: Microservices can use event-driven architecture to communicate with each other. In this approach, microservices can publish events to a centralized event bus and other microservices can subscribe to these events and react to them. gRPC: gRPC is a high-performance, open-source framework for building microservices. It uses a binary format for communication between microservices and can be used for both synchronous and asynchronous communication. Regardless of the communication method chosen, it's important to ensure that communication between microservices is secure and that only authorized microservices are able to communicate with each other. How to restrict the Microservice from calling the other Microservice? (Let's say there are A, B, C, D, and E-services and I want to restrict A form calling C, D, and E. how will you do that?) One way to restrict a microservice from calling another microservice is to use API gateway to enforce the access control rules. The API gateway can be configured to only allow authorized microservices to make API requests to other microservices. Additionally, you can use authentication and authorization mechanisms such as OAuth, JWT, or API keys to secure the API endpoints and ensure that only authorized microservices are able to access them. Another way to restrict microservice access is to use network segmentation and firewall rules to restrict network access between microservices. This can help prevent unauthorized microservices from accessing other microservices on the network. Finally, you can also use code-level access control in each microservice, for example by using role-based access control (RBAC), to control which microservices can call which APIs and what actions they can perform. How to save your username password in the spring boot- based Microservice application? (What is the best practice) In a Spring Boot-based microservices application, it is generally considered best practice to store sensitive information such as username and password in a secure location, separate from the application code. There are several ways to achieve this, here are a few options: Environment Variables: You can store the username and password as environment variables on the machine where the microservice is running. This approach is considered secure as environment variables are typically stored outside of the file system and are not accessible to unauthorized users. Configuration files: You can store the username and password in a separate configuration file that is encrypted and stored in a secure location. The configuration file can then be accessed by the microservice at runtime. Hashicorp Vault: You can use Hashicorp Vault to securely store, manage, and access sensitive data such as username and password. Vault provides a centralized and secure way to store and access secrets. External Service: You can also use external services like AWS Secrets Manager, Azure KeyVault, Google Cloud Key Management Service (KMS) to store and manage your credentials. It's important to note that, whatever the approach you choose, you should make sure that the sensitive information is encrypted and stored in a secure location that is only accessible to authorized users and services. Also, you should use the best practice of never hardcoding the sensitive information in the code, this could help to avoid security issues, and make it easy to rotate and manage your credentials. CHAPTER 9: MEMORY MANAGEMENT IN JAVA What is Memory management in Java? Memory management in Java is handled by the Java Virtual Machine (JVM), which automatically manages the allocation and deallocation of memory for objects. The JVM uses a technique called garbage collection to periodically scan the heap (the area of memory where objects are stored) and identify objects that are no longer being used by the application. These objects are then removed from memory, freeing up space for new objects. Java has several different garbage collectors that can be used, each with its own set of features and trade-offs. The default garbage collector in most JVMs is called the \"Serial GC\", which is a basic garbage collector that runs serially on a single thread. Other garbage collectors include the \"Parallel GC\", which uses multiple threads to speed up garbage collection, and the \"G1 GC\", which is designed for large heap sizes and can help reduce the frequency of long pauses caused by garbage collection. Java also provides a way for developers to explicitly manage memory through the use of manual memory management techniques such as the new keyword and the finalize() method. However, it's not recommended to use manual memory management in Java, as it can lead to memory leaks and other issues. The JVM's garbage collector does a much better job of managing memory and it's better to let it do its job. In addition, Java also provides several memory managements related flags that can be used to configure the JVM memory usage and performance. Such as, -Xmx and -Xms to configure the maximum and minimum heap size, -XX:NewRatio to configure the size of young and old generation, -XX:+UseG1GC to configure the G1 Garbage collector. It's worth noting that, effective Memory management requires a deep understanding of JVM internals, Garbage Collection and Java Memory Model. Incorrect usage of memory management flags can lead to poor performance and stability issues. Overall, these changes to the Java Memory Model in Java 8 help to improve the performance and safety of multi-threaded Java applications. What is Meta-Space in java ? What benefits does it offer? In Java 8 and later, the Meta-Space is a memory space that is used to store class metadata. It is separate from the Java heap, which is used to store objects and other data. The MetaSpace is used to store information about classes and interfaces, such as their methods, fields, and annotations. This information is used by the Java Virtual Machine (JVM) to dynamically load and link classes at runtime. The MetaSpace is allocated a fixed amount of memory, which is specified using the -XX:MaxMetaspaceSize command-line option. When the MetaSpace is full, the JVM will attempt to free up space by unloading classes that are no longer in use. If this is not sufficient, the JVM will throw a java.lang.OutOfMemoryError: Metaspace error. It is important to monitor the MetaSpace usage and adjust the - XX:MaxMetaspaceSize as necessary to ensure that there is enough space for the classes that are needed at runtime. It's worth noting that, starting from Java 11, the MetaSpace has been replaced by the \"Class Data Sharing\" (CDS) feature. CDS allows to share read-only class data across multiple JVMs, reducing the memory footprint and the time required to start the JVM. What is memory leak in java? how to rectify that in java? A memory leak in Java occurs when an application continues to hold onto objects that are no longer needed, preventing the garbage collector from freeing up memory. This can lead to the application using more and more memory over time, eventually causing it to crash or become unresponsive. Memory leaks can be caused by a variety of issues, such as incorrect object references, failure to close resources, or using third-party libraries that have memory leaks. To fix a memory leak, you will need to identify the source of the problem and correct it. This can involve using tools such as memory profilers, heap dumps, and thread dumps to help identify the root cause of the leak. How to use a profiler to find the memory leak? There are several ways to use a profiler to identify memory leaks in Java: Use a built-in profiler: Many integrated development environments (IDEs) such as Eclipse and IntelliJ IDEA have built-in profilers that can be used to detect memory leaks. These profilers typically provide information such as heap usage, object references, and garbage collection statistics. Use a standalone profiler: Standalone profilers such as VisualVM and JProfiler can be used to profile Java applications. These profilers provide more advanced features such as heap dump analysis, thread profiling, and memory leak detection. Use command-line tools: The Java Virtual Machine (JVM) provides several command-line tools that can be used to profile memory usage, such as jmap, jstat, and jhat. These tools can be used to create heap dumps, monitor garbage collection statistics, and analyze memory usage. To use a profiler, you will need to first run your application in profiling mode, and then analyze the data that the profiler collects. This may include analyzing heap dumps, looking at object references, and identifying patterns of memory usage. Once you have identified the source of the leak, you can then take steps to fix the problem. It's worth noting that, Profilers can be quite complex, it's advisable to have some familiarity with Java Memory Model, Garbage Collection and JVM internals to effectively use them. What is out of memory error? An \"Out of Memory\" error in Java occurs when the application requests more memory from the JVM than is available. This can happen for a number of reasons, such as: The application is using more memory than is available on the system: The JVM has a maximum limit on the amount of memory it can use, which is determined by the -Xmx command line option. If the application is using more memory than this limit, an Out of Memory error will occur. Memory leaks: If an application holds onto objects that are no longer needed, it can cause the JVM to run out of memory. This is known as a memory leak. Insufficient heap size: The heap is the area of memory where the JVM stores objects. If the heap size is not large enough, the JVM may not be able to allocate enough memory for the application's needs, resulting in an Out of Memory error. High usage of non-heap memory: The JVM also uses non-heap memory for things like class metadata, JIT compilation data and native resources. If the non-heap memory usage is high, it can cause Out of Memory error. To fix an Out of Memory error, you will need to identify the cause of the problem and take steps to address it. This may include increasing the amount of memory available to the JVM, fixing memory leaks, or optimizing the application's memory usage. It's worth noting that, Out of Memory errors can be challenging to debug, it's advisable to use a profiler and analyse the heap dump or thread dump to understand the root cause of the error. CHAPTER 10: REST What are the HTTP methods in REST? REST (Representational State Transfer) is an architectural style for building web services, and it supports the following HTTP methods: GET: Used to retrieve a resource or a collection of resources. The GET method should be used for read-only operations and should not have any side-effects. POST: Used to create a new resource. The POST method can be used to submit data to the server, such as form data or JSON payloads. PUT: Used to update an existing resource. The PUT method can be used to submit data to the server, and it should completely replace the resource if it exists. PATCH: Used to partially update an existing resource. The PATCH method can be used to submit a set of changes to the server, and it should only modify the specified attributes of the resource. DELETE: Used to delete a resource. The DELETE method should delete the resource if it exists and should have no additional side- effects. These methods correspond to the CRUD (Create, Read, Update, Delete) operations that can be performed on resources in a RESTful service. The appropriate method should be used depending on the type of operation being performed. Additionally, some RESTful services may support additional methods, such as HEAD and OPTIONS, for performing specific operations. What are the idempotent methods in REST? In REST (Representational State Transfer), idempotent methods are HTTP methods that can be safely called multiple times without changing the result beyond the initial application of the method. The following HTTP methods are considered idempotent: GET PUT DELETE These methods can be called multiple times without any side effects and should always return the same result. On the other hand, non-idempotent methods, such as POST, can have side effects and should be called only once. What are the standards to follow to build a rest service? REST (Representational State Transfer) is a popular architectural style for building web services. To build a RESTful service that adheres to best practices, there are several standards and guidelines that can be followed, including: Use HTTP Verbs: RESTful services should use HTTP verbs such as GET, POST, PUT, and DELETE to perform operations on resources. URI Design: RESTful URIs should be designed to identify resources and their relationships. They should be self-descriptive and hierarchical, with nouns being used as resource names and verbs being used as resource actions. Use HTTP Status Codes: RESTful services should use appropriate HTTP status codes to indicate the result of an operation, such as 200 OK for success, 404 Not Found for a missing resource, and 500 Internal Server Error for a server-side error. Use HATEOAS: RESTful services should use HATEOAS (Hypermedia as the Engine of Application State) to allow clients to discover and interact with resources. HATEOAS uses links in the response to provide information about available actions and resources. Statelessness: RESTful services should be stateless, meaning that they do not maintain client state between requests. This helps to improve scalability and reliability, as it eliminates the need for server- side state storage. Content Negotiation: RESTful services should support content negotiation, allowing clients to request resources in the format they prefer, such as JSON or XML. Versioning: RESTful services should be versioned to allow for changes in the API over time. This can be done by including the version number in the URI or in the media type. Security: RESTful services should be secure, with appropriate measures taken to prevent unauthorized access, What is the difference between POST and PUT methods? POST Method: Purpose: POST is primarily used to submit data to be processed to a specified resource. It is commonly used when you want to create a new resource on the server. Idempotence: It is not idempotent, meaning that multiple identical requests may have different outcomes, especially if used to create new resources each time. Safety: It is not considered safe because it may cause changes on the server. PUT Method: Purpose: PUT is used to update a resource or create it if it doesn't exist at a specified URL. It is often used when you want to fully replace an existing resource with new data. Idempotence: It is idempotent, meaning that multiple identical requests will have the same effect as a single request. If the resource doesn't exist, PUT will create it, and if it does, it will update it. Safety: It is considered safe when used for updates because it doesn't create new resources; it only modifies or replaces existing ones. What is sent in headers? Can we intercept the header? If yes, how? Yes, it is possible to intercept the header in a RESTful service. The header is part of an HTTP request and contains metadata about the request, such as the type of request, the format of the payload, and the authentication credentials. In some cases, it may be necessary to intercept the header in order to process the request or to provide additional information about the request. This can be done by using middleware, which is a software component that sits between the client and the server. Middleware can inspect and modify the request and response headers, and it can also perform other tasks, such as logging, authentication, and authorization. For example, if a RESTful service needs to authenticate the client, it can use middleware to inspect the header for an authentication token. If the token is present, the middleware can verify its authenticity and allow the request to continue. If the token is not present or is invalid, the middleware can return an error response, such as a 401 Unauthorized. In summary, intercepting the header is a common practice in RESTful services, and it can be used to implement additional functionality, such as authentication, logging, and request modification. How to secure REST API? Securing a REST API involves a combination of different techniques and technologies to ensure that only authorized clients can access the API and that the data transmitted between the client and the server is protected. Here are some common ways to secure a REST API: Authentication: This is the process of verifying the identity of the client. REST APIs can use various authentication methods such as Basic Authentication, Token-based Authentication (OAuth2, JWT) or API keys. Authorization: This is the process of determining whether a client is allowed to perform a specific action on a resource. Authorization can be done using role-based access control (RBAC) or access control lists (ACLs). Encryption: This is the process of protecting data in transit by encrypting it. REST APIs can use HTTPS to encrypt the data transmitted between the client and the server. Validation: This is the process of validating the input data to ensure that it meets certain criteria. REST APIs can use input validation libraries to validate data before processing it. Rate Limiting: This is the process of limiting the number of requests that a client can make to an API within a certain time period. This can help prevent Denial of Service (DoS) attacks. Logging and Auditing: This is the process of recording API access and activity, which can be used to detect and investigate security incidents. How to pass a parameter in request, is it via URL or as a JSON object? There are multiple ways to pass a parameter in a request, and the choice depends on the application's requirements and the API design. Two common ways to pass parameters in a request are: Via URL: The URL query string can be used to pass parameters in a request. The parameters are appended to the URL after the \"?\" character, and multiple parameters are separated by \"&\". For example, http://example.com/api/users?name=john&age=30. As a JSON object: Another way to pass parameters is to include them in the request body as a JSON object. This is common in RESTful APIs that use HTTP POST or PUT methods to create or update resources. For example, the request body could be { \"name\": \"john\", \"age\": 30 }. Both methods have their advantages and disadvantages. Passing parameters via URL is easy to understand and implement, and the parameters can be easily bookmarked or shared. However, passing sensitive data via URL is not secure as it can be easily intercepted and viewed by third parties. On the other hand, passing parameters as a JSON object in the request body is more secure as it is not visible in the URL. However, it may require more effort to implement and may not be as easy to understand for beginners. In summary, passing parameters via URL or as a JSON object in the request body are both valid methods, and the choice depends on the application's requirements and the API design. It's important to note that, securing a REST API requires a holistic approach that considers all aspects of the API and its environment, such as the infrastructure, network, and clients. Also, security best practices and standards such as OWASP and PCI-DSS should be followed. Also, you can use Spring Security to secure your REST API. CHAPTER 11: DESIGN PATTERN & SYSTEM DESIGN Design Rest API for tiny URL application, how many endpoints it requires? Based on that there is a discussion on it.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0 How to use sorting in Java-8?",
    "answer": "In Java 8, you can use the sorted method of the Stream API to sort elements in a collection. By default, the sorted method sorts elements in their natural order, but you can also provide a Comparator to specify the sort order. Here's an example of how you can sort a list of integers in ascending order using the sorted method: List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5); numbers.stream() .sorted() .forEach(System.out::println); And here's an example of how you can sort a list of strings in descending order based on their length: List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"); words.stream() .sorted(Comparator.comparingInt(String::length).reversed()) .forEach(System.out::println); In this example, we use the Comparator.comparingInt method to create a comparator that compares strings based on their length, and then we use the reversed method to reverse the sort order. Note that the sorted method returns a new stream with the elements sorted in the specified order, and it does not modify the original stream or collection. Write a program using stream API - Find the employee count in each department in the employee list? import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.stream.Collectors; public class Employee { private String name; private String department; public Employee(String name, String department) { this.name = name; this.department = department; } public String getName() { return name; } public String getDepartment() { return department; } } public class FindEmployeeCountByDepartment { public static void main(String[] args) { List<Employee> employees = Arrays.asList( new Employee(\"Alice\", \"Engineering\"), new Employee(\"Bob\", \"Sales\"), new Employee(\"Carol\", \"Engineering\"), new Employee(\"Dave\", \"Marketing\"), new Employee(\"Eve\", \"Sales\") ); // Create a stream of the employee list. Stream<Employee> employeeStream = employees.stream(); // Group the employees by department. Map<String, Long> employeeCountByDepartment = employeeStream .collect(Collectors.groupingBy(Employee::getDepartment , Collectors.counting())); // Print the results. System.out.println(employeeCountByDepartment); } } Output : {Engineering=2, Sales=2, Marketing=1} Find employees based on location or city and sort in alphabetical manner using stream API? (like a-z and each city employee’s salary should be sorted max to min salary) import java.util.*; import java.util.stream.Collectors; public class EmployeeFilter { public static void main(String[] args) { List<Employee> employees = Arrays.asList( new Employee(\"John\", \"New York\", 5000), new Employee(\"Jane\", \"New York\", 6000), new Employee(\"Bob\", \"Chicago\", 4500), new Employee(\"Alice\", \"Chicago\", 5500), new Employee(\"Sam\", \"San Francisco\", 7000), new Employee(\"Emily\", \"San Francisco\", 6500) ); String location = \"Chicago\"; List<Employee> filteredEmployees = employees.stream() .filter(e -> e.getLocation().equals(location)) .sorted(Comparator.comparing(Employee::getName)) .sorted(Comparator.comparing(Employee::getSalary).rev ersed()) .collect(Collectors.toList()); System.out.println(\"Filtered employees: \" + filteredEmployees); } static class Employee { private final String name; private final String location; private final int salary; public Employee(String name, String location, int salary) { this.name = name; this.location = location; this.salary = salary; } public String getName() { return name; } public String getLocation() { return location; } public int getSalary() { return salary; } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", location='\" + location + '\\'' + \", salary=\" + salary + '}'; } } } In this program, we first define a List of Employee objects with some elements, where each employee has a name, a location (city), and a salary. We then define a location variable to filter the employees based on the given location. We use a stream to filter the employees based on the given location using the filter() method, and then sort them in alphabetical order by name using the sorted() method with Comparator.comparing(Employee::getName). Finally, we sort each city employee’s salary from highest to lowest using the sorted() method with Comparator.comparing(Employee::getSalary).reversed(). We collect the filtered and sorted employees into a list using the collect() method with Collectors.toList(), and print the result using the System.out.println() statement. Filtered employees: [Employee{name='Alice', location='Chicago', salary=5500}, Employee{name='Bob', location='Chicago', salary=4500}] Find the occurrence of names of employees from the List<Employee>, and find the frequency of each name. import java.util.*; public class EmployeeNameFrequency { public static void main(String[] args) { List<Employee> employees = Arrays.asList( new Employee(\"John\", \"New York\", 5000), new Employee(\"Jane\", \"New York\", 6000), new Employee(\"Bob\", \"Chicago\", 4500), new Employee(\"Alice\", \"Chicago\", 5500), new Employee(\"Sam\", \"San Francisco\", 7000), new Employee(\"Emily\", \"San Francisco\", 6500), new Employee(\"John\", \"Chicago\", 5500), new Employee(\"Jane\", \"San Francisco\", 6500), new Employee(\"Bob\", \"San Francisco\", 7000) ); Map<String, Integer> nameFrequencyMap = new HashMap<>(); for (Employee employee : employees) { String name = employee.getName(); nameFrequencyMap.put(name, nameFrequencyMap.getOrDefault(name, 0) + 1); } System.out.println(\"Name frequency: \" + nameFrequencyMap); } static class Employee { private final String name; private final String location; private final int salary; public Employee(String name, String location, int salary) { this.name = name; this.location = location; this.salary = salary; } public String getName() { return name; } public String getLocation() { return location; } public int getSalary() { return salary; } @Override public String toString() { return \"Employee{\" + \"name='\" + name + '\\'' + \", location='\" + location + '\\'' + \", salary=\" + salary + '}'; } } } We then define a nameFrequencyMap map to store the frequency of each name. We iterate over the employees using a for-each loop, and for each employee, we extract the name using the getName() method. We then put the name in the nameFrequencyMap map and increment its frequency using nameFrequencyMap.getOrDefault(name, 0) + 1. Finally, we print the nameFrequencyMap map using the System.out.println() statement. The output of the above program would be: Name frequency: {Bob=2, Emily=1, Alice=1, Sam=1, Jane=2, John=2} Write a Program to print only numbers from an alphanumeric char array using stream API in java-8. import java.util.Arrays; public class AlphanumericFilterExample { public static void main(String[] args) { String str = \"a1b2c3d4e5f6g7h8i9j0\"; char[] arr = str.toCharArray(); System.out.println(\"Original array: \" + Arrays.toString(arr)); int[] nums = new String(arr) .chars() .filter(Character::isDigit) .map(Character::getNumericValue) .toArray(); System.out.println(\"Numbers only: \" + Arrays.toString(nums)); } } character array. Then we create a stream from the characters of the string, filter only the numeric characters using the isDigit method of the Character class, convert the character to a numeric value using the getNumericValue method, and finally convert the result to an int array using the toArray method. Original array: [a, 1, b, 2, c, 3, d, 4, e, 5, f, 6, g, 7, h, 8, i, 9, j, 0] Numbers only: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] Write a program to find the sum of the entire array result using java 8 streams? import java.util.Arrays; public class ArraySum { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; int sum = Arrays.stream(arr).sum(); System.out.println(\"Sum of array elements: \" + sum); } } In this program, we first define an integer array arr with some elements. Then we use the Arrays.stream() method to create a stream of integers from the array, and then we call the sum() method on the stream to find the sum of all the elements in the array. Finally, we print the sum using the System.out.println() statement. Write a program to find even numbers from a list of integers and multiply by 2 using stream java 8? import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class EvenNumbers { public static void main(String[] args) { List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9,",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the Java Persistence API?",
    "answer": "The Java Persistence API (JPA) is the speci\u0000cation of Java that is used to persist data between Java object and relational database. JPA acts as a bridge between object-oriented domain models and relational database systems. As JPA is just a speci\u0000cation, it doesn't perform any operation by itself. It requires an implementation. Therefore, ORM tools like Hibernate, TopLink, and iBatis implements JPA speci\u0000cations for data persistence. The \u0000rst version of the Java Persistence API, JPA 1.0 was released in 2006 as a part of EJB 3.0 speci\u0000cation.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the object-relational mapping?",
    "answer": "The object-relational mapping is a mechanism which is used to develop and maintain a relationship between an object and the relational database by mapping an object state into the database column. It converts attributes of programming code into columns of the table. It is capable of handling various database operations easily such as insertion, updation, deletion, etc. Advertisement",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the embeddable classes?",
    "answer": "Embeddable classes represent the state of an entity but do not have a persistent identity of their own. The objects of such classes share the identity of the entity classes that owns it. An Entity may have single-valued or multivalued embeddable class attributes.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the JPQL?",
    "answer": "JPQL is the Java Persistence query language de\u0000ned in JPA speci\u0000cation. It is used to construct the queries.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the steps to persist an entity object?",
    "answer": "The following steps are performed to persist an entity object. Create an entity manager factory object. The Advertisement EntityManagerFactory interface present in  java.persistence package is used to provide an entity manager.  HomeEntityMPaynthaognerFactoJrayv aemf=PJearvsaisStcernipcte.creatHeTML SQL PHP C# C++ EntityManagerFactory(\"Student_details\"); Obtain an entity manager from the factory. EntityManager em=emf.createEntityManager() ; Initialize an entity manager. em.getTransaction().begin(); Persist the data into the relational database. em.persist(s1); Closing the transaction em.getTransaction().commit(); Release the factory resources. emf.close(); em.close(); Advertisement Advertisement Gửi & nhận thanh toán toàn cầu Nâng tầm doanh nghiệp với nền tảng thanh toán quốc tế toàn diện. Trải nghiệm ngay. Payoneer Mở",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the steps to insert an entity?",
    "answer": "We can easily insert the data into the database through the entity. The EntityManager provides persist() method to add records. The following steps are used to insert the record into the database. Advertisement Advertisement Ad Thanh toán nhanh và bảo mật Payoneer Mở Create an entity class, for example, Advertisement Student.java with the attribute student_name. package com.javatpoint.jpa.student; import javax.persistence.*; Ad @Entity @Table(name=\"student\") public class Student { @Id Advertisement private String s_name; Thanh toán nhanh và bảo mật public StudentEntity(String s_name) { Payoneer Mở super(); this.s_name = s_name; } public StudentEntity() { super(); } public String getS_name() { return s_name; } public void setS_name(String s_name) { this.s_name = s_name; } } Now, map the entity class and other databases con\u0000guration in Persistence.xml \u0000le. <persistence> <persistence-unit name=\"Student_details\"> <class>com.javatpoint.jpa.student.StudentE ntity</class> <properties> <property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/> <property name=\"javax.persistence.jdbc.url\" va lue=\"jdbc:mysql://localhost:3306/studentdata\"/ > <property name=\"javax.persistence.jdbc.user\" value=\"root\"/> <property name=\"javax.persistence.jdbc.passw ord\" value=\"\"/> <property name=\"eclipselink.logging.level\" val Advertisement ue=\"SEVERE\"/> <property name=\"eclipselink.ddl- generation\" value=\"create-or-extend-tables\"/> </properties> </persistence-unit> </persistence> Create a persistence class named as PersistStudent.java under com.javatpoint.jpa.persist package to persist the entity object with data package com.javatpoint.jpa.persist; import com.javatpoint.jpa.student.*; import javax.persistence.*; public class PersistStudent { public static void main(String args[]) { EntityManagerFactory emf=Persistence.cr eateEntityManagerFactory(\"Student_details\"); EntityManager em=emf.createEntityMana ger(); em.getTransaction().begin(); StudentEntity s1=new StudentEntity(); s1.setS_name(\"Gaurav\"); em.persist(s1); em.getTransaction().commit(); emf.close(); em.close(); } }",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the steps to \u0000nd an entity?",
    "answer": "Advertisement To \u0000nd an entity, EntityManger interface provides \u0000nd() method that searches an element by the primary key. The following steps are used to \u0000nd an entity in the record. Create an entity class named as StudentEntity.java under com.javatpoint.jpa.student package that contains attributes s_name. package com.javatpoint.jpa.student; import javax.persistence.*; @Entity @Table(name=\"student\") public class StudentEntity { @Id private String s_name; private int s_id; public StudentEntity(String s_name, int s_id ) { super(); this.s_name = s_name; this.s_id = s_id; } public StudentEntity() { super(); } public String getS_id() { return s_id; } public void setS_id(int s_id) { this.s_name = s_id; } public String getS_name() { Advertisement return s_name; } public void setS_name(String s_name) { this.s_name = s_name; } } Now, map the entity class and other databases con\u0000guration in Persistence.xml \u0000le. <persistence> <persistence-unit name=\"Student_details\"> <class>com.javatpoint.jpa.student.StudentE ntity</class> <properties> <property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/> <property name=\"javax.persistence.jdbc.url\" va lue=\"jdbc:mysql://localhost:3306/studentdata\"/ > <property name=\"javax.persistence.jdbc.user\" value=\"root\"/> <property name=\"javax.persistence.jdbc.passw ord\" value=\"\"/> <property name=\"eclipselink.logging.level\" val ue=\"SEVERE\"/> <property name=\"eclipselink.ddl- generation\" value=\"create-or-extend-tables\"/> </properties> </persistence-unit> Advertisement </persistence> Ad Create a persistence class named as Advertisement FindStudent.java under com.javatpoint.jpa. Find the package to persist the entity object with data. Thanh toán nhanh và bảo mật package com.javatpoint.jpa.\u0000nd; Payoneer Mở import javax.persistence.*; Advertisement import com.javatpoint.jpa.student.*; Ad public class FindStudent { public static void main(String args[]) { EntityManagerFactory emf=Persistence.cr eateEntityManagerFactory(\"Student_details\"); EntityManager em=emf.createEntityMana Thanh toán nhanh và bảo mật ger(); Payoneer Mở StudentEntity s=em.\u0000nd(StudentEntity.cla ss,101); System.out.println(\"Student id = \"+s.getS_i d()); System.out.println(\"Student Name = \"+s.ge tS_name()); System.out.println(\"Student Age = \"+s.getS _age()); } }",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the steps to update an entity?",
    "answer": "JPA allows us to change the records in the database by updating an entity. The following steps are to be performed to update the entity. Advertisement Create an entity class named as StudentEntity.java under com.javatpoint.jpa.student package, that contains attribute s_id and s_name. StudentEntity.java package com.javatpoint.jpa.student; import javax.persistence.*; @Entity @Table(name=\"student\") public class StudentEntity { @Id private String s_name; private int s_id; public StudentEntity(String s_name, int s_id ) { super(); this.s_name = s_name; this.s_id = s_id; } public StudentEntity() { super(); } public String getS_id() { return s_id; } public void setS_id(int s_id) { this.s_name = s_id; } public String getS_name() { return s_name; } Advertisement public void setS_name(String s_name) { this.s_name = s_name; } } Now, map the entity class and other databases con\u0000guration in Persistence.xml \u0000le. Persistence.xml <persistence> <persistence-unit name=\"Student_details\"> <class>com.javatpoint.jpa.student.StudentE ntity</class> <properties> <property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/> <property name=\"javax.persistence.jdbc.url\" va lue=\"jdbc:mysql://localhost:3306/studentdata\"/ > <property name=\"javax.persistence.jdbc.user\" value=\"root\"/> <property name=\"javax.persistence.jdbc.passw ord\" value=\"\"/> <property name=\"eclipselink.logging.level\" val ue=\"SEVERE\"/> <property name=\"eclipselink.ddl- generation\" value=\"create-or-extend-tables\"/> </properties> </persistence-unit> </persistence> Create a persistence class named as UpdateStudent.java under com.javatpoint.jpa.update package to persist Advertisement the entity object with data. UpdateStudent.java package com.javatpoint.jpa.update; import javax.persistence.*; import com.javatpoint.jpa.student.*; public class UpdateStudent { public static void main(String args[]) { EntityManagerFactory emf=Persistence.cr eateEntityManagerFactory(\"Student_details\"); EntityManager em=emf.createEntityMana ger(); StudentEntity s=em.\u0000nd(StudentEntity.cla ss,102); System.out.println(\"Before Updation\"); System.out.println(\"Student Name = \"+s.ge tS_name()); s.setName(\"Ayush\"); System.out.println(\"After Updation\"); System.out.println(\"Student Name = \"+s.ge tS_name()); } }",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the steps to delete an entity?",
    "answer": "To delete a record from the database, EntityManager interface provides remove() method. The remove() method uses the primary key to delete the particular record. The following examples are to be performed to delete an entity. Create an entity class named as StudentEntity.java under com.javatpoint.jpa.student package that Advertisement contains attribute s_id and s_name. package com.javatpoint.jpa.student; import javax.persistence.*; @Entity @Table(name=\"student\") public class StudentEntity { @Id private int s_id; private String s_name; Advertisement public StudentEntity(int s_id, String s_name ) { super(); this.s_id = s_id; this.s_name = s_name; } public StudentEntity() { super(); } Advertisement public int getS_id() { return s_id; } 7% OFF public void setS_id(int s_id) { this.s_id = s_id; } Smart Tivi Toshiba Full public String getS_name() { HD 43 inch 43E31MP return s_name;",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Insert a record mechanism using JPA?",
    "answer": "@Override @Transactional public void create(Category entity) throws Meetin gAppDAOException { try { logger.info(\"Enter - create()\"); super.create(entity); logger.info(\"Exit - create()\"); } catch (PersistenceException exception) { logger.error(\"create()::REASON OF EXCEPTION=\" + exception.getMessage(), e); } }",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the different directions of Advertisement entity mapping?",
    "answer": "The direction of a mapping can be either unidirectional or bidirectional. In unidirectional mapping, only one entity can be mapped to another entity, whereas in bidirectional mapping each entity can be mapped or referred to another entity.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the different types of entity mapping?",
    "answer": "Following are the types of object-relational mapping: - One-to-one mapping: The one-to-one mapping represents a single-valued association where an instance of one entity is associated with an instance of another entity. In this type of association, one instance of source entity can be mapped with at most one instance of the target entity. One-To-Many mapping: The One-To-Many mapping comes into the category of collection- valued association where an entity is associated with a collection of other entities. In this type of association, the instance of one entity can be mapped with any number of instances of another entity. Many-to-one mapping The Many-To-One mapping represents a single-valued association where a collection of entities can be associated with the similar entity. In the relational database, more than one row of an entity can refer to the same row of another entity. Many-to-many mapping The Many-To-Many mapping represents a collection-valued association where any number of entities can be associated with a collection of other entities. In the relational database, more than one row of one entity can refer to more than one row of Advertisement another entity.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is an orphan removal in mappings?",
    "answer": "If a target entity in one-to-one or one-to-many mapping is removed from the mapping, then remove operation can be cascaded to the target entity. Such target entities are known as orphans, and the orphanRemoval attribute can be used to specify that orphaned entities should be removed.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Explain persistence life cycle of an object?",
    "answer": "In persistence life cycle, the object lies in the following states: - Advertisement Transient - The object is called to be in the transient state when it is just declared by using the new keyword. When an object remains in the transient state, it doesn't contain any identi\u0000er(primary key) in the database. Persistence - In this state, an object is associated with the session and either saved to a database or retrieved from the database. Advertisement When an object remains in the persistence Advertisement state, It contains a row of the database and consists of an identi\u0000er value. We can make an object persistent by associating it with the hibernate session. Detached - The object enters into a detached state when the hibernate session is closed. The changes made to the detached objects are not saved to the database.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the different types of identi\u0000er generation?",
    "answer": "Following are the types of id generation strategy required to specify with @GeneratedValue annotation: - Automatic Id generation - In this case, the application doesn't care about the kind of id generation and hand over this task to the provider. If any value is not speci\u0000ed explicitly, the generation type defaults to auto. Id generation using a table - The identi\u0000ers can also be generated using a database table. Id generation using a database sequence - Databases support an internal mechanism for id generation called sequences. To customize the database sequence name, we can use the JPA @SequenceGenerator annotation. Id generation using a database identity - In this approach, whenever a row is inserted into the table, a unique identi\u0000er is assigned to the identity column that can be used to generate the identi\u0000ers for the objects.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is an entity?",
    "answer": "The entity is a group of states associated together in a single unit. An entity behaves as an object and becomes a major constituent of the object-oriented paradigm. In other words, we can say that an entity is an application- Advertisement de\u0000ned object in the Java Persistence Library. Each entity is associated with the metadata which represents its information in the form of XML or annotation.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the properties of an entity?",
    "answer": "Following are the properties of an entity that an object must have: - Persistability: An object is called persistent if it is stored in the database and can be accessed anytime. Persistent Identity: In Java, each entity is unique and represents an object identity. Similarly, when the object identity is stored in a database, then it is represented as persistence identity. This object identity is equivalent to the primary key in the database. Transactionality: In Java, each entity is unique and represents an object identity. Similarly, when the object identity is stored in a database, then it is represented as persistence identity. This object identity is equivalent to the primary key in the database. Granularity: Entities should not be primitives, Advertisement primitive wrappers or built-in objects with single dimensional state. Advertisement Gửi & nhận thanh toán toàn cầu Nâng tầm doanh nghiệp với nền tảng thanh toán quốc tế toàn diện. Trải nghiệm ngay. Payoneer Mở",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the role of Entity Manager in JPA?",
    "answer": "An entity manager is responsible for the following operations. The entity manager implements the API and encapsulates all of them within a single interface. The entity manager is used to read, delete and write an entity. An object referenced by an entity is managed by entity manager.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the constraints on an entity class?",
    "answer": "An entity class must ful\u0000ll the following requirements: The class must have a no-argument constructor. The class can't be \u0000nal. The class must be annotated with @Entity Advertisement annotation. The class must implement a Serializable interface if value passes an empty instance as a detached object.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the purpose of Java collections in JPA?",
    "answer": "In JPA, Java collections are used to persist the object of wrapper classes and String.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What type of objects can be stored in the JPA collections mapping?",
    "answer": "Following are the type of objects that JPA allows to store: - Basic Types Entities Embeddable",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What type of collections can be used in JPA?",
    "answer": "To store multivalued entity associations and a collection of objects, following types of Java collections is used: - List Advertisement Set Map",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the purpose of cascading operations in JPA?",
    "answer": "If we apply any task to one entity then using cascading operations, we make it applicable to its related entities also.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the types of cascade supported by JPA?",
    "answer": "Following is the list of cascade type: - PERSIST: In this cascade operation, if the parent entity is persisted then all its related entity will also be persisted. MERGE: In this cascade operation, if the parent entity is merged, then all its related entity will also be merged. DETACH: In this cascade operation, if the parent entity is detached, then all its related entity will also be detached. REFRESH: In this cascade operation, if the parent entity is refreshed, then all its related entity will also be refreshed. REMOVE: In this cascade operation, if the parent entity is removed, then all its related entity will also be removed. ALL In this case, all the above cascade operations can be applied to the entities related to the parent entity.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is JPQL?",
    "answer": "The Java Persistence Query language (JPQL) is a part of JPA speci\u0000cation that de\u0000nes searches against persistence entities. It is an object-oriented query language which is used to perform database operations on persistent entities. Instead of the database table, Advertisement JPQL uses entity object model to operate the SQL queries. Here, the role of JPA is to transform JPQL into SQL. Thus, it provides an easy platform for developers to handle SQL tasks. JPQL is an extension of Entity JavaBeans Query Language (EJBQL).",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What are the features of JPQL?",
    "answer": "Some of the essential features of JPQL are: - It is simple and robust. It is a platform-independent query language. JPQL queries can be declared statically into metadata or can also be dynamically built in code. It can be used with any database such as MySQL, Oracle.",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "What is the Criteria API?",
    "answer": "The Criteria API is a speci\u0000cation that provides type-safe and portable criteria queries written using Java programming language APIs. It is one of the most common ways of constructing queries for entities and their persistent state. It is just an alternative method for de\u0000ning JPA queries. Criteria API de\u0000nes a platform- Advertisement independent criteria queries, written in Java programming language. It was introduced in JPA 2.0. The main purpose behind this is to provide a type-safe way to express a query. SEO Interview HTML Interview Questions Questions PL/SQL Interview SQL Interview Questions Questions Oracle Interview Android Interview Questions Questions SQL Server Interview MySQL Interview Questions Questions Java Basics Interview Java OOPs Interview Questions Questions Spring Interview Hibernate Interview Questions Questions Advertisement Latest Courses   Advertisement",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0\" encoding=\"UTF-8\"?",
    "answer": "> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <!--the org.springframework. package was shortened to o.s. for this code to fit the page better --> <bean class=\"o.s.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/> <bean class=\"o.s.context.annotation.CommonAnnotationBeanPostProcessor\"/> <bean class=\"o.s.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/> <bean class=\"o.s.beans.factory.annotation.RequiredAnnotationBeanPostProcessor\"/> </beans> Considering the following bean definition: <bean class=\"com.book.sandbox.SimpleBean\" /> 38 Chapter 2 ■ Spring FundamentalS If there is no other bean definition with the same class attribute value, the bean can be accessed like this: SimpleBean sb = context.getBean(SimpleBean.class); Or can even be injected as a dependency via autowiring: @Autowired SimpleBean simpleBean; ■ ! in the book-code/02-chapter project, there is a class called BeanIdentificationTest that tests various scenarios of bean identification. Bean Identification by Name The <bean/> element has an attribute called name. The value assigned to this attribute in a bean definition can be used to access this bean. A duplicate bean name will invalidate a configuration file. The name is flexible and can be used to define more than one name when the values are separated by a comma (\",\") or a semicolon (\";\"). The bean is defined as follows: <bean name=\"sbb0\" class=\"com.book.sandbox.SimpleBean\"/> Can be accessed as follows: // the old way SimpleBean sb0 = (SimpleBean)context.getBean(\"sb0\"); // or the Spring 3.0 way SimpleBean sb0 = context.getBean(\"sb0\", SimpleBean.class); And can also be injected as a dependency via autowiring using the @Qualifier annotation: @Autowired @Qualifier(value = \"sb0\") SimpleBean simpleBean; The @Bean annotation has a name attribute too, so an equivalent annotation configuration can be created: @Bean(name=\"simpleBean\") public SimpleBean getSimpleBean(){ return new SimpleBean(); } 39 Chapter 2 ■ Spring FundamentalS Bean Identification by id The <bean/> element has an attribute called id. The value assigned to this attribute in a bean definition can be used to access the bean. This attribute uniquely identifies a bean, so a duplicate bean id will invalidate a configuration file. This attribute can appear alongside the name attribute, and both can be used to access the bean. The id and the name attributes serve the same purpose: they are both used to define bean identifications. The difference between them is that the value of the id attribute must conform to XML standard id, which means no weird characters like a comma (\",\") or semicolon (\";\") can be contained in it. Basically, the following bean definition is valid: <bean name=\"sb0\" id=\"id0\" class=\"com.book.sandbox.SimpleBean\"/> And the following test will pass, as both calls will return the same bean: @Test public void testBeans() { ... SimpleBean sb01 = context.getBean(\"sb0\", SimpleBean.class); SimpleBean sb02 = context.getBean(\"id0\", SimpleBean.class); assertTrue(sb01 == sb02); } Accessing Annotated Beans The beans defined using @Component and extensions of it can be autowired by name or by type without any extra configuration. ■ CC When using annotation configuration—beans annotated with @Component or extensions of it—the Spring ioC container also creates a logical name for these beans by lowercasing the first letter of the class name. @Component @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class PrototypeBean { ... } ... \\\\ requesting bean by name PrototypeBean pb1 = (PrototypeBean)context.getBean(\"prototypeBean\"); assertNotNull(pb1); \\\\Requesting bean by type PrototypeBean pb2 = context.getBean(PrototypeBean.class); assertNotNull(pb2); assertNotEquals(pb, pb2); 40 Chapter 2 ■ Spring FundamentalS Spring AOP AOP is an acronym for aspect-oriented programming and represents a programming paradigm that aims to simplify code by grouping repetitive operations in units called aspects. AOP helps managing common functionality that spans across the application, like logging, security, and transactionality. AOP complements OOP (object-oriented programming) by providing a more advanced way of decoupling the code and modularizing an application. The AOP framework complements the Spring IoC container. The container can be used without it in small applications that do not require the use of security or transactions, because these are the key crosscutting concerns for enterprise applications. In Spring, an aspect is class annotated with @Aspect. It contains methods called advices that are annotated with aspect-specific annotations that intercept the execution of other beans’ methods and performs specific operations before and/or after their execution, and can prevent the execution of an intercepted method if necessary. The AOP framework makes this possible by scanning all aspects when the application context is started, and creates AOP proxy objects that wrap around existing beans to implement aspect contracts. When the target beans are requested for usage or injection, the proxy object is injected or returned instead. From a developer’s point of view, it looks like the intended object is used, but the Spring IoC container works with the proxy object that is wrapped around it. Let’s see how AOP can make things easier when you want to save a Person instance to the database using the PersonManagerImpl mentioned at the beginning of the chapter. The following is what the code looks like in Spring without AOP. Figure 2-6 shows the UML diagram. <!-- configuration will contain this element --> <bean id=\"txManager\" class= \"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> <property name=\"dataSource\" ref=\"dataSource\"/> </bean> // PersonManagerImpl.java ... @Autowired @Qualifier(\"txManager\") PlatformTransactionManager transactionManager; @Autowired @Qualifier(\"personRepository\") PersonRepository repo; public int save(Person person) { TransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); int result = repo.save(person); transactionManager.commit(status); return result; } 41 Chapter 2 ■ Spring FundamentalS Figure 2-6. Diagram in non-AOP mode And here is how it looks using AOP (the UML diagram is presented in Figure 2-7): <!-- configuration will contain this element needed to switch on the transactional behaviour --> <tx:annotation-driven transaction-manager=\"txManager\"/> // PersonManagerImpl.java @Component(\"personManager\") @Transactional public class PersonManagerImpl implements PersonManager { @Autowired @Qualifier(\"personRepository\") PersonRepository repo; public int save(Person person) { return repo.save(person); } } 42 Chapter 2 ■ Spring FundamentalS Figure 2-7. Diagram in AOP mode The <tx:annotation-driven/> configuration element is defined in the Spring tx namespace, which has to be added to the configuration file: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"> ... </beans> And in order to run the methods of a bean in a transactional environment, you also have to specify the TransactionManager instance used to handle the transactions. In a test environment, the annotation @TransactionConfiguration is used: @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {\"classpath:app-aop-cfg.xml\", \"classpath:spring/test-db-config.xml\"}) @TransactionConfiguration(transactionManager = \"txManager\") public class PersonSaveTest { ... } 43 Chapter 2 ■ Spring FundamentalS To verify that the test method is running in a transaction environment, you can switch the Spring Framework log to DEBUG, as explained in the “Lifecycle and Instantiation” section, and run the test. In the console, the following logs will prove this: DEBUG o.s.j.d.DataSourceTransactionManager - Acquired Connection conn1: url=jdbc:h2:mem:dataSource user=SA for JDBC transaction DEBUG o.s.j.d.DataSourceTransactionManager - Switching JDBC Connection conn1: url=jdbc:h2:mem:dataSource user=SA to manual commit INFO c.b.a.PersonManagerImpl - -> Calling repo.save(person) DEBUG o.s.j.c.JdbcTemplate - Executing prepared SQL update DEBUG o.s.j.c.JdbcTemplate - Executing prepared SQL statement insert into person (firstname, lastname, date_of_birth) values (?,?,?) DEBUG o.s.j.c.JdbcTemplate - SQL update affected 1 rows INFO c.b.a.PersonManagerImpl - -> repo.save execution completed. DEBUG o.s.j.d.DataSourceTransactionManager - Initiating transaction commit DEBUG o.s.j.d.DataSourceTransactionManager - Committing JDBC transaction on Connection conn1: url=jdbc:h2:mem:dataSource user=SA DEBUG o.s.j.d.DataSourceTransactionManager - Releasing JDBC Connection conn1: url=jdbc:h2:mem:dataSource user=SA after transaction ■ CC if the bean of type TransactionManager is named transactionManager when in a transactional environment, the Spring ioC container will detect it automatically and there is no need to specify it as an argument for the @TransactionConfiguration annotation. even more, @TransactionConfiguration can be replaced with @Transactional, and the test methods will still be executed in a transactional environment. the transaction-manager attribute from the <tx:annotation-driven/> can be omitted too. also, @Qualifier(\"transactionManager\") is not needed when the transactionManager is autowired and the bean of type TransactionManager has the default name. in the code samples presented here, a bean of type TransactionManager with a different name was used to show the developer the configurations needed to work in cases other than the default one, because in bigger applications, multiple beans of type TransactionManager might be needed. Testing Spring Applications When it comes to writing code, there are two types of testing that matter: unit testing and integration testing. • Unit testing is used to test small units of code, thus its naming. Unit testing is easy to do—not much setup is necessary, and since JUnit10 has introduced @Test annotation writing, unit tests have become a breeze. 10The most commonly used Java testing framework (see http://junit.org). 44 Chapter 2 ■ Spring FundamentalS • Integration testing is used to test bigger chunks of code made up of objects interacting together in a given context, and the focus is set on business logic and object integration with each other. The context is usually made up of mocks or stubs that replace the objects, which are not the focus of the tests. You can imagine that creating a testing context is not a simple job. The Spring Framework includes a testing module called spring-test that makes integration testing really practical to implement. The tests that have been used throughout this chapter use the spring-test module. • The SpringJUnit4ClassRunner, as the names says, is a Spring class used to tell JUnit that the tests in this class are executed in a Spring test context. • The @ContextConfiguration receives one or more configuration files as parameters that are used to initialize the test context. • The @TransactionConfiguration is the annotation that injects the transactionManager instance used to run tests in a transactional environment. As mentioned earlier, this can be skipped, and @Transactional can be used when the TransactionManager bean has the default name. ■ CC When using @ContextConfiguration to annotate a test class, the configuration file path can be skipped, and then Spring ioC container will look for a file named [TestClassName]-context.xml in the same location where the test class is defined. When the project has a maven structure, the configuration is placed in the resources directory, and the directories matching the package name for the test class are created so the file will have the same relative path as the test class. So if you have test class com.book.simple.SimpleTest annotated with @ContextConfiguration, then resources will have com/books/simple/SimpleTest-context.xml to provide the test context configuration, which is automatically discovered and used by the Spring ioC container. Summary After reading this chapter, you should have a basic knowledge of how Spring does its magic and understand the following: • Two flavors of configuration can be mixed: XML-based (decoupled from classes code) and Java annotation–based (bean definitions are mixed in the class code) • The lifecycle of a bean • How to access a bean • What AOP is and how and where Spring can apply it • How to test Spring applications 45 Chapter 2 ■ Spring FundamentalS Quick Quiz Question 1: What is a bean? A. a plain old Java object B. an instance of a class C. an object that is instantiated, assembled, and managed by a Spring IoC container Question 2: What is the default scope of a bean? A. default B. singleton C. protected D. prototype Question 3: What types of dependency injection are supported by Spring IoC container? A. setter injection B. constructor injection C. interface-based injection D. field-based injection Question 4: What is true about @PostConstruct and @PreDestroy ? A. they are JSR-250 annotations B. they are supported by AutowiredAnnotationBeanPostProcessor C. they are registered by the <context:component-scan/> element Detailed answers are in the Appendix. Practical Exercise The practice module for this chapter is in the book-code project; it is named 02-chapter-practice. The solution is in the 02-chapter-solution module. You are given the code for a few related beans. Your task is to complete the existing configuration files, to create test contexts, and to make sure that the tests pass. The book-code project is a gradle multimodule project. It can be built from the command line by running gradle build under the book-code directory. This will build all modules of the project. The build will fail when run for the first time because of the unresolved tasks in the -practice projects. If you do it this way, you will have something similar to the following output in your console: $ gradle build .. :02-chapter-practice:compileJava UP-TO-DATE :02-chapter-practice:processResources UP-TO-DATE :02-chapter-practice:classes UP-TO-DATE :02-chapter-practice:jar UP-TO-DATE :02-chapter-practice:assemble UP-TO-DATE :02-chapter-practice:compileTestJava UP-TO-DATE :02-chapter-practice:processTestResources UP-TO-DATE 46 Chapter 2 ■ Spring FundamentalS :02-chapter-practice:testClasses UP-TO-DATE :02-chapter-practice:test com.book.plain.PlainPersonSaveTest > savePerson FAILED java.lang.AssertionError at PlainPersonSaveTest.java:31 .. BUILD FAILED Total time: 4.096 secs If you decided to use the Intellij IDEA editor on the Gradle tab, you already have available all the predefined Gradle tasks and you can just double-click the one you are interested in. In the following image, the selected task is the build task for the project book-code; but if you scroll down in that view, you will see the modules in the project and you can choose to build a specific module. So double-click under the :02-chapter-practice on the build task and execute it. The build will fail, but this is expected. This task will succeed because it does not execute the tests. In Figure 2-8 you can see how your IDE should look. Figure 2-8. Intellij IDEA Gradle run ■ ! to compile projects without failing (due to tests in practice projects that are not fixed yet), you can use the allCompile task, which was created this purpose. 47 Chapter 2 ■ Spring FundamentalS On the left in the Project view, you can see the book-code project and the component modules. Each module has the typical Maven structure mentioned earlier in the chapter (see Figure 2-3). Expand the 02-chapter-practice and look in the com.book.base package. In it you will notice the implementation of the Person class. The instances of this class are used in the test examples and are handled by instances of classes that implement PersonManager. The PersonManager interface defines the int save(Person person) method, which should return the number of records that were affected. In this case, it can be only 1 (one Person instance was saved) or 0 (no Person instance was saved). The PersonRepository interface will be implemented by the repository classes used in this example. Some repositories will actually save Person instances into a test database, but most of them will just print a log message to tell the developer that the method was executed correctly. The code for this chapter was created to show how a Spring application is configured, so more complex functionality is not covered. Classes and methods are commented properly, so using them is very straightforward. Every time a project or module is built with gradle, a directory named build is created containing the detailed results of the build for that project or module. This can be seen in Figure 2-9. Figure 2-9. Intellij IDEA Project view 48 Chapter 2 ■ Spring FundamentalS What is relevant when working with these sources is the reports\\tests\\index.html file. When opened in a browser, it displays all the failing tests in that module. This page can be refreshed during development to track, step by step, the number of tests that have to be fixed. When accessed after the first gradle build, it should display what is depicted in Figure 2-10. Figure 2-10. Gradle-generated index.html There are eight tests failing, and they do so because the implementation for them is incomplete. Completing them has been left as practice for you, the developer reading this book. Click the TODO label in the bottom-left corner. A view will open that should look like what is shown in Figure 2-11. Click and expand everything. Every TODO task has a number attached. Start resolving the tasks in ascending order. 49 Chapter 2 ■ Spring FundamentalS Figure 2-11. Intellij IDEA TODO tab The root package is called com.book. Under this package all packages will group classes with a common purpose. For example, the plain package contains classes that implement the functionality for saving a Person instance by using plain Java—no Spring beans or configuration files, as was shown in the beginning of the “The Spring Core Container” section. As Maven convention requires, the test classes are placed in the same package as the classes being tested, but under the test directory. The first exercise is to complete the plain Java implementation to save a Person instance and make the com.book.plain.PlainPersonSaveTest. After you have written the code, run the test. Just right-click anywhere in the file and choose Run and the class name in the menu, similar to what you see in Figure 2-12. Figure 2-12. Intellij IDEA— running a Gradle test 50 Chapter 2 ■ Spring FundamentalS If the test does not pass, go back and re-read the beginning of this chapter to refresh your memory on how dependency injection is handled in plain Java. After you are done and you have a successful build for 02-chapter-practice, you can compare your solution to the one in 02-chapter-solution. Also, you should take a look at the sources, test sources, and resources under packages aop, noaop, and sandbox. The book.code.spring.noaop package contains classes that implement a transactional bean used to save a Person instance, but opening and committing a transaction are done manually. The book.code.spring.aop package contains classes that implement a transactional bean used to save a Person instance using Spring AOP. Both implementations are tested in a test context that uses a H2 in-memory database to perform the actual save of a Person instance. The configuration of the test database is in the test-db-config.xml file, and you will notice that the Spring jdbc namespace is used. As JPA is not used, you need some *.sql initialization files, which can be found under the test/resources/datasource directory. <jdbc:embedded-database id=\"dataSource\" type=\"H2\"> <jdbc:script location=\"classpath:datasource/db-schema.sql\"/> <jdbc:script location=\"classpath:datasource/db-test-data.sql\"/> </jdbc:embedded-database> The com.book.spring.sandbox contains classes and tests designed to help you understand how bean identification works. When you have passed all the tests and you feel confident that you have a solid grasp of the Spring fundamentals, you can continue to the next chapter. 51 Chapter 3 Spring MVC This chapter was written with the intention of teaching a developer how to create a simple Spring web application and understand how the background plumbing can be modified according to the desired approach. Think of Spring infrastructure components as LEGO pieces. You can connect them in different ways to get the final result: a working web application. After going through this chapter, you should be able identify and use the main components of Spring MVC to create a web application in a few easy steps. Aside from describing and giving examples on how Spring Web MVC works, this chapter also teaches you how to integrate it with different view technologies, like JSP, Apache Tiles, and Thymeleaf.1 MVC Basics Spring Web MVC is a popular request-driven framework based on the model-view-controller software architectural pattern, which was designed to decouple components that by working together make a fully functional user interface. The typical model-view-controller behavior is displayed in Figure 3-1. Figure 3-1. Typical MVC behavior 1Thymeleaf is the new sheriff in Web town. It is an XML/XHTML /HTML5 template engine that works both in web and non-web environments. It is really easy to integrate it with Spring. If you want to read more about it before using it in the practice code for this chapter, go to the official site at http://www.thymeleaf.org/. 53 Chapter 3 ■ Spring MVC The Spring Web MVC provides preconfigured beans for the implementation of this behavior. These beans are contained in two main libraries: • spring-web.jar • spring-webmvc.jar These libraries are the core of all Spring-related modules. At the center of the Spring Web MVC framework sits the DispatcherServlet class, which is the entry point for any Spring web application. Before any HTTP request reaches the specific controller, it has to go through DispatcherServlet for that controller to be identified.2 In a nutshell, the DispatcherServlet coordinates all request-handling operations using other infrastructure components defined in Spring and user-defined components. And it acts as a front controller, an entry point for the web application. The Spring components mentioned earlier can be categorized as follows: • Spring MVC infrastructure components • handler mappings • handler adapters • view resolvers • personalization beans • exception resolvers • User-provided web components • handler interceptors • controllers Thus, the Spring MVC functional flow can be sketched somewhat like in Figure 3-2. 2If it looks as if Spring MVC resembles Struts, you are definitely not imagining things. The Spring Web MVC was inspired by Struts, which was one of the first MVC-based frameworks. The DispatcherServlet in Spring has the same responsi- bilities as the ActionServlet in Struts, as both are implementations of the Front Controller Pattern. You can read more about this software design pattern at http://www.martinfowler.com/eaaCatalog/frontController.html. 54 Chapter 3 ■ Spring MVC Figure 3-2. Spring MVC functional flow Briefly put, to configure a Spring web application, you need to do the following: • Define the DispatcherServlet as the main servlet handling all requests to the application in web.xml and link it to the Spring configuration, or configure this servlet programmatically by using a class implementing WebApplicationInitializer (only possible in a Servlet 3.0+ environment) • Define the application configuration (usually in a Spring configuration file named mvc-config.xml or a Java configuration class), which should do the following: • Define the MVC context used (handler adapter, handler mapping, and other infrastructure beans) • Define a view resolver (or more) Configuring MVC Spring Web MVC can be configured just like any other Spring application, via XML (using mostly the <mvc/> namespace), Java configuration annotations, or by mixing these. A Spring web application can be configured in two ways: • All-in-one configuration: web.xml (part of JEE specification) or a WebApplicationInitializer implementation and Spring application configuration files. Back-end and front-end configurations are coupled and the DispatcherServlet is the only entry point to the application. • Separate configuration: Used for more complex applications when the DispatcherServlet is not the only entry point (usually applications that require the back end to be accessed via REST or SOAP requests/web services, and in this case, the back end needs a separate listener). 55 Chapter 3 ■ Spring MVC Typical Java web applications that can be built with Gradle have the internal structure consecrated by Maven. The folder containing web-specific files, configuration files, and static resources is named webapp. The projects used in this chapter all have this structure (in Intellij IDEA), as shown in Figure 3-3. Figure 3-3. Typical Java web application structure with web.xml configuration file XML Configuration Spring XML configuration for core applications was covered in the previous chapter. But XML namespaces can be used for declaring web-specific infrastructure beans too. There are multiple ways to configure a web application; multiple files can be used for web-specific beans to be grouped together based on their purpose. In this chapter, multiple ways to create a configuration are presented, and after getting familiar with all of them, you will be able to “mix and match” to create configurations for the types of applications that you will develop. All-in-One Configuration This is the simplest way to configure a web application. The Spring configuration files are all referred to in the web.xml file as a value for the contextConfigLocation parameter. <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/mvc-config.xml /WEB-INF/spring/app-config.xml </param-value> </init-param> </servlet> 56 Chapter 3 ■ Spring MVC <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> In the preceding case, the mvc-config.xml contains the Spring configuration for the front-end (controllers and MVC infrastructure beans) of the application, and the app-config.xml contains the back-end configuration (service beans). In this case, all Spring configuration files are loaded by the DispatcherServlet and a web context is created. Separate Configuration The proper way to configure a more complex web application to make it more extensible and flexible is to decouple the front-end configuration the back-end configuration. Such an implementation provides web services access to the back end. This can be done by having a separate listener for the back-end configuration. This complicates the content of web.xml a bit, and the configuration looks similar to the next one: <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/app-config.xml</param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/mvc-config.xml</param-value> </init-param> </servlet> <servlet-mapping>...</servlet-mapping> ■ CC When the back-end Spring configuration file is named applicationContext.xml, there is no need to specify the <context-param> element in your configuration. the Spring ioC container accepts the previously mentioned file name as a default name for the backed configuration file and it will load it automatically. 57 Chapter 3 ■ Spring MVC The web.xml file is transformed to this: <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <!-- The backend configuration file is named applicationContext.xml --> <!-- The <context-param> is no longer needed.--> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>mvc-dispatcher</servlet-name> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/mvc-config.xml</param-value> </init-param> </servlet> <servlet-mapping>...</servlet-mapping> ■ ! throughout this book, package names may not be presented fully: or.springframework. usually becomes o.s. the reason for this is to fit the configuration and code samples better in the page to make them more readable. ■ CC if the Spring MVC configuration file is named [servletName]-servlet.xml, there is no need to specify the <init-param> element either. the Spring ioC container accepts the previously mentioned file name template (replace servletName with the name given to the servlet) as a default name for the front-end configuration file and it will load it automatically. The separate configuration can be simplified like this: <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/app-config.xml</param-value> </context-param> 58 Chapter 3 ■ Spring MVC <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> <servlet> <servlet-name>mvc-dispatcher</servlet-name> <!-- The frontend configuration file is named mvc-dispatcher-servlet.xml --> <!-- The <init-param> is no longer needed.--> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>mvc-dispatcher</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> Customizing the configuration is easy. All rules from Spring core configuration apply. Wildcards are supported. Different resource prefixes can be used. The DispatcherServlet can even be configured to a different url-pattern. In this case, the requests to the application must contain the value of the url-pattern value, otherwise they won’t be handled by the DispatcherServlet. This approach is suited when the application uses multiple DispatcherServlet instances. <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/*-beans.xml classpath:com/book/app-config.xml </param-value> </init-param> ... <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/admin/*</url-pattern> </servlet-mapping> In the previous example, the DispatcherServlet handles the request with the URL matching [server:port]\\[application-name]\\admin\\*. ■ ! throughout this book and in all code examples, the Spring MVC configuration file is named mvc-config.xml to emphasize that only Spring MVC components are defined in it; otherwise, this configuration file can be named in any other way. the contents of this file are used for view, locale, and time zone resolution and for customizing handler mappings and other Spring MVC infrastructure beans. 59 Chapter 3 ■ Spring MVC The controllers can be defined in the mvc-config.xml configuration file using the bean tag element, just like any other bean, but starting with Spring 3.0, the preferred way to define controllers is using the @Controller annotation, which is why the Spring MVC is often referred to as @MVC. The main component of an MVC XML configuration is the <mvc:annotation-driven/> element that registers all necessary default infrastructure beans for a web application to work: handler mapping, validation conversion beans, and many others. Another component that is important is the <mvc:default-servlet-handler/>. Usually in Spring web applications the default servlet mapping “/” is mapped to the DispatcherServlet. This means that static resources have to be served by it too, which might introduce a certain lag in providing a response as the DispatcherServlet has to find the resources that the request URL is mapped to. The <mvc:default- servlet-handler/> configures a DefaultServletHttpRequestHandler with a URL mapping of “/*” and the lowest priority relative to other URL mappings. Its sole responsibility is to serve static resources. You can see some user-defined beans needed for configuring a Spring MVC application in the following example. Configurations might differ, depending on the types of resources used. <!-- Defines basic MVC defaults (handler mapping, date formatting, etc) --> <mvc:annotation-driven/> <!-- Configures a handler for serving static resources by forwarding to the Servlet container's default Servlet.--> <mvc:default-servlet-handler/> <!-- ResourceBundle bean used for internationalization --> <bean name=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\" p:basename=\"classpath:messages/global\"/> <!-- View resolver bean used to render a *.jsp page --> <bean id=\"jspViewResolver\" class=\"o.s.web.servlet.view.InternalResourceViewResolver\"> <property name=\"prefix\" value=\"/WEB-INF/\"/> <property name=\"suffix\" value=\".jsp\"/> </bean> ■ ! Before continuing to the next section, take a look at the module project 03-chapter-01-practice under the book-code project. this is a simple project focusing on the XML-based configuration; it can be used to test your understanding of this section. it uses the minimum number of Spring infrastructure beans required to start a web application and display a simple JSp page. to run a project that is a web application from the command line, execute the gradle appRun task. to run a project in intellij iDea, use the appStart task to start the application and appStop to stop the application. Make sure to execute the tasks from under the specific module in the gradle task tree. Figure 3-4 can help you identify the task you need to run the application within intellij iDea. 60 Chapter 3 ■ Spring MVC Figure 3-4. Gretty plugin special tasks to start and stop web applications 2015-03-01 15:48:36.834 WARN - 03-chapter-01-practice runs at: 2015-03-01 15:48:36.834 WARN - http://localhost:8080/03-chapter-01-practice Open that location in your browser. if you see the page shown in Figure 3-5, the project is working properly. run gradle appStop to stop the server. Figure 3-5. Practice Spring MVC application welcome page Configuration Using Annotations An equivalent configuration using Java configuration can be created, but there are a few additional details needed for the configuration class to work properly. The configuration class has to also be annotated with the @EnableWebMvc annotation and has to either implement WebMvcConfigurer or extend an implementation of this interface, for example: WebMvcConfigurerAdapter, which gives the developer the option to override only the methods he or she is interested in. 61 Chapter 3 ■ Spring MVC Annotating a configuration class with @EnableWebMvc has the result of importing the Spring MVC configuration implemented in the WebMvcConfigurationSupport class; it is equivalent to <mvc:annotation- driven/>. This class registers a lot of Spring infrastructure components that are necessary for a web application (covered later in this chapter).3 To tell the DispatcherServlet that the configuration will be provided by a configuration class instead of a file, the following changes have to be made in web.xml: • Define an initialization parameter named contextClass with the full name of the Spring class used to create an annotation-based context as the value. • The initialization parameter named contextConfigLocation should have the full name of the configuration class written by the developer as the value. <servlet> <servlet-name>admin</servlet-name> <servlet-class> org.springframework.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextClass</param-name> <param-value> o.s.web.context.support.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> </servlet> The configuration class for what was configured with XML in the previous chapter looks like this: @Configuration @EnableWebMvc // equivalent with <mvc:annotation-driven/> @ComponentScan(basePackages = {\"com.book.controllers\"}) // equivalent with <context:component-scan base-package=\"com.book.controllers\"/> //used to scan only web components public class WebConfig extends WebMvcConfigurerAdapter { ... @Bean(name = \"messageSource\") MessageSource getMessageSource() { ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); ... return messageSource; } 3If you want, you can look in the API documentation for detail information about this class, which is available at http://docs.spring.io/spring/docs/current/javadoc- api/. 62 Chapter 3 ■ Spring MVC // <=> <mvc:default-servlet-handler/> @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) { configurer.enable(); } @Bean InternalResourceViewResolver getViewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/\"); resolver.setSuffix(\".jsp\" ); return resolver; } } The @ComponentScan annotation is the equivalent of <context:component-scan />. It is used to find all the classes annotated with @Controller in the package com.book.controllers. ■ ! Before continuing to the next section, take a look at the module project 03-chapter-02-practice under book-code. this is a simple project focusing on the Java configuration–based configuration and can be used to test your understanding of this section. it uses the minimum number of Spring infrastructure beans required to start a web application and display a simple JSp page. the gradle running instructions are the same as the instructions for the previous section. Mixed Configuration ■ ! there are Spring-specific annotations like @Controller, @Service, @Component, and @Repository, which can be used to configure a Spring application without the need to use a Java configuration class; instead, an XML file is used, containing context or MVC namespace element definitions. this is called a mixed configuration, because it uses annotations to define the beans, and XML to define the context. In practice, most common and frequently used Spring configurations imply a combination of XML and annotations. The primary reason for this is legacy code, as XML configuration was the first and only way to configure a Spring application prior to Spring 2.5. Migration to a more recent version of Spring is usually a slow process, and projects remain stuck between worlds for some periods of time. And there are also developers that still prefer XML because it seems easier to separate configurations for the back end, front end, security, web services, and so on, in separate files (although this can just as easily be done with Java configuration classes). It is also intuitive and very readable when it comes to dependency injection. It is more practical to have the definition of the relationship between the beans decoupled from the bean implementation. Because it is more practical to implement transaction management using annotations, it is very visible which method is executed in a transaction. 63 Chapter 3 ■ Spring MVC Annotations should be applied when they provide functionality and/or visibly mark the annotated classes or methods for a specific purpose. Annotations should not tie the code down to some specific process, so the code should function normally without them. The most obvious case here is the @Controller annotated classes for the web side of an application. In the back end, @Repository and @Service annotations are used for the same purpose. When looking at the code of a controller class, you see the annotation and you can easily infer what the purpose of that class is. All annotation mentioned earlier are Spring stereotype annotations, which are used to denote the roles of types in the overall architecture. A typical Spring web application configuration uses an mvc-config.xml file to declare the infrastructure beans and @Controller annotated classes. Configuration Without Using web.xml Starting with Servlet 3.0+, the web.xml file is no longer needed to configure a web application. It can be replaced with a class implementing the WebApplicationInitializer (or a class extending any of the Spring classes that extend this interface). This class is detected automatically by SpringServletContainerInitializer (an internal Spring supported class, which is not meant to be used directly or extended). The SpringServletContainerInitializer class is bootstrapped automatically by any Servlet 3.0+ container. The SpringServletContainerInitializer4 extends javax.servlet.ServletContainerInitializer and provides a Spring-specific implementation for the onStartup method. This class is loaded and instantiated, and the onStartup is invoked by any Servlet 3.0–compliant container during container startup, assuming that the Spring-web module JAR is present on the classpath. Considering you have a web.xml file that looks like this: <servlet> <servlet-name>admin</servlet-name> <servlet-class>o.s.w.s.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/mvc-config.xml </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> 4The code for this class is at https://github.com/spring-projects/spring-framework/blob/master/spring- web/src/main/java/org/springframework/web/ SpringServletContainerInitializer.java. 64 Chapter 3 ■ Spring MVC The most obvious way to implement WebApplicationInitializer is this: public class WebInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); registration.setInitParameter(\"contextConfigLocation\", \"/WEB-INF/spring/mvc-config.xml\"); } } The class does not need to be annotated or linked to any other configuration file existing in the application. You can easily notice which lines from XML turned into which lines in the code, right? But there is another way, which involves constructing the application context first and then injecting it into the DispatcherServlet: XmlWebApplicationContext appContext = new XmlWebApplicationContext(); appContext.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(appContext)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); And there is an even simpler way—by extending AbstractDispatcherServletInitializer, an abstract implementation of the WebApplicationInitializer: public class WebInitializer extends AbstractDispatcherServletInitializer { @Override protected WebApplicationContext createRootApplicationContext() { //there is no root application context for the web application context to inherit return null; } @Override protected WebApplicationContext createServletApplicationContext() { XmlWebApplicationContext cxt = new XmlWebApplicationContext(); cxt.setConfigLocation(\"/WEB-INF/spring/mvc-config.xml\"); return cxt; } @Override protected String getServletMappings() { return new String { \"/\" }; } } 65 Chapter 3 ■ Spring MVC Java-based annotation configurations are supported too—in multiple ways. Consider that you have a WebConfig class and a web.xml that looks like this: <servlet> <servlet-name>admin</servlet-name> <servlet-class> o.s.web.servlet.DispatcherServlet </servlet-class> <init-param> <param-name>contextClass</param-name> <param-value> o.s.web.context.AnnotationConfigWebApplicationContext </param-value> </init-param> <init-param> <param-name>contextConfigLocation</param-name> <param-value> com.book.config.WebConfig </param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>admin</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> This is the most obvious way to implement WebApplicationInitializer’s onStartup() method: ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); registration.setInitParameter(\"contextConfigLocation\", \"com.book.config.WebConfig\"); registration.setInitParameter(\"contextClass\", \"o.s.w.c.s.AnnotationConfigWebApplicationContext\"); But wait, there’s more! You can create the application context and inject it into the DispatcherServlet as you did before: AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(WebConfig.class); ServletRegistration.Dynamic registration = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(context)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); 66 Chapter 3 ■ Spring MVC And the easiest way to do it is with AbstractAnnotationConfigDispatcherServletInitializer, which extends AbstractDispatcherServletInitializer, an abstract implementation of the WebApplicationInitializer. Spring provides them to help you eliminate some of the code writing. By extending the AbstractAnnotationConfigDispatcherServletInitializer template and using customization methods offered by the AbstractDispatcherServletInitializer, the developer is only required to provide concrete implementations for three methods: getRootConfigClasses, getServletConfigClasses, and getServletMappings. public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?> getRootConfigClasses() { //there is no root application context for the web application context to inherit return null; } @Override protected Class<?> getServletConfigClasses() { return new Class { WebConfig.class }; } @Override protected String getServletMappings() { return new String { \"/\" }; } } ■ ! Before continuing with this chapter, take a look at the 03-chapter-03-practice and 03-chapter-04- practice and try to make the projects run. the first requires you to configure a Spring web application using a Spring XML–based configuration and without a web.xml file. the second requires you to configure a Spring web application using a Java-based configuration and without a web.xml file. Be creative, read the Spring api if necessary, and then you can even compare your solution to the ones provided in the solution projects. the gradle running instructions are the same as in the previous section. MVC Components The configuration of a Spring web application integrates quite a few infrastructure beans. The DispatcherServlet looks for implementations of type: HandlerMapping, HandlerAdapter, ViewResolver, and HandlerExceptionResolver. Out-of-the-box implementations for the previously mentioned interfaces are provided by Spring. The default configuration can be found in the DispatcherServlet.properties, which is in the spring-webmvc.jar in package org.springframework.web.servlet.5 5The contents can be accessed directly on GitHub at https://github.com/spring-projects/ spring-framework/ blob/master/spring-webmvc/src/main/resources/org/springframework/web/ servlet/DispatcherServlet. properties. 67 Chapter 3 ■ Spring MVC ■ ! You can find the jar in your local maven repository. it is recommended to open the file and study it, because in the exam you might be asked about the default components configured in Spring for some MVC bean types. Some of them are deprecated in the current api—DefaultAnnotationHandlerMapping, for example—and the file will suffer some changes in future versions. The infrastructure beans mentioned earlier can be configured manually, but this is rarely done and is recommended to be avoided, as the explicit configuration cancels the default configuration for that bean type. In Spring 4.0, <mvc:annotation-driven/> and the equivalent @EnableWebMvc do just that—override the default configuration to provide the new features, so you don’t have to struggle with the configuration yourself. A Spring web application can use more than one infrastructure bean of a specific type. In this case, the beans can be chained and have an associated priority value specified using the order property. For example, you can have multiple HandlerMapping implementations: <bean class=\"o.s.web.servlet.handler.SimpleUrlHandlerMapping\"> <property name=\"order\" value=\"0\"/> </bean> <bean class= \"o.s.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"> <property name=\"order\" value=\"1\"/> </bean> When <mvc:annotation-driven/> or @EnableWebMVC is used in the application configuration, the RequestMappingHandlerMapping implementation is registered internally with Spring MVC. This class was added in Spring 3.1; it allows RequestMappings for the same URL to be in different controller classes. It is meant to replace the DefaultAnnotationHandlerMapping implementation. It was introduced to make the annotation controller support class more customizable and open for extension. When using the RequestMappingHandlerMapping, the actual handler is an instance of HandlerMethod, which identifies the specific controller method that will be invoked. Starting with Spring version 4.0, the DefaultAnnotationHandlerMapping was marked as deprecated. The following sections cover each of the infrastructure bean types in detail. Infrastructure Beans Spring MVC offers developers a lot of support when it comes to building the plumbing of a web application, so developers can focus on implementing the actual service a web application is expected to provide. The beans provided by Spring MVC are often called infrastructure beans, which have default configurations that work out of the box. Each of these infrastructure beans are presented in detail in the following sections. HandlerMapping This HandlerMapping Spring interface is implemented by classes that map parts of URL for the incoming requests to the appropriate handlers and a list of pre- and post-processor interceptors (AOP is used for this). Prior to Spring 3.1, it was necessary to specify one or more HandlerMapping beans in the application context, but after the introduction of annotated controllers, there is no need to do so. All HandlerMapping implementations are used by the DispatcherServlet to identify the handler (controller class) of a request. 68 Chapter 3 ■ Spring MVC In the DispatcherServlet.properties, you find the following default HandlerMapping implementations configured: org.springframework.web.servlet.HandlerMapping= org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping The BeanNameUrlHandlerMapping class maps URLs to beans with names that start with “/”. So a request incoming with URL http://localhost:8080/persons maps to bean: @Controller(\"/persons\") public class PersonsController { ... } ■ ! the DefaultAnnotationHandlerMapping is deprecated in Spring 4.0 as it was replaced by RequestMappingHandlerMapping. The RequestMappingHandlerMapping class maps URLs to classes annotated with @RequestMapping. So a request coming from URL http://localhost:8080/persons/list is handled by the following controller: @RequestMapping(\"/persons\") @Controller public class PersonsController { @RequestMapping(value=\"/list\") public void list(Model model){ ... } } In the preceding example, the @RequestMapping at method level is used to narrow the mapping expressed at class level, if one is present. The annotation is not really necessary at method level when it is present at class level, because narrowing can be done using other criteria too; for example, the request method type. @RequestMapping(\"/persons\") @Controller public class PersonsController { //End user requests to see data for a certain person. @RequestMapping(method = RequestMethod.GET) public void getPerson(Model model){ ... } //End user sends data to save for a certain person. @RequestMapping(method = RequestMethod.POST) public void savePerson(Person person, Model model){ ... } } 69 Chapter 3 ■ Spring MVC It is mandatory for any HTTP request path to be uniquely mapped onto a specific handler. It is recommended to keep all related handler methods in the same bean, and not span them across multiple handler beans in order to improve code readability. Another implementation worth mentioning is ControllerClassNameHandlerMapping, which was introduced in the spirit of convention over configuration. This implementation offers the possibility to generate URL path mappings from the class names and method names of registered or annotated controller beans. The convention is to take the short name of the class, remove the Controller suffix, lower case the first letter of the remaining text, prefix it with “/”, and then add the method name used to handle the request. Using this implementation, the PersonsController mentioned earlier is mapped to \"/persons*\" and the @RequestMapping(\"/persons\") annotation is no longer needed. In the book-code project, there is a sample module named 03-chapter-05-solution, which contains a simple controller with the following implementation. @Controller public class WelcomeController { @RequestMapping //maps to /welcome/sayhi public String sayhi(Model model){ model.addAttribute(\"salute\", \"Hi!\"); return \"welcome\"; } @RequestMapping //maps to /welcome/sayhello public String sayhello(Model model){ model.addAttribute(\"salute\", \"Hello!\"); return \"welcome\"; } } In order for a request to be solved correctly using the ControllerClassNameHandlerMapping, a HandlerAdapter implementation needs to be configured. AnnotationMethodHandlerAdapter will do, even if it is deprecated in Spring 4.0. ... <context:component-scan base-package=\"com.book\"/> <bean class=\"o.s.web.servlet.mvc.support.ControllerClassNameHandlerMapping\" p:caseSensitive=\"true\"/> <bean id=\"annotationMethodHandlerAdapter\" class=\"o.s.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\" /> ... 70 Chapter 3 ■ Spring MVC ■ ! an example of how to configure the ControllerClassNameHandlerMapping bean and how it works is implemented in the 03-chapter-05-solution module in the book-code project. this project does not have a practice project associated with it because there is no need for one. the gretty plugin is quite flexible and can be configured to start a web application on a different context or port. When working locally, the UrL of the application looks like this: http://localhost:8080/03-chapter-05- solution. the context is the string after the port, and gretty automatically takes the name of the project and uses it as context for the web application, if not configured to do otherwise. also, the default port is 8080, which is the default port used by most of application servers for web applications.6 As the name of the modules in book-code are quite long, Gretty was configured to use a different context, which can also emphasize the purpose of the application. gretty { port = 8080 contextPath = '/mvc-handling' } HandlerAdapter The HandlerAdapter interface is internal and is not intended for application developers. It must be implemented by each handler to be able to handle a request. The DispatcherServlet uses this interface to invoke handler methods because the interface is taking care of solving various annotations inside a controller class and identifies which method should be called. In the DispatcherServlet.properties you find the following default HandlerAdapter implementations: org.springframework.web.servlet.HandlerAdapter= org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter These are the out-of-the-box defaults if <mvc:annotation-driven/> is not specified. When <mvc:annotation-driven/> or @EnableWebMVC is used in the application configuration, RequestMappingHandlerAdapter is used. Introduced in Spring 3.1, the scope of this class is to work with RequestMappingHandlerMapping to make this class the only place where a decision is made about which method should handle a request. This actually means that every handler method is a unique endpoint that can be identified from class and method-level RequestMapping information. Prior to Spring 3.1, identifying and calling a handler method involved two steps: identifying a controller (handler) using a HandlerMapping implementation and identifying the method (handler method) using a HandlerAdapter implementation. Starting with Spring 3.1, everything is done in one step, with the two classes working together. So Figure 3-2 is not an accurate representation for Spring >=3.1; when using <mvc:annotation-driven/> or @EnableWebMVC, Figure 3-6 is more accurate. 6The full list of configuration options for Gretty can be found at http://akhikhl.github.io/gretty-doc/Gretty- configuration.html. 71 Chapter 3 ■ Spring MVC Figure 3-6. @MVC Spring >= 3.1 The old implementations were kept in the Spring MVC library, but it is recommended to use the ones introduced in Spring 3.1 and enabled by the MVC namespace or @EnableWebMVC because these ensure a simpler configuration and faster identification of a handler method, and take advantage of other new features introduced in Spring 3.1. Here is a list of some of the changes introduced by this approach: • It is no longer possible to use SimpleUrlHandlerMapping or BeanNameUrlHandlerMapping to identify a controller and then identify the handler method by narrowing the method choice with @RequestMapping. • It is no longer possible to have a single method without explicit mapping to solve all requests mapped to a controller. The new support classes will throw a Not Found 404 error. • HandlerInterceptor and HandlerExceptionResolver (covered later in the chapter) can now expect the object-based handler to be a HandlerMethod. They can examine its parameters and annotations. • Custom argument and return types are supported for handler methods. • @PathVariable annotated parameters (covered later in the chapter) are automatically added to the model, so it’s not necessary to manually add them if you are providing them as part of forwarding or redirecting. 72 Chapter 3 ■ Spring MVC • Supports parameterized URI template on redirect strings. • RequestMappings now support consumes/produces, so it’s not necessary to specify h eaders=\"ContentType=application/json\". This is a little closer to the JAX-RS style of specifying @Consumes/@Produces annotations. This helps in producing the correct error code if unsupported media types are referenced on REST requests. The preceding list is not complete. If you want a full read of all the advantages of using the new handler support classes, you can find it in the official documentation.7 Some are also mentioned in the following sections; those are the ones you should focus on for the exam. When the web application starts, if the logger of the application is configured properly, you should be able to see all the beans used in the application, including the infrastructure beans. The following is a snippet from a debug log printed when 02-pr-mvc-basic-solution starts. Run the project yourself to analyze the console output in more detail. INFO Initializing Spring FrameworkServlet 'mvc-dispatcher' ... DEBUG o.s.b.f.s.DefaultListableBeanFactory - Pre-instantiating singletons ..., accountRepo,hospitalRepo,personManager,identityCardRepo,transactionManager, entityManagerFactory, ..., o.s.w.s.m.m.a.RequestMappingHandlerMapping#0, ... ,o.s.w.s.m.m.a.RequestMappingHandlerAdapter#0, o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver#0,..., org.springframework.web.servlet.view.InternalResourceViewResolver, ,messageSource,localeResolver,themeResolver, ... ViewResolver The HTTP response returned to the client after the execution of a handler method is constructed using a model and a view. The model contains the data that is used to populate a view. Spring provides view resolvers to avoid ties to a specific view technology. Out of the box, Spring supports JSP, Velocity templates, and XSLT views. The interfaces needed to make this possible are ViewResolver and View. The first provides a mapping between view names and actual views. The second takes care of preparing the request and forwards it to a view technology.8 7http://docs.spring.io/spring/docs/current/spring- framework-reference/htmlsingle/#mvc-ann- requestmapping-31-vs-30, http://docs.spring.io/spring/docs/current/spring- framework-reference/ htmlsingle/#mvc-config-enable. 8http://docs.spring.io/spring/docs/4.1.x/spring- framework-reference/htmlsingle/#mvc-viewresolver. 73 Chapter 3 ■ Spring MVC All handler methods must resolve to a logical view name that corresponds to a file, either explicitly by returning a String, View, or ModelAndView instance or implicitly based on internal conventions. The core view resolver provided by Spring is the InternalResourceViewResolver, which is the default view resolver, as you can see in the DispatcherServlet.properties file: org.springframework.web.servlet.ViewResolver= org.springframework.web.servlet.view.InternalResourceViewResolver View Resolver Chaining A web application can have more than one ViewResolver configured and the DispatcherServlet discovers them by type. In this case, the default view resolver configuration is overridden, meaning the InternalResourceViewResolver is not the default resolver anymore, so if this bean is needed, it has to be configured explicitly. In this case, the available view resolvers can and should be chained to have a fixed sequence of resolvers trying to obtain a view. The next example shows how two view resolvers can be chained together to resolve JSP and Excel views: <!-- in mvc-config.xml --> <bean name=\"persons/list.xls\" class=\"com.book.persons.PersonsExcelView\"/> <bean id=\"xlsViewResolver\" class=\"...web.servlet.view.BeanNameViewResolver\" p:order=\"0\"/> <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:order=\"1\" /> ■ ! Defining bean properties using the p: ... syntax is possible by using the p namespace that offers a way to contract bean definitions in XML configuration files to reduce their size and make them more readable.9 Chaining view resolvers is also possible using a Java configuration class: \\\\ in @Configuration annotated class @Bean(name=\"persons/list.xls\") public View excelView(){ return new PersonsExcelView(); } @Bean(name=\"xlsViewResolver\") public ViewResolver xlsViewResolver(){ BeanNameViewResolver resolver = new BeanNameViewResolver(); 9You can read more about it in the official documentation at http://docs.spring.io/spring/docs/current/ spring-framework-reference/html/beans.html#beans- p-namespace. 74 Chapter 3 ■ Spring MVC resolver.setOrder(0); return resolver; } @Bean public ViewResolver jspViewResolver() { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); ... resolver.setOrder(1); return resolver; } When a view resolver does not result in a view (usually null is returned, but there are view resolvers that throw exceptions), Spring examines the application context for other view resolver beans and inspects each of them until a view is obtained. If this is not possible, a ServletException is returned. When resolver beans are chained, the inspection is done based on the value of their order property; the lower the value of the property, the higher the priority when resolving view names. ■ ! the InternalResourceViewResolver resolves the view no matter what view name is returned. it throws an exception if it cannot resolve a view name, so this bean always has to be placed last in the chain; otherwise, Spring skips looking for other view resolver beans in the context. XSLt and JSOn are also resolvers that must be last in the chain. tiles, Velocity, and FreeMarker can appear anywhere in the chain. In the case just presented, if the BeanNameViewResolver does not return a view (a request method has returned a logical view name different than \"persons/list.xls\"), the next resolver is called to do that. The InternalResourceViewResolver is the most important implementation provided by Spring. It is a specialization of UrlBasedViewResolver (so they cannot be used together in a configuration, chained or not) and inherits the behavior of interpreting view names as a URL, supports the \"redirect:\" prefix and the \"forward:\" prefix. And supports InternalResourceView(Servlets and JSPs) and JstlView. ■ ! the \"redirect:\" and \"forward:\" prefixes are appended to the logical view name to tell the servlet container what to do. With \"forward:\", the servlet container just forwards the same request to the target UrL, and the browser is not involved and does not know the UrL has changed. a forward should be used for safe operations when reloading the page won’t result in corrupt data (usually for requesting data to display in the page). With \"redirect:\", the response status is set to 302 and the UrL to redirect to is set in a Location header, then the response is sent to the browser. the browser then makes another request to the new UrL. redirect is a two-step operation; it is recommended to be used when the first request is a data manipulation request, and the browser must then be redirected to a confirmation page to prevent data duplication. The “redirect:” prefix can be returned together with a view name to delegate the creation of the response to another handler. The most suitable for such behavior is when a POST request was received and the possibility to resubmit the same form data has to be eliminated. The browser sends an initial POST, receives a response to redirect to a different URL, and then performs a GET request for the URL received as a 75 Chapter 3 ■ Spring MVC response. This sequence of actions matches a web development design pattern named Post-Redirect-Get that prevents duplicate form submissions. In Figure 3-7, the Post- Redirect-Get process is displayed using the PersonsController. Figure 3-7. Post-Redirect-Get in Spring using the \"redirect:\" prefix compared to \"forward:\" \"redirect:\" and \"forward:\" are recognized by the UrlBasedViewResolver and all its subclasses. They treat them accordingly and consider the view name after the prefix as the redirect/forward URL. ■ ! You will have the occasion to work with \"redirect:\" and \"forward:\" in the 05-pr-mvc-form-practice project. All view file templates are stored under /WEB-INF for security reasons. They cannot be accessed directly via a manually introduced URL and they require a model in order to be rendered. The previously mentioned view implementations supported by InternalResourceViewResolver have the following characteristics: • InternalResourceView exposes the model attributes as request attributes and forwards the request to the specified resource URL using a RequestDispatcher. • JstlView is a specialization of InternalResourceView that exposes request attributes specifying the locale and the resource bundle for JSTL’s formatting and message tags, using Spring’s locale and MessageSource ( the JSTL library is required in the classpath for this View technology to be available). 76 Chapter 3 ■ Spring MVC More about this topic is covered later in this chapter. This is an example of how a view is resolved using the chained resolvers configured earlier: /* 1 */ @RequestMapping(\"/persons.htm\") public String listHtml(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); return \"accounts/list\"; } /* 2. */ @RequestMapping(\"/persons.xls\") public String listExcel(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); return \"persons/list.xls\"; } The first method has InternalResourceViewResolver resolve the view, and the second is taken care of by BeanNameViewResolver and a PersonsExcelView is rendered. As you can see, the implementation for the two methods is almost identical. The URL and the logical view name returned are different, however. And there’s a programming principle called Don’t Repeat Yourself! that those two methods do not respect. Let’s try and respect that principle by merging the two methods into one: /* 1 */ @RequestMapping(\"/persons\") public String list(HttpServletRequest rq, Model model) { model.addAttribute(personManager.getAllPersons()); if (rq.getRequestURL().toString().endsWith(\"xls\")) { return \"persons/list.xls\"; } else { return \"persons/list\"; } } But this is not an acceptable solution either. What if the application is requested to support PDF views too? That means more if-else instructions have to be added. Right now you are probably telling yourself: “There’s gotta be a better way of doing this!” And there is. Worry not, this shall be covered in the next section. ■ ! take a look at the 03-chapter-06-solution project. it has been set up to work with the chained resolver configuration mentioned in this chapter. the data can be viewed in a web page, an excel document or a pDF. run it and take a look at the implementation before moving on to the next section. 77 Chapter 3 ■ Spring MVC Content Type Negotiation Another way of organizing the view resolver beans and making sure that the view name is always resolved correctly is to use content-type negotiation. The previous approach, resolver chaining, works only when each resource is associated with one view type. But clients might request different content- types for the same resource via extension, request header, request parameter, and so forth. In this case, chaining won’t work, as the type of view returned depends on some parameters that have to be taken into consideration and then a matching view resolver must be selected to do the job. The bean that does that is the ContentNegotiatingViewResolver, which was introduced in Spring 3.0. This bean does not resolve views but delegates the job to the view resolver implementations defined in the application configuration, selecting the view matching the content-type in the client request. There are two strategies for a client to request a view from the server: • Use a distinct URL for each resource by using a different extension in the URL (example: http://localhost:8080/persons/list.xls requests an Excel view containing a list of persons, while http://localhost:8080/persons/list.pdf requests a PDF view containing a list of persons) • Use the same URL but set the Accept HTTP request header to the desired resource type (example: a request coming from http://localhost:8080/persons/list having the Accept header set to application/pdf requests a PDF view containing a list of persons) ■ ! the problem with the Accept header is that it cannot be used when the client is a browser, as most browsers force its value to text/html. Because of this, web applications are always built to use the first approach and each view type is mapped to its own UrL (taking the extension into consideration; for example: /persons/list.html, /persons/list.xls). the Accept header approach is most useful for reSt web services and similar automation scenarios. The ContentNegotiatingViewResolver implements the Ordered interface, so it can be used alongside other resolvers, it can be part of a view resolver chain, and it has to have the highest priority in the chain. This is due to its behavior; if theContentNegotiatingViewResolver cannot select a View, it returns null, and Spring examines the application context for other view resolver beans and inspects each of them until a view is obtained. Usually the ContentNegotiatingViewResolver is configured to pick up view resolvers automatically from the application context, so it should always resolve to a View. The next resolvers in the chain can be considered a fallback solution, to make sure that a View is provided. The ContentNegotiatingViewResolver can be configured in a similar way, as shown in the following example: <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\" p:order=\"-1\"> <property name=\"mediaTypes\"> <map> <entry key=\"html\" value=\"text/html\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"json\" value=\"application/json\"/> </map> </property> 78 Chapter 3 ■ Spring MVC <property name=\"viewResolvers\"> <list> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\" /> <bean class=\"com.book.resolver.JsonViewResolver\"/> </list> </property> <property name=\"defaultViews\"> <list> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" /> </list> </property> <property name=\"defaultContentType\" value=\"text/html\"/> <property name=\"ignoreAcceptHeader\" value=\"true\"/> <property name=\"favorParameter\" value=\"false\"/> <property name=\"favorPathExtension\" value=\"true\"/> </bean> <!-- Fallback Resolver: If no extension matched, use JSP view --> <!-- Resolves view names to protected .jsp resources within the /WEB-INF directory --> <bean class=\"o.s.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/\" p:suffix=\".jsp\" p:order=\"0\"/> Here is the meaning of each property used in the previous configuration: • mediaTypes: Map containing extension to content-type correspondences. This property is not mandatory and it does not have to be set in the application when the JavaBeans Activation Framework is used, in which case the types are determined automatically.10 • viewResolvers: The list of view resolvers to delegate to. This property is not mandatory and when it is not set, all view resolver beans in the context are detected and used, but they have to be ordered. • defaultViews: The default view to use when a more specific view could not be obtained. The property is not mandatory. • defaultContentType: The type to render in case a match was not found. The property is not mandatory. • ignoreAcceptHeader: Indicates that the HTTP Accept header should be ignored if true, and taken into consideration if false. The property is not mandatory, and if not set, it defaults to false. 10By default, strategies for checking the extension of the request path and the Accept header are registered. The path extension check performs lookups through the ServletContext and the JavaBeans Activation Framework (if present) unless media types are configured. In order to use the JavaBeans Activation Framework, the activation.jar has to be in the classpath of the application. 79 Chapter 3 ■ Spring MVC • favorParameter: Indicates if a request parameter named format should be used to determine the requested content-type. The property is not mandatory, and if not set, it defaults to false. • favorPathExtension: Indicates if the extension of the request URL should be used to determine the requested content-type. The property is not mandatory, and if not set, it defaults to true. Starting with Spring 3.2, ContentNegotiationManagerFactoryBean and ContentNegotiationManager were introduced in order to encapsulate all content-type related configurations for the ContentNegotiatingViewResolver. ContentNegotiationManagerFactoryBean provides access to a ContentNegotiationManager configured with one or more ContentNegotiationStrategy. An equivalent configuration to the preceding, after Spring 3.2, looks like this: <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\"> <property name=\"viewResolvers\"> <list> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <bean class=\"o.sweb.servlet.view.tiles3.TilesViewResolver\"/> <bean class=\"com.book.resolver.JsonViewResolver\"/> </list> </property> <property name=\"defaultViews\"> <list> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\" /> </list> </property> <!-- All content-type related configuration is now done by this bean since Spring 3.2 --> <property name=\"contentNegotiationManager\"> <bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean> <property name=\"mediaTypes\"> <map> <entry key=\"html\" value=\"text/html\"/> <entry key=\"json\" value=\"application/json\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> </map> </property> <property name=\"defaultContentType\" value=\"text/html\"/> <property name=\"ignoreAcceptHeader\" value=\"true\"/> <property name=\"favorParameter\" value=\"false\"/> <property name=\"favorPathExtension\" value=\"true\"/> </bean> </property> 80 Chapter 3 ■ Spring MVC ■ ! the problem with using JavaBeans activation Framework is that if the extension is not recognized, it sets the content-type to application/octet-stream by default. this means that the Views configured with the defaultViews property are not taken into consideration and the ContentNegotiatingViewResolver will return null. that’s why in Spring 3.2, the useJaf property was introduced; it can be set to false to disable the JavaBeans activation Framework. this property has been added to ContentNegotiationManagerFactoryBean too. Considering the previous configuration, the following code displays how a view is resolved using content negotiation type: // In PersonsController.java @RequestMapping(\"/persons\") public String list(Model model) { model.addAttribute(personManager.getAllPersons()); return \"persons/list\"; } <!-- In mvc-config--> <bean class=\"com.book.persons.PersonsExcelView\"/> As you can see, there is no need for the bean name to be persons/list.xls, because the ContentNegotiatingViewResolver does the match without it. ■ ! in the following XML configuration, the util namespace is introduced to simplify the configuration. the util namespaces allows you to define and use collections in the same way that beans are defined and used in a configuration file. This configuration can be simplified by using the p and util namespaces, which allow the ContentNegotiatingViewResolver XML bean definition to be simplified, as follows: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> ... 81 Chapter 3 ■ Spring MVC <!-- sample usage of the util namespace to declare a map --> <util:map id=\"mediaTypesMap\"> <entry key=\"html\" value=\"text/html\"/> <entry key=\"xls\" value=\"application/vnd.ms-excel\"/> <entry key=\"pdf\" value=\"application/pdf\"/> <entry key=\"json\" value=\"application/json\"/> </util:map> <!-- sample usage of the util namespace to declare a list --> <util:list id=\"defaultViewsList\"> <!-- Excel view--> <bean class=\"com.pr.views.PersonsExcelView\"/> <!-- JSON View --> <bean class=\"o.s.web.servlet.view.json.MappingJackson2JsonView\"/> </util:list> <util:list id=\"resolverList\"> <bean class=\"com.pr.resolver.JsonViewResolver\"/> <bean class=\"o.s.web.servlet.view.BeanNameViewResolver\"/> <!-- Resolves logical view names to Tiles 3 definitions --> <bean id=\"tilesViewResolver\" class=\"o.s.web.servlet.view.tiles3.TilesViewResolver\" p:requestContextAttribute=\"requestContext\"/> </util:list> <bean class=\"o.s.web.servlet.view.ContentNegotiatingViewResolver\" p:order=\"-1\" p:defaultViews-ref=\"defaultViewsList\" p:viewResolvers-ref=\"resolverList\"> <property name=\"contentNegotiationManager\"> <bean class=\"o.s.web.accept.ContentNegotiationManagerFactoryBean\" p:defaultContentType=\"text/html\" p:ignoreAcceptHeader=\"true\" p:favorParameter=\"false\" p:favorPathExtension=\"true\" p:mediaTypes-ref=\"mediaTypesMap\"/> </property> </bean> <beans> Of course, this means taking out the defaultViewsList and the mediaTypesMap outside the declaration of the ContentNegotiatingViewResolver, which is the only place that they are needed. In this configuration, they can be used by other beans, although this is rarely needed. The choice belongs to the developer, depending on what configuration approach he is most comfortable with. ■ ! When the p namespace is used, the p:[property-name]-ref means this property is a reference to an existing bean in the context, with the id specified as the value. 82 Chapter 3 ■ Spring MVC That’s mostly it when it comes to content-type negotiation. What is left to add is some sample code for the Java configuration: @Configuration @EnableWebMvc public class WebConfig extends WebMvcConfigurerAdapter { // Configures the contentNegotiationManager bean @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { configurer .ignoreAcceptHeader(true) .defaultContentType(MediaType.TEXT_HTML) .favorParameter(false) .favorPathExtension(true); } //Configure ContentNegotiatingViewResolver @Bean public ViewResolver contentNegotiatingViewResolver (ContentNegotiationManager manager) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(manager); // Define all possible view resolvers List<ViewResolver> resolvers = new ArrayList<>(); resolvers.add(beanNameViewResolver()); resolvers.add(tilesViewResolver()); resolvers.add(jsonViewResolver()); resolver.setViewResolvers(resolvers); List<View> defaultViewList = new ArrayList<>(); defaultViewList.add(jsonView); resolver.setDefaultViews(defaultViewList); resolver.setOrder(0); return resolver; } @Bean public ViewResolver jsonViewResolver() { return new JsonViewResolver(); } @Bean public MappingJackson2JsonView jsonView(){ return new MappingJackson2JsonView(); } 83 Chapter 3 ■ Spring MVC @Bean InternalResourceViewResolver getViewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/\"); resolver.setSuffix(\".jsp\" ); resolver.setOrder(1); return resolver; } // other bean definitions ... } In the Java-annotated configuration there is no need to create a ContentNegotiationManager using the ContentNegotiationManagerFactoryBean. Spring does it automatically if you provide a configuration for it by overriding the implementation for the configureContentNegotiation method. JSON View Resolver In this section, in the code samples, the MappingJackson2JsonView is an example of a default View. This is a Spring MVC View implementation that renders JSON content by serializing the model for the current request using the Jackson 2.x ObjectMapper. By default, everything serializable (classes that implement the Serializable interface) in a model map is being serialized, except for framework-specific classes and classes or fields annotated with @JsonIgnore. The configuration for the view is provided by Jackson2ObjectMapperBuilder. The only tiny issue is that there is no view resolver provided by Spring, which could resolve this type of view. So a developer has to create one; but worry not— it’s quite easy: @Component public class JsonViewResolver implements ViewResolver { @Override public View resolveViewName(String viewName, Locale locale) throws Exception { MappingJackson2JsonView view = new MappingJackson2JsonView(); //make JSON output readable using proper indentation view.setPrettyPrint(true); return view; } } When using Java configuration classes, all that is needed is a @Bean annotated method: @Bean public ViewResolver jsonViewResolver() { MappingJackson2JsonView view = new MappingJackson2JsonView(); view.setPrettyPrint(true); return view; } The Jackson library provides a set of annotations designed to be used when implementing classes subjected to JSON serialization to customize what is serialized and in which format. This way of working is similar to JPA and JAXB. 84 Chapter 3 ■ Spring MVC ■ ! the project 03-chapter-07-solution has a view resolver configuration that uses a ContentNegotiatingViewResolver. the data can be viewed in a web page, excel document, pDF document, or JSOn. run it and take a look at the implementation before moving on to the next section. Personalization Beans Most web applications are created to provide a certain service to users from different places in the world, so the application needs to adapt to the language used by those customers (a process called internationalization). Some web applications offer their users the ability to customize the application’s interface based on a number of available themes. Spring offers the ability to easily customize the locale and look-and-feel of a web application via a couple of infrastructure beans. MessageSource To support internationalization, a Spring application must have in its context a bean named messageSource. The class of this bean must implement the MessageSource interface and provides access to localized messages. This class provides concrete implementations for localization methods named getMessage(...). When an ApplicationContext is loaded, it automatically searches for this bean in the context and all calls to getMessage(...) methods are delegated to this bean. Spring provides two out-of-the-box implementations for the MessageSource interface: ResourceBundleMessageSource and StaticMessageSource. The second one allows messages to be registered programmatically and it is intended to be used in testing. The first implementation relies on JDK’s ResourceBundle implementation. Reloading a resource bundle during execution is not possible, as ResourceBundle caches loaded bundles files forever, so the implementation usually used in a web application is ReloadableResourceBundleMessageSource, which is a Spring-specific implementation that accesses bundles using specified base names, participating in the Spring ApplicationContext’s resource loading. This class supports reloading properties files containing the internationalization information; it is usually slightly faster than ResourceBundleMessageSource. Another advantage is that it can read properties files with a specific character encoding. In the following, you can see a simple XML configuration of this bean: <bean id=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\"> <property name=\"basenames\"> <list> <value>/WEB-INF/messages/global<value/> </list> </property> <property name=\"cacheSeconds\">1</property> </bean> When only one resource bundle and the p-namespace are used, the previous definition becomes this: <bean id=\"messageSource\" class=\"o.s.context.support.ReloadableResourceBundleMessageSource\" p:basename=\"/WEB-INF/messages/global\" p:cacheSeconds=\"1\"/> 85 Chapter 3 ■ Spring MVC When Java-based configuration is used, the bean definition looks like this: @Bean public MessageSource getMessageSource(){ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename(\"/WEB-INF/messages/global\"); messageSource.setCacheSeconds(1); return messageSource; } The cacheSeconds property is used to set the number of seconds to cache the loaded property files. Internationalization messages are loaded from properties files under /WEB-INF/messages/; they are named global_[locale].properties. To use the messageSource bean to retrieve internationalized resources inside handler methods, simply inject the bean in the controller and call the desired getMessage(...) method. The Spring type library is used for this purpose too. The fmt tag library, which is a component of JSTL, can be used too. The syntax is a little different, as you can see in the following example: <!-- JSTL fmt way --> <fmt:message key=\"menu.home\"/> <!-- Spring way --> <spring:message code=\"menu.home\"/> When using the spring:message tag, the MessageSource classes can be integrated with the Spring context. The spring:message- tag works with the locale support that comes with Spring. If the “code” attribute isn’t set or cannot be resolved, the “text” attribute is used as the default message. And spring:message supports dynamic names for internationalization codes, so a message code can be an expression: <spring:message code=\"myPrefix.${account.state}\"/> ReloadableResourceBundleMessageSource is able to load messages from properties files with a specific encoding. In order for those messages to be successfully incorporated in a view, Spring provides a class called CharacterEncodingFilter, which is used to apply character encoding to requests. It can work in two modes to do the following: • Enforce the encoding • Apply the encoding if one is not already defined This bean is added to the web.xml file like this: <filter> <filter-name>characterEncodingFilter</filter-name> <filter-class>o.s.web.filter.CharacterEncodingFilter</filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> 86 Chapter 3 ■ Spring MVC <init-param> <param-name>forceEncoding</param-name> <param-value>true</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterEncodingFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> Equivalent Java-based configuration looks like in the following code snippet: \\\\in class implementing WebApplicationInitializer @Override protected Filter getServletFilters() { CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(\"UTF-8\"); characterEncodingFilter.setForceEncoding(true); return new Filter { characterEncodingFilter}; } LocaleResolver In order for the messageBean to solve the messages, a locale must be defined for a web application. The value for the locale is taken from the browser. The bean resolving the locale must be named localeResolver and it must implement the LocaleResolver interface, because the DispatcherServlet looks for such a bean to use. A LocaleResolver can also store a different locale defined by the user. In Spring, there are three types of locale resolvers defined: • AcceptHeaderLocaleResolver: Reads the locale from the request • CookieLocaleResolver: Reads/writes the locale from/to a cookie named org. springframework.web.servlet.i18n.CookieLocaleResolver.LOCALE (unless named otherwise in the bean definition using property cookieName) • SessionLocaleResolver: Reads/writes the locale from/to an HTTP session ■ ! the default name of the cookie can be confusing because it looks like a full name for a static variable, but no such variable exists. the same applies to the theme cookie mentioned in the next section. When a specific LocaleResolver is not defined, AcceptHeaderLocaleResolver is used as default. When users select language, CookieLocaleResolver or SessionLocaleResolver can be used. CookieLocaleResolver is most often used in stateless applications without user sessions; this bean is defined in the mvc-config.xml file. The following definition is quite common: <bean id=\"localeResolver\" class=\"o.s.w.s.i18n.CookieLocaleResolver\" p:defaultLocale=\"en\" p:cookieMaxAge=\"3600\"/> 87 Chapter 3 ■ Spring MVC The cookieMaxAge sets the maximum age in seconds for the cookie. If set to –1, the cookie is deleted only when the client shuts down. In order for Spring to be notified of the changes in the locale, a bean of type LocaleChangeInterceptor needs to be configured. This ensures that the locale interceptor will be applied to all handler mappings. <mvc:interceptors> <bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /> </mvc:interceptors> An equivalent Java configuration for this bean can be used by providing an implementation for the addInterceptors method when implementing WebMvcConfigurer or overriding the same method when extending WebMvcConfigurerAdapter: \\\\in the @Configuration and @EnableWebMvc annotated class @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(localeChangeInterceptor()); \\\\other interceptors can be added here } @Bean public LocaleChangeInterceptor localeChangeInterceptor(){ return new LocaleChangeInterceptor(); } This interceptor detects requests to change the locale by looking for a request parameter named locale by default. The LocaleResolver bean is used to store the value of this parameter. A different name can be set by using a different value for the parameterName property. Request URLs to change the locale are expected to contain the parameter name and a value in the URL: http://myapp.com/?[parameterName]=[locale_name] (under /WEB-INF/messages/ a [filename]_[locale_name].properties files is defined). ThemeResolver If the web application has a customizable look and feel, the different themes can be managed using a bean named themeResolver. The bean resolving the theme has to implement the ThemeResolver interface, because the DispatcherServlet looks for such a bean to identify the resources needed for creating a response. To use a ThemeResolver, you have to do the following:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0\" encoding=\"utf-8\"?",
    "answer": "> <person rel=\"self\" href=\"/person/5\"> <linkList> <link rel=\"parent\" title=\"mother\" href=\"/persons/2\"/> <link rel=\"parent\" title=\"father\" href=\"/persons/3\"/> </linkList> 7This is at http://stateless.co/hal_specification.html. 196 Chapter 5 ■ Spring reStful ServiCeS <firstName>John</firstName> <lastName>Constantine</lastName> <!-- other simple properties--> ... <hospital> <code>134181</code> <!-- other simple properties--> ... </hospital> <identityCard> <pnc>1351001134181</pnc> <!-- other simple properties--> ... </identityCard> </person> Advantages of REST The following list describes the advantages of REST. • REST is simple. • REST is widely supported. • Resources can be represented in a wide variety of data formats (JSON, XML, Atom, etc.). • You can make good use of HTTP cache and proxy servers to help you handle high loads and improve performance. • It reduces client/server coupling. • Browsers can interpret representations. • JavaScript can use representations. • A REST service can be consumed by applications written in different languages. • It is easy for new clients to use a RESTful application, even if the application was not designed specifically for a client. • Because of the statelessness of REST systems, multiple servers can be behind a load balancer and provide services transparently, which means increased scalability. • Because of the uniform interface, documentation of the resources and basic API operations are unnecessary. • The hypermedia constraint assures that application processing transitions are always navigable by clients, simply by following opaque server-provided links. Thus, the client does not need to understand anything more than the data format. (And when JSON is used, the data format is quite obvious.) • Using REST does not imply specific libraries at the client level in order to communicate with the server. With REST, all that is needed is a network connection. 197 Chapter 5 ■ Spring reStful ServiCeS REST services can be secured, but as the interaction between the client and server is stateless, credentials have to be embedded in every request header. Basic authentication is the easiest to implement without additional libraries (HTTP Basic, HTTP Digest, XML-DSIG, or XML-Encryption), but it guarantees the lowest level of security. Basic authentication should never be used without TLS (formerly known as SSL) encryption because the credentials can be easily decoded otherwise. In Figure 5-6, you can see how basic authentication is used when a client communicates with a RESTful application that requires basic authentication. Figure 5-6. Basic authentication when using RESTful systems ! When a collection is expected, it is enough use: /persons (plural) and /hospitals (plural). the /all link was used here because the original web controllers implemented in Chapter 3 were kept separate, so you can access the interface and verify the changes you are doing via reSt in the browser. Basically, the reSt and web functionalities are fully decoupled. and because the PersonsController was already mapped to /persons and the HospitalController was already mapped to /hospitals, there was no other way to do this but to map the reSt controllers to different urls. ! Snippets of code from the HospitalsRestController are not mentioned in the book, because the code is almost identical to the one for the reSt methods in PersonsController; the only difference is the resource type. But the code is available for you to practice on in the book’s code samples. Other common protocols used with RESTful systems are OAuth 1.0a and OAuth 2.0. Custom security implementation should be used only if necessary, because the skill to understand cryptographic digital signatures is quite difficult to master. There may be a lot more to say about REST in general, but the introduction to REST must end here, as this chapter is about Spring and how Spring can be used to develop RESTful applications. And you will notice that providing and consuming REST services with Spring is so easy that a deep understanding of REST is not actually needed. 198 Chapter 5 ■ Spring reStful ServiCeS RESTful Applications Using Spring MVC To learn how to implement and test RESTful services using MVC, module 09-pr-rest-practice was created. This module contains the implementation of the operations depicted in Figure 5-7. Figure 5-7. RESTful architecture for the practice section RESTful Clients with Spring A RESTful application can be accessed by any type of client that can create the type of request supported by the application. To test a Spring RESTful application, Spring provides two classes: RestTemplate and AsyncRestTemplate. The RestTemplate is Spring’s central class for synchronous client-side HTTP access. This class provides a wide set of methods for each HTTP method, which can be used to access RESTful services and enforces REST principles.8 Figure 5-8 depicts a correspondence between HTTP methods and RestTemplate methods that can be used to access REST services. 8Javadoc for this class can be found at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/ springframework/web/client/RestTemplate.html. 199 Chapter 5 ■ Spring reStful ServiCeS Figure 5-8. RestTemplate api to HTTP methods correspondence As you can see, the execute and exchange methods can be used for any type of REST calls, as long as the HTTP method is given as a parameter for the methods. All methods are polymorphic,9 and using one or another depends on the requirements and the developer’s preferences. URI instances are returned to identify resources, and RestTemplate methods support URI templates. So, the following two calls are identical: //using URI Template String url = \"http://localhost:8080/mvc-rest/rest-person/id/{id}\"; Person person = restTemplate.getForObject(url, Person.class, \"1\"); // using URI String url = \"http://localhost:8080/mvc-rest/rest-personid/1\"; Person person = restTemplate.getForObject(url, Person.class); 9Multiple methods with the same name, but different signatures are provided. Just check out the Spring API for RestTemplate at http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/ RestTemplate.html. 200 Chapter 5 ■ Spring reStful ServiCeS The execute method can also be given a RequestCallback implementation as a parameter, which tells the RestTemplate what to do with the request before sending it to the server. Considering this, a GET request for a Person instance with id=1 could be written with the exchange method like this: String url =\"http://localhost:8080/mvc-rest/rest-person/id/{id}\"; Person person = restTemplate.execute(url, HttpMethod.GET, new RequestCallback() { @Override public void doWithRequest(ClientHttpRequest request) throws IOException { HttpHeaders headers = request.getHeaders(); headers.add(\"Accept\", MediaType.APPLICATION_JSON_VALUE); System.out.println(\"Request headers = \" + headers); } }, new HttpMessageConverterExtractor<Person>(Person.class, restTemplate.getMessageConverters()) , new HashMap<String, Object>() {{ put(\"id\", \"1\"); }}); Objects passed to and returned from the methods getForObject(), postForLocation(), and put() are converted to HTTP requests and from HTTP responses by HttpMessageConverters. Message converters are automatically detected and used by Spring in applications configured with <mvc:annotation-driven/> or @EnableWebMvc. In the code sample for this chapter, the representations are in JSON format, so MappingJackson2HttpMessageConverter is used. And because the message format is supported by default, the HttpMessageConverterExtractor<T> is not necessary in the previous example. Also, if no Accept header is specified, all formats supported by Spring are considered. So in this case, RequestCallback becomes unnecessary too, so you can stick to the simpler restTemplate.getForObject method that was mentioned in the previous code snippet. Speaking of message converters, restTemplate deals only with objects, so it internally converts resources to representations, and vice-versa, using message converter implementations of the HttpMessageConverter<T> interface. Spring comes with a default long list of supported message converters, but if necessary, a developer can provide his own implementation of the HttpMessageConverter<T>. Table 5-2 provides a list of the most commonly used message converters and the datatype handled: Table 5-2. Message Converters Message Converter Data Type Observation StringHttpMessageConverter text/plain MappingJackson2HttpMessageConverter application/*+json Only if Jackson 2 is present on the classpath AtomFeedHttpMessageConverter application/atom+xml Only if Rome is present on the classpath RssChannelHttpMessageConverter application/rss+xml Only if Rome is present on the classpath MappingJackson2XmlHttpMessageConverter application/*+xml Only if Jackson 2 is present on the classpath 201 Chapter 5 ■ Spring reStful ServiCeS To use a restTemplate, you can define and initialize it directly where you need it, or declare a bean and inject it. restTemplate handles HTTP connections internally, so the developer does not have to write extra code with opening and closing connections. A different HTTP client can also be used, and Apache provides an implementation that can be injected into a RestTemplate bean. This is highly recommended for production applications when authentication and HTTP connection pooling are usually needed. To use the Apache Commons HttpClient, Spring provides a factory class named HttpComponentsClientHttpRequestFactory, which provides an HttpClient instance that uses a default org.apache.http.impl.conn.PoolingClientConnectionManager10 that is able to service connection requests from multiple execution threads. <bean id=\"restTemplate\" class=\"o.s.web.client.RestTemplate\"> <property name=\"requestFactory\"> <bean class= \"o.s.http.client.HttpComponentsClientHttpRequestFactory\"/> </property> </bean> Configuring a RestTemplate bean using Java Configuration looks like this: \\\\in the @Configuration and @EnableWebMvc annotated class @Bean public RestTemplate restTemplate() { RestTemplate restTemplate = new RestTemplate(); restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory()); return restTemplate; } Other examples of restTemplate usage are in the following code snippet: // GET request to retrieve all persons born at a hospital with a specific code String url = \"http://localhost:8080/mvc-rest/rest-hospitals/{code}/persons\"; Person[] persons = restTemplate.getForObject(url, Person[].class, \"134181\"); // POST request to create a person Person person = buildPerson(); final HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); final HttpEntity<Person> personRequest = new HttpEntity<>(person, headers); String url = \"http://localhost:8080/mvc-rest/rest-persons/create\"; // this method returns the created resource Person newPerson = this.restTemplate.postForObject(url, personRequest, Person.class); //this method returns the URI of the created resource URI uri = this.restTemplate.postForLocation(url, personRequest, Person.class); //DELETE request to delete a person by id String url = \"http://localhost:8080/mvc-rest/rest-persons/delete/23\"; restTemplate.delete(url); 10The class is part of the Apache http-client library. JavaDoc API can be accessed at http://hc.apache.org/ httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/ conn/PoolingClientConnection Manager.html. 202 Chapter 5 ■ Spring reStful ServiCeS REST services are used most commonly by AJAX components in a web application, and currently all HTTP methods are supported in AJAX. But most browsers do not support any other methods besides GET and POST in HTML forms. To use them in a form, Spring has introduced hidden methods. Basically, a hidden input is added to a form with a regular POST method. If the POST request is to be treated as a PUT request, the value of the field will be equal to this method name, as shown in the code sample below. A filter interceptor intercepts the request, searches for that parameter, and modifies the request accordingly before sending it to the appropriate handler. For this to work, the Spring form has the method attribute value set to the desired HTTP method, and the resulting HTML form has a hidden field added: <!-- Spring form --> <sf:form method=\"put\" action=\"..\" modelAttribute=\"..\"> ... </sf:form> <!-- HTML form --> <form method=\"post\" action=\"...\"> <input type=\"hidden\" name=\"method\" value=\"put\" /> ... </form> The filter interceptor that takes care of intercepting requests and modifying the methods is the HiddenHttpMethodFilter, which can be configured in a web.xml file or in a class implementing WebApplicationInitializer. <!-- in web.xml --> <!-- Enables use of HTTP methods PUT and DELETE --> <filter> <filter-name>httpMethodFilter</filter-name> <filter-class>o.s.web.filter.HiddenHttpMethodFilter</filter-class> </filter> <filter-mapping> <filter-name>httpMethodFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> \\\\in class extending AbstractDispatcherServletInitializer \\\\ or AbstractAnnotationConfigDispatcherServletInitializer @Override protected Filter[] getServletFilters() { return new Filter[] { new HiddenHttpMethodFilter()}; } Asynchronous REST Calls At the beginning of this section, AsyncRestTemplate was mentioned. This class can be used to create Spring REST clients that make asynchronous calls to a REST service. The AsyncRestTemplate class is nothing other than a wrapper class for RestTemplate that provides the asynchronous behavior via a set of methods (analogous to the ones in RestTemplate) that return Future<T> wrappers (or ListenableFuture<F> 203 Chapter 5 ■ Spring reStful ServiCeS that extends Future<T> when a callback method is needed) instead of concrete data. An example of an asynchronous GET request can be found in the AsyncRestTemplateTest class, in the 07-pr-rest-solution. In the same class, you can also find an example with a callback. private static final String PERSON_BASE_URL = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; AsyncRestTemplate asyncRestTemplate = new AsyncRestTemplate(); ... Future<ResponseEntity<Person>> futurePerson = asyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\"); //waiting a little, to give time to the async call to complete Thread.sleep(1000L); ResponseEntity<Person> result = futurePerson.get(); Person person = result.getBody(); assertNotNull(person); //callback example ListenableFuture<ResponseEntity<Person>> futurePerson = asyncRestTemplate.exchange(url, HttpMethod.GET, entity, Person.class, \"5\"); futurePerson.addCallback(new ListenableFutureCallback<ResponseEntity<Person>>() { @Override public void onSuccess(ResponseEntity result) { Person person = (Person) result.getBody(); assertNotNull(person); } @Override public void onFailure(Throwable t) { logger.error(\"------> Async call failure!\", t); } }); Implementing REST with Spring MVC There are multiple Java frameworks available for implementing RESTful applications: Spark, Restlet, JAX-RS(Java EE), and RESTEasy, but Spring MVC is the easiest to use. This section contains a lot of information and code snippets to convince you that this affirmation is true. REST support was added to Spring MVC in version 3.0, and although developing RESTful applications was always easy, in version 4.x things have become even more practical. Among the aforementioned frameworks, JAX-RS is shipped with out-of-the-box Spring Integration. This framework encapsulates the Java API for RESTful web services (JAX-RS, defined in JSR 311). Jersey, the reference implementation of JAX-RS, implements support for the annotations defined in JSR 311, making it easy for developers to build RESTful web services by using the Java programming language. It is focused more on application-to-application communication, so the focus is not on browser clients. That’s the amazing thing about Spring MVC—a Spring RESTful application does not care about its client type at all. 204 Chapter 5 ■ Spring reStful ServiCeS Spring MVC provides the following resources to build RESTful applications: • The potential to declare status codes. • URI templates. • Content negotiation. • Many message converters offer out-of-the-box support. • RestTemplate and AsyncRestTemplate classes are used for easily creating client applications or for testing RESTful application services. • Browsers are supported as clients, although HTTP method conversion is necessary for PUT and DELETE methods. When making REST requests from a web page, jQuery can be used (this is covered in Chapter 6). A few of these have already been mentioned in the previous section, as they were involved in creating REST clients; the others are covered in this section. To develop a RESTful service class with Spring MVC, you have to do the most obvious thing: create a controller that contains handler methods that return resources representations instead of views, which are the actual response body. In Spring 3.0, we had to do the following: @Controller @RequestMapping(value = \"/rest-persons\") public class PersonsRestController { @Autowired PersonManager personManager; @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET) public @ResponseBody Person getPersonById(@PathVariable Long id) throws NotFoundException { Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } return person; } } Looks like any MVC controller, right? The only difference is the @ResponseBody that indicates a method return value should be bound to the web response body. The advantage here is that, in the same controller you can also have methods that are not used to provide REST representations, having all the people management data in one place. But, because it is a good practice to decouple code with different scopes, in Spring MVC 4.0 the @RestController was introduced. This annotation is conveniently annotated with 205 Chapter 5 ■ Spring reStful ServiCeS @Controller and @ResponseBody, which practically means that if you annotate a class with it, all handler methods are transparently annotated with @ResponseBody. Also, the purpose of this controller becomes quite obvious—it handles only REST requests. Thus, the preceding code becomes the following: @RestController @RequestMapping(value = \"/rest-persons\") public class PersonsRestController extends BaseController { @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET) public Person getPersonById(@PathVariable Long id) throws NotFoundException { ... // identical content as above } } And this is all. All methods defined inside this class can then be called from REST clients, and they will receive the requested representations. What happens in the background—the way that the DispatcherServlet is involved—is depicted in Figure 5-9. Figure 5-9. Spring MVC RESTFul Container 206 Chapter 5 ■ Spring reStful ServiCeS So basically, the controller methods return data directly to the client—data that no longer needs to be processed in order to render a view. Every time a request is mapped to a handler method that has parameters annotated with @RequestBody, or the method is annotated with @ResponseBody, Spring loops over all HttpMessageConverters; it is seeking the first that fits the given MIME type and class, and then uses it for the actual conversion. Mapping requests to methods is the same as with web controllers. All annotations applicable in web handler methods are applicable in REST handler methods too: @PathVariable, @Valid, and so forth. @RequestParam can be used too, but this would break the REST constraints mentioned at the beginning of the chapter. HTTP Status Codes When a web application returns a response, that response has a status code that describes a certain state of the returned resource or the result of the operation that the request triggered on the server. The most familiar is probably the 404 Not Found status code that is returned when a requested resource cannot be found. A full list of HTTP status codes can be found on Wikipedia, which you should look at if you are curious about and unfamiliar with HTTP status codes.11 RESTful applications use HTTP status codes to communicate with their clients. With Spring MVC, the status code of a response can be set easily using the @ResponseStatus annotation. This annotation can receive as a value any of the constants defined in Spring class HttpStatus. Table 5-3 contains the most common response statuses used in RESTful applications. Here are some examples of @ResponseStatus annotated REST handlers that you will work with in the practice project for this chapter: @ResponseStatus(HttpStatus.NO_CONTENT) @RequestMapping(value = \"/delete/{pnc}\", method = RequestMethod.DELETE) public void deletePerson(@PathVariable String pnc) throws NotFoundException { ... } @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public Person createPerson(@RequestBody @Valid Person newPerson) { ... } @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/all\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public List<Person> getAll() { ... } 11See http://en.wikipedia.org/wiki/List_of_HTTP_status_codes. 207 Chapter 5 ■ Spring reStful ServiCeS Table 5-3. HTTP Status Codes HTTP Status HttpStatus Constant Observation 200 OK Successful GET with returned content. 201 CREATED Successful PUT or POST; location header should contain URI or new resource. 204 NO_CONTENT Empty response; after successful PUT or DELETE. 404 NOT_FOUND Resource was not found. 403 FORBIDDEN Server is refusing to respond to the request, because the response is not authorized. 405 METHOD_NOT_ALLOWED HTTP method is not supported for the resource identified by the Request-URI. 409 CONFLICT Problems when making changes, when PUT or POST try to save data that already exists and is marked as unique 415 UNSUPPORTED_MEDIA_TYPE The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method. ! the \"produces\" and \"consumes\" properties are covered later in the chapter. ! normally, void or null returning methods result in a default view name determined by the request’s path information (from @RequestMapping annotations on the class and method, as explained in Chapter 3).the @ResponseStatus overrides the default behavior, causing a null ModelAndView to be used, which indicates that the response has been handled by the controller method already. So, obviously the @ResponseStatus is mandatory for a reStful handler method returning void or null. Exception Handling The status codes can be used for exception handlers too. Yes, RESTful handlers can also throw exceptions, and they have to be properly handled. Similar to Spring MVC web specific controllers, exception handlers can be defined either in the body of the REST controller, or they can be defined in class annotated with @ControllerAdvice. And the same ExceptionHandler annotation is used to annotate the exception handler methods. In the next code snippet, such a class was defined with two exception handlers for different types of exceptions, and the handlers were limited to the com.pr.rest package, using the basePackages attribute, in order to handle exceptions thrown only by controllers in that package. 208 Chapter 5 ■ Spring reStful ServiCeS @ControllerAdvice(basePackages = \"com.pr.rest\") public class RestExceptionProcessor { private Logger logger = LoggerFactory.getLogger(RestExceptionProcessor.class); //Maps IllegalArgumentExceptions to a 404 Not Found HTTP status code @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"This entity is not found in the system\") @ExceptionHandler({NotFoundException.class}) public void handleNotFound(NotFoundException nfe) { // just return empty 404 logger.info(\"-----> Entity \" + nfe.getObjType() + \" with identifier\" + nfe.getObjIdentifier() + \"not found.\"); } // Maps DataIntegrityViolationException to a 409 Conflict HTTP status code. @ResponseStatus(value = HttpStatus.CONFLICT, reason = \"Another entity with the same identity exists\") @ExceptionHandler({DataIntegrityViolationException.class}) public void handleAlreadyExists() { // just return empty 409 logger.info(\"-----> Entity save operation failure\"); } } Content can be returned using an exception handler, but in this case, the client must be implemented to handle the response. @ExceptionHandler(NotFoundException.class) @ResponseStatus(value= HttpStatus.NOT_FOUND) @ResponseBody public JsonError personNotFound(HttpServletRequest req, NotFoundException ex) { Locale locale = LocaleContextHolder.getLocale(); String errorMessage = messageSource. getMessage(\"error.no.person.id\", null, locale); errorMessage += ex.getObjIdentifier(); String errorURL = req.getRequestURL().toString(); return new JsonError(errorURL, errorMessage); } ... public class JsonError { private String url; private String message; public JsonError(String url, String message) { this.url = url; this.message = message; } // getters and setters } 209 Chapter 5 ■ Spring reStful ServiCeS The “produces” and “consumes” Properties In the previous examples, the consumes and produces annotation properties of the @RequestMapping were used. These two attributes are used to narrow the primary mapping for a request. The consumes attribute defines the consumable media types of the mapped request (defined on the server) and the value of the Content-Type header (defined on the client side) must match at least one of the values of this property in order for a method to handle a specific REST request. Let’s say, for example, that in the REST client, the following headers were set: final HttpHeaders headers = new HttpHeaders(); final String url = \"http://localhost:8080/mvc-rest/rest-persons/create\"; \\\\\"application/json\" headers.setContentType(MediaType.APPLICATION_JSON); final HttpEntity<Person> personRequest = new HttpEntity<>(person, headers); Person newPerson = restTemplate.postForObject(url, personRequest, Person.class); On the server, the following REST handler would be mapped to process this request: @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = {MediaType.APPLICATION_JSON_VALUE, //Public constant media type for {@code application/octet-stream}. MediaType.APPLICATION_OCTET_STREAM}) public Person createPerson(@RequestBody @Valid Person newPerson) { ... } The produces attribute defines the producible media types of the mapped request, narrowing the primary mapping. The value of the Accept header (on the client side) must match at least one of the values of this property in order for a method to handle a specific REST request. Let’s say, for example, that in the REST client there is the following request: final String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; Person person = restTemplate.execute(url, HttpMethod.GET, request -> { HttpHeaders headers = request.getHeaders(); headers.add(\"Accept\", MediaType.APPLICATION_JSON_VALUE); }, new HttpMessageConverterExtractor<>(Person.class, restTemplate.getMessageConverters()) , new HashMap<String, Object>() {{ put(\"id\", \"1\"); }}); ! as mentioned, the code for making a reSt request for a person can be far simpler than what was depicted earlier. the execute method was used here to show how this method can be used. 210 Chapter 5 ■ Spring reStful ServiCeS On the server, the following REST handler would be mapped to process this request: @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/id/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public Person getPersonById(@PathVariable Long id) throws NotFoundException { return personManager.findById(id) } Accessing Servlet Environment and Request Data Because RESTful controllers are run in a servlet environment, and the interface is the DispatcherServlet, the servlet environment properties can be injected and accessed in the same manner presented in Chapter 3. The RESTful handler methods can have flexible signatures. HttpServletRequest or HttpServletResponse can be used as parameters, and Spring will take care of populating them for you. The @PathVariable and @RequestParam annotations can be used to tell Spring to inject request data automatically. @Valid can be used to validate resources submitted with POST or PUT. And so on. Even SpEL expressions are supported. The next example depicts a REST handler for a POST method, which creates a person and adds the URI of the new resource; this is built from the original request URL that is populated by Spring as a value for the Location header: @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create2\", method = RequestMethod.POST) public void createPerson2(@RequestBody @Valid Person newPerson, @Value(\"#{request.requestURL}\")StringBuffer originalUrl, HttpServletResponse response) { Person person = personManager.save(newPerson); logger.info(\"-----> PERSON: \" + person); response.setHeader(\"Location\", getLocationForPersonResource(originalUrl, person.getId())); } //Determines URL of person resource based on the full URL of the given request, //appending the path info with the given childIdentifier using a UriTemplate. protected static String getLocationForPersonResource (StringBuffer url, Object childIdentifier) { String newURL = url.toString(); newURL = newURL.replace(\"create2\", \"id/{id}\"); UriTemplate template = new UriTemplate(newURL); return template.expand(childIdentifier).toASCIIString(); } 211 Chapter 5 ■ Spring reStful ServiCeS Another method for accessing request and response is the HttpEntity<T> class and its subclasses: RequestEntity<T> and ResponseEntity<T>. By using these classes, you can get access to the request and response body. RequestEntity<T> and ResponseEntity<T> can be used as follows: • In the REST client to encapsulate every detail about a REST request that is made by calling restTemplate.exchange. final String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; final RequestEntity<Person> entity = RequestEntity.post(new URI(url)) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) //setting a custom header that will be accessed in the handler method .header(\"custom\", \"true\") .body(person); ResponseEntity<Person> response = restTemplate.exchange(entity, Person.class); Person newPerson = response.getBody(); //get URI location for the Person created HttpHeaders headers = response.getHeaders(); URI uri = headers.getLocation(); • In the RESTful handler method to access request headers, read the body of a request, and write headers to the response stream. @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create3\", method = RequestMethod.POST) public ResponseEntity<Person> handle(HttpEntity<Person> requestEntity, @Value(\"#{request.requestURL}\") StringBuffer originalUrl) throws UnsupportedEncodingException { // will return \"true\" String requestHeader = requestEntity.getHeaders().getFirst(\"custom\"); //we are just making sure the header is the one sent from the client assertTrue(Boolean.parseBoolean(requestHeader)); Person person = requestEntity.getBody(); Hospital hospital = hospitalManager. findByCode(person.getHospital().getCode()); person.setHospital(hospital); Person newPerson = personManager.save(person); HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.set(\"Location\", getLocationForPersonResource(originalUrl, person.getId())); return new ResponseEntity<>(newPerson, responseHeaders, HttpStatus.CREATED); } 212 Chapter 5 ■ Spring reStful ServiCeS ! as with @RequestBody and @ResponseBody, Spring uses HttpMessageConverter<T> to convert to and from the request and response streams. the HttpMessageConverter<T> and supported implementations were covered in the “reStful applications using Spring MvC” section. Asynchronous REST Services Using @Async Annotated Methods The “Asynchronous REST Calls” section showed how to make an asynchronous REST call using the AsyncRestTemplate class. In that case, the client did the rest call and could then focus on other operations until the Future object returned the concrete data. But asynchronous calls can be made in a different way using @Async annotated methods. This annotation marks a method as a candidate for asynchronous execution. It can also be used at type level; in this case, all methods in the class are considered asynchronous. Asynchronous methods can have any signature and any parameter types. There are absolutely no restrictions about this. However, the return type is restricted to void and Future (and implementations of this interface). Immediately after a client calls an asynchronous method, the invocation returns and the execution of the method is submitted to a Spring TaskExecutor12. Asynchronous methods that return void are used when the client does not expect a reply. By default, to execute a method annotated with @Async, the executor that is used is the one supplied to the <task:annotation-driven/> element. (The Spring Task namespace was introduced in Spring 3.0 to help configure TaskExecutor and TaskScheduler instances.) <task:annotation-driven executor=\"prExecutor\"/> <task:executor id=\"prExecutor\" pool-size=\"100\"/> In Java Configuration, support for @Async can be enabled using @EnableAsync in one of the configuration classes of the application—those annotated with @Configuration. To provide a different executor, like in the preceding XML example, the class must implement org.springframework.scheduling. annotation.AsyncConfigurer and provide a concrete implementation for the getAsyncExecutor method. @Configuration @EnableAsync public class AppConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(100); executor.initialize(); return executor; } ... } 12Spring’s TaskExecutor interface is equivalent to the java.util.concurrent.Executor interface and extends it without modifying the API in order for clients to declare a dependency on an executor and receive any TaskExecutor implementation. It was created to remove the need for Java libraries when using thread pools. 213 Chapter 5 ■ Spring reStful ServiCeS Also the @Async annotation has a value attribute to indicate that an executor other than the default should be used when the executor13 is defined as a bean: @Async(\"otherExecutor\") public Future<Person> findPerson(Long id) throws InterruptedException { String url = \"http://localhost:8080/mvc-rest/rest-persons/id/{id}\"; Person person = restTemplate.getForObject(url, Person.class, \"1\"); Thread.sleep(1000L); return new AsyncResult<>(person); } <!-- in a spring configuration file we define an Executor bean --> <bean id=\"otherExecutor\" class=\"o.s.scheduling.concurrent.ThreadPoolTaskExecutor\" init-method=\"initialize\" destroy-method=\"shutdown\"> <property name=\"corePoolSize\" value=\"100\"/> </bean> // in a class annotated with @Configuration @Bean(name=\"otherExecutor\", destroyMethod = \"shutdown\", initMethod = \"initialize\") ThreadPoolTaskExecutor getExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(100); return executor; } ! an example of an @Async annotated method and usage can be found in 07-pr-rest-solution. the example is covered in the “practical exercise” section. Intercepting REST Calls There is a section in Chapter 3 about handler interceptors for controller methods, which mentions that REST requests can be intercepted too, but the REST interceptors have to implement the ResponseBodyAdvice<T> or extend one of its subclasses and provide the proper implementation for the beforeBodyWrite and supports. When extending JsonViewResponseBodyAdvice or AbstractMappingJacksonResponseBodyAdvice, the beforeBodyWriteInternal method must be implemented, because the AbstractMappingJacksonResponseBodyAdvice class provides a concrete implementation for beforeBodyWrite, which calls beforeBodyWriteInternal after creating a proper JSON body container. ResponseBodyAdvice<T> implementation allows you to customize the response after the execution of a @ResponseBody or a ResponseEntity<T> method, but before being passed for conversion to an HTTP message converter. These interceptors are annotated with @ControllerAdvice and are automatically picked up and used by Spring. 13You can see all methods available for a ThreadPoolTaskExecutor at http://docs.spring.io/spring/docs/4.1.x/ javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html. 214 Chapter 5 ■ Spring reStful ServiCeS In the 07-pr-rest-solution module, such an interceptor is implemented for you: @ControllerAdvice(basePackages = \"com.pr.rest\") //this interceptor is retricted to the classes in package \"com.pr.rest\" public class AuditRestInterceptor extends JsonViewResponseBodyAdvice { private Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class); @Override public boolean supports(MethodParameter returnType, Class converterType) { logger.info(\"-----> Audit REST interceptor supports(Person.class) ? \" + Person.class.isAssignableFrom(returnType.getParameterType())); return (super.supports(returnType, converterType) && returnType.getMethodAnnotation(JsonView.class) != null); } .... } The supports method tests if the AuditRestInterceptor supports the given controller method return type and the selected HttpMessageConverter<T> type. The value logged in the preceding supports method implementation is true if the controller method return type is assignable to a reference of type Person. @ControllerAdvice(basePackages = \"com.pr.rest\") //this interceptor is retricted to the classes in package \"com.pr.rest\" public class AuditRestInterceptor extends JsonViewResponseBodyAdvice { private Logger logger = LoggerFactory.getLogger(AuditRestInterceptor.class); ... @Override protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) { logger.info(\"-----> Audit REST interceptor beforeBodyWrite\"); response.getHeaders().add(HttpHeaders.CONTENT_ENCODING, \"UTF-8\"); super.beforeBodyWriteInternal(bodyContainer, contentType, returnType, request, response); } } In the beforeBodyWriteInternal, the CONTENT_ENCODING header is added to the response, so the presence of this header can be tested in the client and you can make sure that the interceptor did its job. After that, the super.beforeBodyWriteInternal() is called to keep the original behavior of the extended class, which is to modify the response body before being converted and sent back to the client. 215 Chapter 5 ■ Spring reStful ServiCeS You see this interceptor in action when testing your REST services, because the log messages are printed in the log console. INFO c.p.r.AuditRestInterceptor - --> Audit REST interceptor supportsPerson.class ? true INFO c.p.r.AuditRestInterceptor - --> Audit REST interceptor beforeBodyWrite Using Spring HATEOAS HATEOAS and Spring HATEOAS project were mentioned at the beginning of the chapter. When the Hypermedia REST constrains are respected by a REST service, it is said that the service is a Hypermedia Driven REST web service. Hypermedia is quite important for REST, because it allows you to build services that are almost fully decoupled from their clients. The representations returned by the REST services contain links that indicate further locations of resources that the client needs access to. To build a Hypermedia Driven REST web service with Spring, the spring-hateoas dependency must be added to the project. The current version of spring-hateoas is 0.17.0.RELEASE. This library (it is only one jar currently, but it will probably grow into a framework) provides a set of classes used to generate resource URIs. It also provides classes to decorate representations with links to return to the HATEOAS complying client. In this chapter’s examples, the Person class is wrapped inside a PersonHateoas class that extends the core class of spring-hateoas: ResourceSupport. This class provides methods useful to add links to representations and to access representations links. The PersonHateoas looks like this: ... import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty; import org.springframework.hateoas.ResourceSupport; public class PersonHateoas extends ResourceSupport { private Person person; @JsonCreator public PersonHateoas(@JsonProperty(\"person\") Person person) { this.person = person; } public Person getPerson() { return person; } } The PersonHateoas class has a field of type Person. By extending class ResourceSupport, methods to generate HATEOAS links and references are inherited. When requesting a Person resource from a HATEOAS REST service, a PersonHateoas is serialized and sent to the client. When the serialization is done in JSON format, some specific JSON annotations are needed when declaring the PersonHateoas class. The @JsonProperty specifies that at serialization time, the resulted object will contain a property named person that will be mapped to a serialized version of the Person instance. Looks like a simple POJO, right? Well, that’s what it is. 216 Chapter 5 ■ Spring reStful ServiCeS A controller that returns an instance of PersonHateoas must define handler methods that populate the PersonHateoas instances with HAREOAS-specific links. In order to do, Spring offers utility methods that allow you to create links by pointing to controller classes, which are grouped under the ControllerLinkBuilder. The controller and the method do nothing special, except that before returning the response, the personHateoas object is populated with its own URI, using utility methods from the ControllerLinkBuilder class that link together in a very readable way. For example, the underlined code snippet in the previous example can be read like this: Add link to which the handler method getPersonHateoasById from the PersonHateoasController class is mapped, with PathVariable id equal to person.getId() to the personHateoas ph instance. The sources for spring-hateoas are available on GitHub at https://github.com/spring-projects/spring-hateoas. In the following code snippet, the linkTo and methodOn methods from ControllerLinkBuilder are statically imported and used to generate the resource link for the Person instance with id=1. ... import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo; import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn; @RestController @RequestMapping(value = \"/hateoas\") public class PersonHateoasController { private Logger logger = LoggerFactory.getLogger(PersonHateoasController.class); @ResponseStatus(HttpStatus.OK) @RequestMapping(value = \"/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public HttpEntity<PersonHateoas> getPersonHateoasById( @PathVariable Long id) throws NotFoundException { logger.info(\"-----> PERSON: \" + id); Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } PersonHateoas ph = new PersonHateoas(person); ph.add( linkTo( methodOn(PersonHateoasController.class) .getPersonHateoasById(person.getId()) ).withSelfRel() ); return new ResponseEntity<>(ph, HttpStatus.OK); } } In the previous example, the controller class is the one that takes care of setting the links by inspecting the mappings. But Spring provides another way—by using EntityLinks implementations. To use them, the controller class must be annotated with @ExposesResourcesFor, which makes EntityLinks available 217 Chapter 5 ■ Spring reStful ServiCeS by dependency injection. Also, the configuration class must be annotated with @EnableEntityLinks. The EntityLinks interface API exposes methods to access links pointing to controllers backing an entity type. So the controller becomes this: ... import org.springframework.hateoas.EntityLinks; import org.springframework.hateoas.ExposesResourceFor; @Controller @ExposesResourceFor(Person.class) @RequestMapping(\"/hateoas\") public class PersonHateoasController extends BaseController { private Logger logger = LoggerFactory.getLogger(PersonHateoasController.class); @Autowired private EntityLinks entityLinks; @RequestMapping(value = \"/{id}\", method = RequestMethod.GET, produces = \"application/hal+json\") public HttpEntity<PersonHateoas> getPersonHateoasById (@PathVariable Long id) throws NotFoundException { logger.info(\"-----> PERSON: \" + id); Person person = personManager.findById(id); if (person == null) { throw new NotFoundException(Person.class, id.toString()); } PersonHateoas ph = new PersonHateoas(person); ph.add(entityLinks.linkForSingleResource(Person.class, id).withSelfRel()); return new ResponseEntity<>(ph, HttpStatus.OK); } } And the @EnableEntityLinks annotation is added to the configuration class. Also, to enable HAL support, the EnableHypermediaSupport should be added to the configuration class too. import org.springframework.hateoas.config.EnableEntityLinks; import org.springframework.hateoas.config.EnableHypermediaSupport; import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType; ... @EnableEntityLinks @EnableHypermediaSupport(type= {HypermediaType.HAL}) @Configuration @EnableWebMvc @ComponentScan(basePackages = {\"com.pr, com.pr.web, com.pr.rest, com.pr.hateoas\"}) @ImportResource({\"classpath:spring/app-service-config.xml\", \"classpath:spring/db-config.xml\"}) public class WebConfig extends WebMvcConfigurerAdapter { .... } 218 Chapter 5 ■ Spring reStful ServiCeS The full documentation for spring-hateoas can be found at http://docs.spring.io/spring-hateoas/ docs/current/reference/html/. The Hypermedia Driven REST web service that was just created can be tested with restTemplate, just like any REST service. But to deserialize the HATEOAS links correctly, a custom MappingJackson2HttpMessageConverter must be set for the restTemplate. The ObjectMapper must also be customized to register the Jackson2HalModule implementation provided by Spring HATEOAS. import org.springframework.core.ParameterizedTypeReference; import org.springframework.hateoas.Resource; import org.springframework.hateoas.hal.Jackson2HalModule; ... public class PersonHateoasControllerTest { @Test public void getHateoasPerson() throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.configure (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.registerModule(new Jackson2HalModule()); MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); converter.setSupportedMediaTypes( MediaType.parseMediaTypes(\"application/hal+json\")); converter.setObjectMapper(mapper); RestTemplate restTemplate = new RestTemplate( Collections.<HttpMessageConverter<?>> singletonList(converter)); String url = \"http://localhost:8080/mvc-rest/hateoas/{id}\"; ResponseEntity<PersonHateoas> responseEntity = restTemplate.getForEntity(url, PersonHateoas.class, \"1\"); PersonHateoas personHateoas = responseEntity.getBody(); assertNotNull(personHateoas); assertTrue(personHateoas.hasLinks()); assertEquals(\"http://localhost:8080/mvc-rest/hateoas/1\", ppersonHateoas.getLink(\"self\").getHref()); assertEquals(\"John\", personHateoas.getPerson().getFirstName()); assertEquals(\"Smith\", personHateoas.getPerson().getLastName()); } } 219 Chapter 5 ■ Spring reStful ServiCeS And the response sent to the client will look like this: {\"person\": {\"firstName\":\"John\", \"middleName\":null, \"lastName\":\"Smith\", \"dateOfBirth\":\"1935-10-01\", \"gender\":\"MALE\",\" \"hospital\":{...}, \"identityCard\":{...}, \" links\":{\"self\":{\"href\":\"http://localhost:8080/mvc-rest/hateoas/1\"}} } ! the hospital and identityCard objects are not displayed in the previous example, as their contents are not relevant for it. the content of those properties represents the JSOn serialization of the hospital and identityCard fields specific to the Person instance. their contents are displayed in figure 5-15. The response body contains two properties: \"person\" and \"links\". The \"person\" property value is the JSON representation of the Person instance with id=1. The \"links\" property contains a link and its meaning. The \"rel\":\"self\" tells the client that the link points to the current resource. In this chapter, the fundamentals of creating and consuming RESTful services with Spring MVC were covered, which is enough for the certification exam. Summary After reading this chapter, you should have a proper understanding of how Spring can be used to provide and consume REST services. Here is a simple list of topics that you should keep handy when reviewing your acquired knowledge: • What is REST? • What type of clients can access a web application? • How are resources exposed to the client? • How many types of representations are supported? • What is the difference between @Controller and @RestController? • Make sure that you can describe Spring MVC support for RESTful applications. • Understand how to access request/response data. • Use message converters. • How is asynchronous REST supported? • What is HATEOAS? • How do you build a HATEOAS complying service with Spring HATEOAS and MVC? 220 Chapter 5 ■ Spring reStful ServiCeS Quick Quiz Question 1: What is REST? A. a software design pattern B. a framework C. an architecture style Question 2: Which of the following methods are HTTP methods? A. PUT B. GET C. SUBMIT D. OPTIONS Question 3: What Spring class can be used to access and test REST services? A. RestTemplate B. AsyncRestTemplate C. Both D. None Question 4: What does the RestTemplate handle? A. Resources B. Representations C. Both Question 5: What can be said about the @RestController annotation? A. It is used to declare a controller providing REST services. B. Is annotated with @Controller and @ResponseBody. C. Controller methods annotated with @RequestMapping assume @ResponseStatus semantics by default when the controller is annotated with @RestController. Question 6: What is the effect of annotating a method with @ResponseStatus? A. The default behavior for resolving to a view for methods returning void or null is overridden. B. The HTTP status code matching the @ResponseStatus is added to the response body. C. It forces usage of HTTP message converters. Question 7: Which of the following HTTP message converters are supported by Spring MVC? A. StringHttpMessageConverter B. MappingJackson2HttpMessageConverter, but Jackson2 must be in the classpath C. YamlMessageConverter 221 Chapter 5 ■ Spring reStful ServiCeS Question 8: Which of the following RestTemplates can be used to make a GET REST call to a URL? A. restTemplate.getForObject(...) B. optionsForAllow(...) C. getForEntity(...) D. exchange(..., HttpMethod.GET,...) Question 9: Does the following REST handler method comply with the HATEOAS constraint? @ResponseStatus(HttpStatus.CREATED) @RequestMapping(value = \"/create\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public Person createPerson(@RequestBody @Valid Person newPerson) { logger.info(\"-----> CREATE\"); Hospital hospital = hospitalManager.findByCode( newPerson.getHospital().getCode()); newPerson.setHospital(hospital); Person person = personManager.save(newPerson); logger.info(\"-----> PERSON: \" + person); return person; } A. Yes, because it returns a representation of the object that was created. B. No, because it does not set the location header to the URI of the created resource. C. This is not a REST handler method. D. No, because a Link object is not added to the returned resource. Practical Exercise The practical exercises for this chapter require you to develop some REST client test methods to check your understanding of implementing RESTful application with Spring MVC. The project module is named 07-pr-rest-practice. An analogous module with proposed solutions exists, which is named 07-pr-rest-solution. The projects and their TODOs are shown in Figure 5-10. 222 Chapter 5 ■ Spring reStful ServiCeS Figure 5-10. Projects associated with this chapter The project is split into packages that contain classes grouped by purpose: • com.pr.config contains the Java Configuration class used to configure the application. • com.pr.hateoas contains classes that describe a hypermedia-driven REST web service • com.pr.problem contains classes that handle the exceptions thrown in the application. – GlobalExceptionHandler handles exceptions thrown by methods in the controllers under the com.pr.web package. The restriction is done using @ControllerAdvice(basePackages = \"com.pr.web\"). – NotFoundException is a type of exception thrown when a resource cannot be found. – RestExceptionProcessor handles exceptions thrown by methods in the REST controllers under the com.pr.rest package. 223 Chapter 5 ■ Spring reStful ServiCeS • com.pr.rest contains classes that implement REST services and interceptors. – AuditRestInterceptor is an interceptor for REST services that prints simple messages and adds a header to the response before it is written. – HospitalsRestController is a REST controller for managing Hospital resources. – PersonsRestController is a REST controller for managing Person resources. • com.pr.web contains the web controllers that receive requests from a browser and return views. The structure of the project is depicted in Figure 5-11. Figure 5-11. Package organization of the 07-pr-rest-practice project module The tests for the rest controllers are located under the same packages as the controllers being tested. The only exception is the com.pr.async that contains a configuration class, a service class, and a test class used to test an asynchronous REST method annotated with @Async. You have no TODO tasks in this package; the example is simply provided for you to run it and see how an REST asynchronous is made. All the TODO tasks are in the RestPersonControllerTest class. They cover GET, POST, and DELETE operations. The practical exercise for this chapter requires Gradle tasks to be run in parallel, because the REST tests require the web application to be started. To do this, you have to create an Intellij IDEA Gradle launcher to start the application, and another to stop it. The test cases are run by right-clicking the method you want to execute, and then selecting Run from the menu that appears. 224 Chapter 5 ■ Spring reStful ServiCeS To create a Gradle launcher, you have to do the following:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0\" encoding=\"UTF-8\"?",
    "answer": "> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <!-- states and actions will be placed here later --> </flow> The flows are exposed to the client as web resources. The client starts flows by accessing these resources. For example, accessing http://localhost:8080/webflow-basic/persons/newPerson starts the newPerson flow. (The reason the URL has that particular structure is explained later.) Starting a flow actually means starting a new flow execution, meaning an execution context for the task currently in progress is created. The execution context is user session-scoped, meaning all the variables and data needed for the execution of the task is kept in the user session, unless an execution step requires otherwise. (Sometimes data can be saved to the database and removed from the session.) Web Flow Internal Logic When the flow starts executing, you can use the URL changing to http://localhost:8080/webflow-basic/persons/newPerson?execution=e1s1 The parameter execution is the session-scoped execution key. Its value contains the flow execution identifier (e1) and the identifier of the execution step that is currently in progress (s1). Every time the flow progresses a step, the step identifier is incremented. Every time a new flow execution is started, the execution identifier is incremented. A user resumes flow executions by clicking buttons in the interface—buttons (or links) that have events associated with them using the name property. For example: <button id=\"newPersonButton\" name=\" eventId proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> So when the button with the newPersonButton id is clicked, a request is sent to the URL. .../persons/newPerson?execution=e1s1&_event_id=proceed The data provided by the user is bound to the flow context. The flow handles the event, processes the data as defined, and decides what to do next based on the definition of the flow: display a new view to the user, display the same view, and remain in the same step of execution if validation failed or ends the flow. When a flow execution has ended, the execution cannot be resumed; this implies that the transaction cannot be completed multiple times. After a flow execution ends, the flow state is automatically cleaned. The interaction between a client and a flow always consists of two separate steps: the client will request a resource or activate (trigger) an event and the flow will redirect to the appropriate state. This means that each web flow interaction involves two requests: the client request and the flow redirect request. This has another implication: the data submitted by the initial request will not be available after the redirecting is 261 Chapter 7 ■ Spring Web FloW done and the next view has already been rendered. But there are ways of persisting the data across requests when using web flows; this is covered later in the chapter. In Figure 7-4, the interaction between the client and a flow is displayed. Figure 7-4. Schema of an interaction between the client and a flow Configuration and Infrastructure Beans Spring provides two ways of configuring the environment in which the web flow components can be used: using an the XML namespace and defining the infrastructure beans in an webflow-config.xml file, or using Java Configuration annotations by defining a configuration class that extends a specific Spring class. ■ ! the configuration file can be named in whatever way the developer desires, as long as it is relevant in the context of the developed application. the beans can be defined in any other Spring configuration file already existing in the application; but the recommended approach and best practice is to keep infrastructure beans definitions grouped by their purpose. in the application used for practice with this book, the beans are grouped as follows: • MVC infrastructure beans in mvc-config.xml • application custom beans in app-config.xml • Web Flow infrastructure beans in webflow-config.xml • Security infrastructure beans in security-config.xml 262 Chapter 7 ■ Spring Web FloW When configuring an application that uses Web Flow, there are roughly three steps that have to be covered:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0\" encoding=\"UTF-8\"?",
    "answer": "> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <mvc:annotation-driven conversion-service=\"typeConversionService\" validator=\"validator\"/> <bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/> <!-- Define a custom ConversionService --> <bean id=\"typeConversionService\" class=\"o.s.format.support.FormattingConversionServiceFactoryBean\"> ... </bean> 263 Chapter 7 ■ Spring Web FloW <!-- other Spring MVC specific beans, look in Chapter 3 for reference --> ... <!-- Maps requests to flows in the flowRegistry; e.g. a path of /persons/newPerson looks for a flow with id \"persons/newPerson\" --> <bean id=\"flowMappings\" class=\"org.springframework.webflow.mvc.servlet.FlowHandlerMapping\" p:order=\"-1\" p:flowRegistry-ref=\"flowRegistry\"/> <!-- Dispatches requests mapped to flows to FlowHandler implementations --> <bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerAdapter\" p:flowExecutor-ref=\"flowExecutor\"/> </beans> In the previous example, because <mvc:annotation-driven/> is used, the annotation-driven Spring MVC Controller programming model is automatically enabled, and no other HandlerMapping implementation needs to be defined. However, the FlowHandlerMapping must be the first HandlerMapping implementation used to try to retrieve a mapping to make sure that the flow is identified correctly; that’s why order=\"-1\" is used to set the highest priority in the handler mappings list. This class returns null in the case of no flow id match, allowing the next handler mapping in the chain to execute. In the webflow-config.xml file, the Spring Web Flow–specific beans are defined and the specific namespace are used: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:webflow=\"http://www.springframework.org/schema/webflow-config\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/webflow-config http://www.springframework.org/schema/webflow-config/spring-webflow-config.xsd\"> <!-- Executes web flows --> <webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\" /> <!-- Contains the flows defined by this application --> <webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\" flow-builder-services=\"flowBuilderServices\"> <webflow:flow-location-pattern value=\"**/*-flow.xml\" /> </webflow:flow-registry> <!-- Configures services needed to build flow definitions --> <webflow:flow-builder-services id=\"flowBuilderServices\" view-factory-creator=\"mvcViewFactoryCreator\" conversion-service=\"conversionService\" development=\"true\" /> 264 Chapter 7 ■ Spring Web FloW <!-- Configures Web Flow to render Tiles views resolved by Spring MVC --> <bean id=\"mvcViewFactoryCreator\" class=\"org.springframework.webflow.mvc.builder.MvcViewFactoryCreator\"> <property name=\"viewResolvers\" ref=\"tilesViewResolver\" /> <property name=\"useSpringBeanBinding\" value=\"true\"/> </bean> <!-- Configures Web Flow to automatically convert custom types (using the same converter as for Spring MVC) --> <bean id=\"conversionService\" class=\"org.springframework.binding.convert.service.DefaultConversionService\"> <constructor-arg ref=\"typeConversionService\" /> </bean> </beans> The Spring webflow-config namespace provides XML elements that make defining Spring Web Flow components more practical and more readable for the user, but a more detailed explanation is needed for the preceding configuration. • flowExecutor: This bean created is of type FlowExecutorImpl and it uses the flowRegistry bean to identify all flows eligible for execution. This bean is the entry point into the Web Flow system, as it manages starting and resuming flow executions. When an executor bean is created, Spring automatically looks for a flow registry bean named flowRegistry, so the preceding definition can be simplified to <webflow:flow-executor id=\"flowExecutor\"/> Also, because this is the central bean of the Spring Web Flow engine, listeners can be registered for it to verify rights to perform specific execution steps or audit the execution steps for debugging purposes. <webflow:flow-executor id=\"flowExecutor\"> <webflow:flow-execution-listeners> <webflow:listener ref=\"secureFlowExecutionListener\" /> <webflow:listener ref=\"auditFlowExecutionListener\" /> <webflow:flow-execution-listeners> </webflow:flow-executor> ... <bean id=\"secureFlowExecutionListener\" class=\"org.springframework.webflow.security.SecurityFlowExecutionListener\"/> <bean id=\"auditFlowExecutionListener\" class=\"com.pr.audit.AuditFlowExecutionListener\"/> ■ ! the flow execution listeners can be configured to be applied only on certain flows; for example: <webflow:listener ref=\"secureFlowExecutionListener\" criteria=\"administrativeFlow1, administrativeFlow2\"/> 265 Chapter 7 ■ Spring Web FloW the flowExecutor can be configured to tune flow execution persistence settings by adding a customized definition for flow-execution-repository. <webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\"> <webflow:flow-execution-repository max-executions=\"5\" max-execution-snapshots=\"30\" /> </webflow:flow-executor> the max-executions property is used to configure the maximum number of persistent flow executions allowed per user session. When the maximum number of executions is exceeded, the oldest execution is removed. the max-execution-snapshots property is used to configure the maximum number of history snapshots allowed per flow execution. history snapshots enable browser back button support. When snapshotting is disabled, pressing the browser back button will not work. it will result in using an execution key that points to a snapshot that has not been recorded. • flowRegistry: Each flow definition registered in this registry bean is assigned a unique identifier. The base-path property is used specify the root directory, under which all the flow definition files are found; usually this is the WEB-INF directory. The flow-location-pattern further narrows the search for the flow definitions, providing a wildcard template file name for the flow definition files. But flow definitions can be also registered one at a time using flow-location elements. For example: <webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\" flow-builder-services=\"flowBuilderServices\"> <webflow:flow-location path=\"persons/newPerson/newPerson-flow.xml\"/> </webflow:flow-registry> • flowBuilderServices: This bean registers custom implementations of services needed to build flow definitions: view resolvers, data convertors, formatters, validators, and others. In version 2.4.0.RELEASE, the validation-hints were added, so flow definition can apply partial validation on the model through the validation- hints attribute supported on view state and transition elements. This bean was modified to add a property named validation-hint-resolver that can be used to set a custom validation hints resolver. (An example is presented later in the book.) ■ ! the development=\"true\" is quite important, because as you will solve the practice exercises, you might not want to restart the application every time you make a change to a flow definition. Setting the development property to \"true\" ensures that changes to a flow definition is autodetected and results in a flow refresh. 266 Chapter 7 ■ Spring Web FloW • mvcViewFactoryCreator: This bean is used by a FlowBuilder to configure a flow’s view states with Spring MVC–based view factories. In this case, the tiles view resolver is injected into it, so it can be used to resolve view states using it. The useSpringBeanBinding property is set to “true” to enable the same binding system used by the Spring MVC in a Web Flow environment. • conversionService: This bean is a wrapper for the conversion service bean used by Spring MVC, which is provided to the flowBuilderServices bean to be used during a flow execution. Configuration Using Annotations For the 09-pr-webflow-basic-practice, a full Java Configuration is used; no web.xml. Three classes were defined for such proposes under the com.pr.config package. Figure 7-5 depicts all three classes, their parents, and the relationship between them. Figure 7-5. Configuration classes for Personal Records Manager project when Spring Web Flow is used ■ ? Can you tell which class takes care of a certain part of the infrastructure just by looking at the diagram in Figure 7-5? 267 Chapter 7 ■ Spring Web FloW Each class covers a part of the infrastructure setup needed to run a Spring web application without a web.xml file that uses Spring Web Flow. • The MvcConfig class encapsulates the Spring MVC infrastructure bean definitions that were covered in Chapter 3. To plug in the Web Flow beans, some modifications were done. The webFlowConfig was injected so the handler mapping and handler adapter specific to flows could be configured. ... import org.springframework.webflow.mvc.servlet.FlowHandlerAdapter; import org.springframework.webflow.mvc.servlet.FlowHandlerMapping; @Configuration @EnableWebMvc public class MvcConfig extends WebMvcConfigurerAdapter { @Autowired private WebFlowConfig webFlowConfig; //other Spring MVC infrastructure beans: formatters, interceptors, // resolvers, etc. Review Chapter 3 for reference. ... //Web Flow specific infrastructure beans @Bean public FlowHandlerMapping flowHandlerMapping() { FlowHandlerMapping handlerMapping = new FlowHandlerMapping(); handlerMapping.setOrder(-1); handlerMapping.setFlowRegistry(this.webFlowConfig.flowRegistry()); return handlerMapping; } @Bean public FlowHandlerAdapter flowHandlerAdapter() { FlowHandlerAdapter handlerAdapter = new FlowHandlerAdapter(); handlerAdapter.setFlowExecutor(this.webFlowConfig.flowExecutor()); handlerAdapter.setSaveOutputToFlashScopeOnRedirect(true); return handlerAdapter; } } The WebFlowConfig class encapsulates the Spring Web Flow infrastructure bean definitions. To align these beans with Spring MVC, the mvcConfig bean was injected, so formatter, validators, and view resolvers could be accessed and set to use during flow executions. This class extends the Spring specialized AbstractFlowConfiguration class, which does not provide any configuration itself but provides access via protected methods to builders for flow executor (getFlowExecutorBuilder()), flow registry (getFlowDefinitionRegistryBuilder()), and flow builder services (getFlowBuilderServicesBuilder()). 268 Chapter 7 ■ Spring Web FloW ... import org.springframework.webflow.config.AbstractFlowConfiguration; import org.springframework.webflow.definition.registry.FlowDefinitionRegistry; import org.springframework.webflow.engine.builder.support.FlowBuilderServices; import org.springframework.webflow.executor.FlowExecutor; import org.springframework.webflow.mvc.builder.MvcViewFactoryCreator; @Configuration public class WebFlowConfig extends AbstractFlowConfiguration { @Autowired private MvcConfig mvcConfig; @Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()) // apply the listener for all flow definitions .addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\") .build(); } @Bean public FlowDefinitionRegistry flowRegistry() { return getFlowDefinitionRegistryBuilder(flowBuilderServices()) .setBasePath(\"/WEB-INF\") .addFlowLocationPattern(\"/**/*-flow.xml\") .build(); } @Bean public FlowBuilderServices flowBuilderServices() { return getFlowBuilderServicesBuilder() .setViewFactoryCreator(mvcViewFactoryCreator()) .setValidator(this.mvcConfig.validator()) .setConversionService(conversionService()) .setDevelopmentMode(true) .build(); } @Bean public MvcViewFactoryCreator mvcViewFactoryCreator() { MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator(); factoryCreator.setViewResolvers(Arrays.<ViewResolver>asList( this.mvcConfig.tilesViewResolver())); factoryCreator.setUseSpringBeanBinding(true); return factoryCreator; } 269 Chapter 7 ■ Spring Web FloW @Bean DefaultConversionService conversionService() { return new DefaultConversionService( conversionServiceFactoryBean().getObject()); } @Bean FormattingConversionServiceFactoryBean conversionServiceFactoryBean() { FormattingConversionServiceFactoryBean fcs = new FormattingConversionServiceFactoryBean(); Set<Formatter> fmts = new HashSet<>(); fmts.add(this.mvcConfig.dateFormatter()); fmts.add(this.mvcConfig.hospitalFormatter()); fcs.setFormatters(fmts); return fcs; } } ■ ! to tune the flow execution persistence settings in Java, the following configuration has to be present in the WebFlowConfig class: @Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()) .addFlowExecutionListener(new AuditFlowExecutorListener(), \"*\") .setMaxFlowExecutions(5) .setMaxFlowExecutionSnapshots(30) .build(); } • The WebInitializer class provides the Servlet 3.0 configuration that replaces the web.xml file. The configuration classes are added to the array of configuration classes used to create the application context by providing the proper implementation for the getRootConfigClasses. public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?> getRootConfigClasses() { return null; } @Override protected Class<?> getServletConfigClasses() { return new Class<?>{ MvcConfig.class, WebFlowConfig.class }; } 270 Chapter 7 ■ Spring Web FloW @Override protected String getServletMappings() { return new String{\"/\"}; } @Override protected Filter getServletFilters() { CharacterEncodingFilter cef = new CharacterEncodingFilter(); cef.setEncoding(\"UTF-8\"); cef.setForceEncoding(true); return new Filter{new HiddenHttpMethodFilter(), cef}; } } At this time, you might be wondering about the FlowController that you saw in Figure 7-2 and why it wasn’t mentioned anywhere in the configuration section. This class is the bridge between the Spring MVC Controller layer and the Spring Web Flow engine; it allows Spring Web Flow to run embedded as a Controller within a DispatcherServlet and it is used internally. This class uses the handlers and executor defined in the configuration to execute flows; it does this transparently.2 ■ ! before continuing to the next section, look at the 09-pr-webflow-basic-practice module under the person-manger project. Start the application using the appStart gretty task for this module. in the browser, you will notice that a new link has appeared, named New Person. the application is depicted in Figure 7-6. if you click the link, you will notice it fails with a 404 error. this is because no handler has been registered for this resource Url. a few configurations have been set up, but some beans and configurations are missing so that this application can use the Spring Web Flow engine. this is left for you to do. the toDo tasks contain comments that direct you where you could implement the required changes. this module will help you test your understanding of the Spring Web Flow Java Configuration. the configuration files have been created, but it is your responsibility to fill them correctly. the flow itself is empty, and no execution step is defined. after clicking New Person link, you see the form in Figure 7-6. this means your configuration is correct and you can continue with the chapter. if you have difficulties in completing the configuration, you can look at the 09-pr-webflow-basic-solution module, which contains the proposed solution for the given tasks. 2The code for the class is publicly available on GitHub at https://github.com/spring-projects/spring-webflow/ blob/master/spring-webflow/src/main/java/org/springframework/webflow/mvc/servlet/FlowController. java. 271 Chapter 7 ■ Spring Web FloW Figure 7-6. Link to the New Person flow Create a Flow A flow describes a sequence of steps that is executed in the order established by the flow definition. A web flow is made of tree types of elements: states, transitions, and data. In a flow definition, the following types of states can be used: • View state: In this type of state, the execution of a flow is paused to render a view to the user and wait for input data. It is defined using the <view-state ../> XML element. • Action state: In this type of state, Java code is executed, and sometimes the next state to transition to depends on the outcome of this code. It is defined using the <action- state ../> XML element. • Decision state: In this type of state, some branch logic is implemented using the XML flow definition language. It is defined using the <decision-state ../> XML element. • Subflow state: The execution is transferred to another flow. When the subflow execution is completed, the execution will return to this state. It is defined using the <decision-state ../> XML element. • End state: The final state of the flow execution. It is not mandatory for this state to render a view, but usually a confirmation view is rendered to the user. It is defined using the <end-state ../> XML element. The states will be referred to using the XML element names in order to faciltate association between the state type and the element used to configure it. The switch from one state to the other is called a transition and it is triggered by events. Some data can be shared among states, depending on the scope of that data. The simple schema of a flow definition and composing elements is depicted in Figure 7-7. The data is the information that is carried from one state to the other; it has a life span that depends on the scope on which it was declared. 272 Chapter 7 ■ Spring Web FloW Figure 7-7. The general schema of a flow definition and composing elements Flow Definition A flow is defined in a single XML file, and all the states composing it are defined as child elements of the flow element. The content of the flow element is actually a task algorithm. All resources used by a flow (views, internationalization files) when being executed must be placed in the same directory as the flow definition file. Basically, each flow defined in an application has its own directory that contains all flow definition resources. This was mentioned in the “Spring Web Flow Architecture” section. In this section, all the necessary steps in defining a flow are covered in detail. For example, to develop the /persons/newPerson flow, the following has to be created (use Figure 7-8 or reference ). Figure 7-8. The components of a flow definition 273 Chapter 7 ■ Spring Web FloW • A directory with the same name as the flow you are trying to create, so as the path inside the WEB-INF matches the URL path that you want to map the flow to • message.properties internationalization files • View files • A tiles configuration file, if tiles are used • A *-flow.xml spring configuration flow definition file When developing a flow, it is recommended to think and design the flow logic first—define the states and transitions, review the flow with business analysts, use mock views (plain HTML files that replace the view in testing scenarios)—to depict the steps and then add the behavior. To define the states of a flow, the *-flow.xml file must be populated. Usually, the first step is a view-state that displays a view to the user to provide data to the flow. <!-- newPerson-flow.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"> <view-state id=\"enterPersonInfo\"/> </flow> The view-state id resolves to a view template; by default, a *.jsp file is searched for in the current directory. View resolution is pluggable, depending on the view technology used. In the examples given in this book, Apache Tiles are used to define and resolve views; so the view to display when entering the enterPersonInfo state is defined in the tiles.xml under the flow directory. The views used for the workflows extend the same tiles template, webapp/WEB-INF/standard/layout.jsp, defined for views in Chapter 3. <!-- tiles.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE tiles-definitions PUBLIC \"-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN\" \"http://tiles.apache.org/dtds/tiles-config_3_0.dtd\"> <tiles-definitions> <definition name=\"enterPersonInfo\" extends=\"layout\"> <put-attribute name=\"pageTitle\" value=\"persons.new.title\" /> <put-attribute name=\"content\" value=\"/WEB-INF/persons/newPerson/newPersonInfo.jsp\" /> <put-attribute name=\"menuTab\" value=\"newPerson\" /> </definition> </tiles-definitions> 274 Chapter 7 ■ Spring Web FloW In the newPersonInfo.jsp view file template, the user event is linked to a button using the name attribute. <!-- newPersonInfo.jsp --> <h2> <spring:message code=\"persons.new.title\"/> </h2> <div class=\"person\"> <sf:form id=\"newPersonForm\" method=\"POST\" modelAttribute=\"person\"> <table> <tr> <th> <label for=\"firstName\"> <span class=\"man\">*</span> <spring:message code=\"label.Person.firstname\"/> : </label> </th> <td><sf:input path=\"firstName\"/></td> <td><sf:errors cssClass=\"error\" path=\"firstName\"/></td> </tr> <!-- other form elements --> ... <tr> <td colspan=\"2\"> <button id=\"newPersonButton\" name=\"_eventId_proceed\" type=\"submit\"> <spring:message code=\"command.proceed\" /> </button> </td> </tr> </table> </sf:form> </div> Next, a transition must be defined by adding the <transition> element as a child to the state you are transitioning from when a user event is activated. If no navigation is performed (for example, when validation fails), the initial view is refreshed. <!-- newPerson-flow.xml --> <flow ...> <view-state id=\"enterPersonInfo\"> <transition on=\"proceed\" to=\"reviewPerson\" /> </view-state> <view-state id=\"reviewPerson\"> <transition on=\"confirm\" to=\"enterIdentityCard\"/> </view-state> ... </flow> 275 Chapter 7 ■ Spring Web FloW When performing typical web navigations, there is always a Cancel button that allows the user to cancel the whole process. When using Spring Web Flow, this can be done by declaring a <global-transition> element, but using global transition elements sort of breaks the flow. It’s similar to using a goto statement. It also makes the flow definition less readable.3 <flow ...> <global-transition on=\"cancel\" to=\"cancelled\" /> ... </flow> A flow can have one or multiple end-states defined (<end-state> elements are used to define them) and a flow execution can end in any of them, based on the events the user triggers. After a flow execution reaches an end state, the flow terminates and the outcome is returned, unless the end state sends a final response or redirects the user to another resource, typically a confirmation page. <flow ...> <end-state id=\"end\" /> </flow> Redirecting to a confirmation page after a flow has finished the execution is tricky, as the flow data is gone. The solution is to use a redirect to a stateless confirmation page and to use a parameter that has a value that can be used to display confirmation data. The <end-state> element has a view attribute that can be used to specify the URL to redirect to. <flow ...> <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/1\" /> </flow> ■ ! the value is hard-coded id value (“1”) in the previous example only because the concept that could be used to make that link dynamic— flow variable—has not been covered yet. The contextRelative prefix is one of the explicit redirects supported in the context of a flow execution. Without these prefixes, the returned resource location is relative to the current servlet mapping. The flow redirect prefixes help you have more control over where the user is redirected. The following is the complete list of flow redirection prefixes: • servletRelative: Redirects to a resource relative to the current server • contextRelative: Redirects to a resource relative to the current web application context path • serverRelative: Redirects to a resource relative to the server root • http:// or https:// Redirects to a fully qualified resource URI 3The GOTO statement (see https://en.wikipedia.org/wiki/Goto). 276 Chapter 7 ■ Spring Web FloW These redirect prefixes are supported in a flow definition together with the externalRedirect: directive in view-state or end-state elements. The view-state element has a view property that can be used to specify a different view than the one with the same state id, and this view can be outside the newPerson flow directory: <flow ...> <view-state id=\"reviewPerson\" view=\"externalRedirect:contextRelative:/verifyPerson\"> <transition on=\"confirm\" to=\"enterIdentityCard\"/> </view-state> </flow> A flow can also redirect to a different flow by using the flowRedirect: directive in its end state; this basically means the current flow ends and a new one is started. In conclusion, when creating a web flow, it is recommended that the following steps be followed in this order:",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "Explicit flow variable usages example 283 Chapter 7 ■ Spring Web FloW ■ ?",
    "answer": "From what has been covered so far, can you tell to which scope the person variable in the previous code sample belongs? Explicit variables can be defined as view-scoped objects too. In this case, the variable is created when the view-state is entered and is destroyed when the transition to the next view-state occurs. They can be used as data models for a single view. They are often updated using AJAX requests before being used for the expression conditioning the transition to the next state; such an implementation is depicted in Figure 7-11. Figure 7-11. Explicit flow variable in view scope usages example In the previous examples, you can see that performing the transition depends on the result of the evaluation of the expression in the <evaluate /> element. The expression in that element is a standard EL expression that can be evaluated directly by the EL; it does not need to be enclosed in delimiters such as #{ }. The delimiters are not needed when the expression is a string that represents a method call or property access, and using them will throw an IllegalArgumentException. The delimiters are only needed when the argument string is a template EL expression that implies mixing literal text with one or more standard expressions, as in the redirect link for the end state in previous examples. <flow ...> <end-state id=\"finish\" view=\"externalRedirect:contextRelative:/person/#{person.id}\" /> </flow> Conversation Variables The conversation scope is the widest web flow scope. Variables defined within this scope are available to subflows too. The conversation variables are similar to global variables and have the same disadvantages. Conversation variables introduce a dependency between top-level flows and their subflows; that’s why the recommendation is to not use them if a different option exists. When working with subflows, input/output parameters can be used to avoid conversation variables. A variable can be assigned to the conversation scope using the <evaluate /> element. 284 Chapter 7 ■ Spring Web FloW In the following example, a Person instance retrieved using a PersonManager service is being assigned to the conversation scope: <flow ...> <!-- The result of this expression is stored into the person variable --> <evaluate result=\"conversationScope.person\" expression=\"personManager.findById(personId)\"/> </flow> Request and Flash Scopes Attributes placed in flash scope exist through the life of the current request and until the next view rendering. After the view renders, the flash scope is cleared. Flash scope is typically used to store messages that should be preserved until after the next view renders. This scope is useful to pass data from one request to another as one flow state involves two requests, as depicted in Figure 7-4. • The first request lasts between the transition from the current state until entering the next state. • The second lasts from the moment before the view is rendered to the end of rendering the same state. You can consider the flash scope as an extension of the request scope in the Web Flow context, because the request scope is not quite useful when using web flow, as is explained later in this section. Attributes placed in request scope exist for the life of the current request into the flow execution. When the request ends, any attributes in request scope goes out of scope. Variables should be assigned the request scope when their values are refetched every time a state is redisplayed. If the data can be cached, the view scope would be more appropriate for the variable. ■ ! the request scope can be useful when creating a sports betting site. the application should have a web flow defined, through which the user can place a bet. a request variable should be used to extract the most recent results of games being played, so the user can be informed in real time of his winning chances. Also, data with request scope can be used in cases where it is needed only to initialize the next view; but it should not be displayed by it. ■ ! Consider the example of a betting site: only the list of games currently being played should be displayed, so a specific time interval value can be stored in a variable and used as criteria for selection. To implement the previously mentioned cases, the flow scope can be used, and the games the user can bet on can be retrieved using AJAX calls. Request scope is pretty useless, considering that usually a developer is interested in sharing the data between the two requests implied by a web flow state. 285 Chapter 7 ■ Spring Web FloW Figure 7-12 is a simple diagram with the duration of the flash scope and the request scope depicted to make their differences in the context of a flow execution more obvious. Figure 7-12. Comparison between request and flash scope In Figure 7-12, you can clearly see the two requests implied by a flow state. One of them is the user request to start the flow with URL /person/newPerson. Accessing this URL makes the web flow engine send a request to /persons/newPerson?execution=e1s1. The request to this web flow resource is the second request. The two arrows under the REQUEST bubble show exactly how long the attributes in the request scope is available. And under the FLASH bubble, you can see the longer arrow, which depicts how long the attributes in the flash scope are available. The execution points— :on-entry, on-render, and so forth—are covered in the next section. Actions Now that web flow scopes have been covered, it is time to introduce actions. Actions execute behavior at specific points within the flow. There are several points where you can execute actions: • on flow start: The <evaluate /> element is declared as a child of the <on-start /> element that marks the start of a flow execution. This action is executed only once, when the flow execution starts. <flow ...> <on-start> <evaluate expression=\"...\"/> </on-start> </flow> 286 Chapter 7 ■ Spring Web FloW • on state entry: The <evaluate /> element is declared as a child of the <on-entry /> element that marks the entry in a state. (A view state in the following example). This action is executed only once, when entering the state. <flow ...> <view-state ...> <on-entry> <evaluate expression=\"...\"/> </on-entry> </view-state> </flow> • on view render: The <evaluate /> element is declared as a child of the <on-render /> element that marks the moment immediately before a view is rendered. The action is executed on every browser refresh. <flow ...> <view-state ...> <on-render> <evaluate expression=\"...\"/> </on-render> </view-state> </flow> • on transition execution: The <evaluate /> element is declared as a child of the <transition /> element. Actions imply evaluating expressions and the results are assigned to variables that have a specific scope assigned. The <evaluate /> action element used in the following example can be used to evaluate an expression and assign the result a specific scope. It can prevent a transition if an exception is thrown or false is returned as a result when the expression is evaluated. How exceptions are handled in the web flow context is covered later in the chapter. Only one <evaluate /> expression is allowed. <flow ...> <view-state ...> <transition on=\"confirm\" to=\"nextStep\"> <evaluate expression=\"...\"/> </transition> </view-state> </flow> • on state exit: The <evaluate /> element is declared as a child of the <on-exit/> element that marks the exit of a state. (A view state in the following example). This action is executed only once, when exiting the state. <flow ...> <view-state ...> <on-exit> <evaluate expression=\"...\"/> </on-exit> </view-state> </flow> 287 Chapter 7 ■ Spring Web FloW • on flow end: The <evaluate /> element is declared as a child of the <on-end /> element that marks the end of a flow execution. This action is executed only once, when the flow execution ends. <flow ...> ... <on-end> <evaluate expression=\"...\"/> </on-end> </flow> The examples presented so far were simplified to set the focus on the syntax when defining your actions. The following example is a concrete one that you will use in the practice exercises: <flow ...> <!-- newPerson-flow.xml --> <view-state id=\"enterPersonInfo\"> <on-render> <evaluate expression=\"hospitalManager.findAll()\" result=\"flowScope.hospitalList\" /> </on-render> <transition on=\"proceed\" to=\"reviewPerson\" /> </view-state> </flow> The <evaluate /> element can also be used to resolve properties on beans and even perform conversions. The actions are usually expressed in Spring EL,4 but Unified EL Standard and OGNL are supported too. Using this type of syntax makes the actions more concise for executing behavior and easier to read from a development point of view. A Spring EL expression has the following template: <variable_name>.property_or_method The variable_name is resolved against the current flow context. Variables referring to data scopes (flowScope, viewScope, requestScope, etc.) should only be used when assigning a new variable to one of the scopes. To resolve a flow variable, reserved variables are searched first, then the variable is searched within each flow scope, starting with request and expanding the scope gradually: flash, view, flow, conversation. If the variable is not found, the flow application context is searched for a bean matching the variable name. Let’s look at a few examples to make usage of Spring EL expressions with web flows easier to understand: • flowScope.person: The person variable is resolved in flow scope • person: The person variable is searched in all scopes • hospitalManager.findAll(): The findAll method is called on the hospitalManager variable (in this book’s examples, hospitalManager is actually a bean). • hospitalManager.findByCode(hospitalCode): Calling a bean method and using the hospitalCode variable as an argument. 4See http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions. html#expressions-language-ref. 288 Chapter 7 ■ Spring Web FloW When using Spring EL to write expressions, a few reserved variables can be used without any prior manual initialization (Spring takes care of initializing them). • scope-specific variables: requestScope, flashScope, viewScope, flowScope, conversationScope • environment-specific variables: flowExecutionUrl, flowRequestContext, requestParameters, externalContext, messageContext, resourceBundle, currentEvent, currentUser • externalContext.sessionMap is used to access HTTP session contents. (No sessionScope variable exists in the context of a flow definition.) Some of these variables can be used in view template files also; in JSP, all scope variables are accessible, flowExecutionUrl is the URL of the current page, flowRequestContext is the RequestContext. Additional variables are available: pageScope, requestParameters, sessionScope, and so forth. So far, only the <evaluate /> element has been used, but there are alternatives more suitable in particular cases. The <set /> action element is used to set the value of a variable, but it does not prevent a transition and can be used multiple times within a transition element. For example, if you just want to view the details on a person after it was selected from a list; there is nothing to evaluate, you just want view some data. The <set /> element is more suitable for this case: <flow ...> <!-- reviewPerson-flow.xml --> <view-state id=\"reviewPersonInfo\"> <on-render> <evaluate expression=\"personManager.getByDateOfBirth(dob)\" result=\"viewScope.persons\" result-type=\"dataModel\" /> </on-render> <transition on=\"select\" to=\"viewPerson\"> <set name=\"flowScope.person\" value=\"persons.selectedRow\" /> </transition> </view-state> </flow> When using <set />, a scope must be specified when creating a new variable, as there is no default. In the following example, the firstName variable is assigned to the flowScope scope. <set name=\"flowScope.firstName\" value=\"requestParameters.firstName\"/> When updating an existing variable, or one of its properties, the scope is no longer required and the algorithm presented previously is used to perform scope resolution. <set name=\"person.firstName\" value=\"requestParameters.firstName\"/> 289 Chapter 7 ■ Spring Web FloW Request Parameters In the previous code sample, the requestParameters system variable was used. This variable contains all the URL parameters for the current request. These parameters are not in the requestScope, and if they are needed further in the execution flow, they need to be assigned to a proper scope; otherwise, they will be lost when the current request ends. <view-state id=\"reviewPersonInfo\"> <transition on=\"cancel\" to=\"cancelled\"> <evaluate expression= \"personManager.delete(requestParameters.personId)\"> </transition> </view-state> ■ ? to test your understanding, look at the following code snippet: <view-state id=\"practiceInfo\"> <on-entry> <set name=\"flashScope.var1\" value=\"var1\" > <set name=\"requestScope.var2\" value=\"var2\" > <on-entry> <on-render> <set name=\"requestScope.var3\" value=\"var3\" > <set name=\"flashScope.var4\" value=\"var4\" > <set name=\"requestScope.var5\" value=\"var5\" > </on-render> </view-state> try to determine which of the following affirmations is true and which is not, and why.5",
    "source": "extracted",
    "confidence": 1.0
  },
  {
    "question": "0\" encoding=\"UTF-8\"?",
    "answer": "> <beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> <http pattern=\"/images/*\" security=\"none\"/> <http pattern=\"/styles/*\" security=\"none\"/> <http pattern=\"/resources/*\" security=\"none\"/> <http auto-config=\"true\" use-expressions=\"true\"> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ROLE_ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('ROLE_USER, ROLE_ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> <authentication-manager> <authentication-provider> <user-service> <user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </user-service> </authentication-provider> </authentication-manager> </beans:beans> Spring Security 4 has introduced a few critical changes that need coverage in this book; because by the time this book is published, Spring Security 4 might be a subject on the exam. 333 Chapter 7 ■ Spring Web FloW ■ ! Spring Security 4 has introduced the possibility of using CSFr tokens in Spring forms to prevent cross- site request forgery.12 a configuration without a <csrf /> element configuration is invalid, and any login requests direct you to a 403 error page stating: Invalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-CSRF-TOKEN'. To migrate from Spring Security 3 to version 4, you have to add a configuration for that element, even if all you do is disable using CSRF tokens. <http auto-config=\"true\" use-expressions=\"true\"> <csrf disabled=\"true\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" logout-success-url=\"/\"/> </http> The delete-cookies attribute can be used to specify a list of cookies to delete at logout time. In the previous configuration, only one is specified, named JSESSIONID; but if the application uses more cookies, they can be specified as a value for this attribute using their names separated by commas. 12This type of attack consists of hacking an existing session to execute unauthorized commands in a web application. You can read more about it at https://en.wikipedia.org/wiki/Cross-site_request_forgery. 334 Chapter 7 ■ Spring Web FloW ■ ! other critical changes are related to the login form default Spring resources, such as the login Url (that indicates an authentication request) and names of the request parameters (expected keys for generation of an authentication token).13 these were changed to match JavaConfig. the login form in the auth.jsp view became the following: <form action=\"<c:url value='/login'/>\" method=\"post\"> <table> <tr> <td> <label for=\"username\"> <spring:message code=\"login.username\"/> </label> </td> <td> <input type='text' id='username' name='username' value='<c:out value=\"${user}\"/>'/> </td> </tr> <tr> <td> <label for=\"password\"> <spring:message code=\"login.password\"/> </label> </td> <td><input type='password' id='password' name='password'/></td> </tr> <tr> <td colspan=\"2\"> <button type=\"submit\"> <spring:message code=\"login.submit\"/> </button> </td> </tr> </table> </form> 13The full list of configuration changes that were made to match Java Configuration is at https://jira.spring.io/ browse/SEC-2783. 335 Chapter 7 ■ Spring Web FloW ■ ! all previous examples used default values for the login Url and the authentication key names j_spring_ security_check, j_username, j_password (in Spring Security 3), login, username, password (in Spring Security 4). Keep in mind that all of them can be redefined using Spring configuration. If you are interested in keeping your form as secure as possible, you can configure CSRF usage and add the token generated by Spring to your form. The following are the required modifications: • First you must enable CSRF generation in your security-config.xml file by adding a <csrf /> configuration element and a repository to generate the value for it. Modify the logout element appropriately; the third bullet in this list tells you why. <beans:beans .../> <beans:bean id=\"tokenRepo\" class=\"org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository\"> <beans:property name=\"sessionAttributeName\" value=\"_csrf\"/> </beans:bean> <http auto-config=\"true\" use-expressions=\"true\"> <csrf token-repository-ref=\"tokenRepo\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" invalidate-session=\"true\" logout-success-url=\"/\"/> </http> ... </beans:beans> • Second, you must add a hidden parameter in every form that you are interested in protecting form cross-site request forgery. <form action=\"<c:url value='/login'/>\" method=\"post\"> <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/> <table> <tr> <td> <label for=\"username\"> <spring:message code=\"login.username\"/> </label> </td> <td> <input type='text' id='username' name='username' value='<c:out value=\"${user}\"/>'/> </td> 336 Chapter 7 ■ Spring Web FloW </tr> <tr> <td> <label for=\"password\"> <spring:message code=\"login.password\"/> </label> </td> <td><input type='password' id='password' name='password'/></td> </tr> <tr> <td colspan=\"2\"> <button type=\"submit\"> <spring:message code=\"login.submit\"/> </button> </td> </tr> </table> </form> • And last, logging out becomes a pain when CSRF is enabled, because you need to log out using a POST request. Thus, you cannot just use a link build like this (like in Spring Security 3): <a href=\"<spring:url value=\"/j_spring_security_logout\"/>\"> <spring:message code=\"menu.logout\"/> </a> You need to add a logout form to the page and submit it using JavaScript: <spring:url value=\"/logout\" var=\"logoutUrl\" /> <form action=\"${logoutUrl}\" id=\"logout\" method=\"post\"> <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/> </form> <a href=\"#\" onclick=\"document.getElementById('logout').submit();\"> <spring:message code=\"menu.logout\"/> </a> Also, as we’ve been mentioning logout, you probably noticed the extra attributes of the <logout /> element; their names are quite obvious, and if specified at logout, the specific resources are cleaned accordingly: <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" invalidate-session=\"true\" logout-success-url=\"/\"/> 337 Chapter 7 ■ Spring Web FloW Also, a handler can be used instead of the logout-success-url that takes care of redirecting to the proper page and eventually cleaning up any resources: <logout logout-url=\"/logout\" delete-cookies=\"JSESSIONID\" success-handler-ref=\"logoutSuccessHandler\"/> To view the token Spring Security has generated, you can use Firebug to view the contents of your login request. You should see something similar to what is depicted in Figure 7-25. Figure 7-25. Spring Security CSRF token ■ ! another simplification change that can be done to this file is provided by a new feature introduced in Spring Security 4 that allows access expressions to be specified without the ROLE_ prefix in front of them; thus, the preceding configuration becomes this: <http auto-config=\"true\" use-expressions=\"true\"> <csrf disabled=\"true\"/> <intercept-url pattern=\"/auth*\" access=\"permitAll\"/> <intercept-url pattern=\"/persons/newPerson\" access=\"hasRole('ADMIN')\"/> <intercept-url pattern=\"/**\" access=\"hasAnyRole('USER, ADMIN')\"/> <form-login login-page=\"/auth\" authentication-failure-url=\"/auth?auth_error=1\" default-target-url=\"/\"/> <logout logout-url=\"/j_spring_security_logout\"/> </http> 338 Chapter 7 ■ Spring Web FloW <authentication-manager> <authentication-provider> <user-service> <user name=\"john\" password=\"doe\" authorities=\"ROLE_USER\"/> <user name=\"jane\" password=\"doe\" authorities=\"ROLE_USER,ROLE_ADMIN\"/> <user name=\"admin\" password=\"admin\" authorities=\"ROLE_ADMIN\"/> </user-service> </authentication-provider> </authentication-manager> Another part of configuration needs to be added in the web.xml file, if used. A security filter needs to be added to intercept all requests to the application. springSecurityFilterChain is a mandatory name and refers to an infrastructure bean with the same name. This bean is responsible for all the security within the application (protecting the application URLs, validating submitted usernames and passwords, redirecting to the log in form, etc.). <filter> <filter-name>springSecurityFilterChain</filter-name> <filter-class> org.springframework.web.filter.DelegatingFilterProxy </filter-class> </filter> <filter-mapping> <filter-name>springSecurityFilterChain</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> Configure Authentication It was mentioned that authentication can be configured to work with almost any credential support technology. In this subsection, a few of them are covered. By default, in Spring Security the DAO authentication provider is used, as well as a specific UserDetailsService implementation to provide credentials and authorities. In the examples so far, the credentials were basically read from the configuration file and stored into memory. The credentials were not encrypted, so even if Spring Security is used, the application is not that secure. To encrypt credentials, the configuration must be modified to specify the encryption type: <!-- spring-config.xml --> <authentication-manager> <authentication-provider> <password-encoder hash=\"md5\" > <salt-source system-wide=\"MySalt\"/> </password-encoder> <user-service properties=\"/WEB-INF/users.properties\" /> </authentication-provider> </authentication-manager> 339 Chapter 7 ■ Spring Web FloW #/WEB-INF/users.properties john=a1c093d7a2742f0afef7720883a59016,ROLE_USER #password: john jane=a1c093d7a2742f0afef7720883a59016,ROLE_USER,ROLE_ADMIN #password: jane admin=5a693853b2958ecb256db46b808ac488,ROLE_ADMIN #password: admin In the preceding configuration, the md514 algorithm is used to encrypt the passwords and a method called password-salting is used to increase the security passwords by adding a well-known string to them. The string added to the password can be an application-wide string, like in the previous example where the String is \"MySalt\", or it can be a property of the entity—something that won’t change, like its unique identifier in the system, for example. A combination of properties can be used as salt too, but all the properties must be constant for the duration of the entity; if any of the property values changes, the user won’t be able to log in anymore because the authentication system won’t be able to create the correct hash. The preceding encrypted strings were generated using an instance of org.springframework.security. authentication.encoding.Md5PasswordEncoder: import org.springframework.security.authentication.encoding.Md5PasswordEncoder; public class PasswordGenerator { public static void main(String args) { Md5PasswordEncoder encoder = new Md5PasswordEncoder(); String encrypted = encoder.encodePassword(\"doe\", \"MySalt\"); System.out.println(encrypted); encrypted = encoder.encodePassword(\"admin\", \"MySalt\"); System.out.println(encrypted); } } To use an entity property as salt, the previous configuration must be modified like this: <authentication-manager> <authentication-provider> <password-encoder hash=\"md5\"> <salt-source user-property=\"id\" /> </password-encoder> </authentication-provider> </authentication-manager> The credentials were decoupled from the configuration by isolating them in a property file, which can be easily edited without needing to recompile the application. The credentials property file has a specific syntax: [username] = [password(encrypted)],[role1,role2...] 14Read more about MD5 at https://en.wikipedia.org/wiki/MD5. 340 Chapter 7 ■ Spring Web FloW But credentials in memory storage is not a solution for production applications; this is only suitable for very small and educational applications. For production application, the most common storage for credentials is a database. To provide these credentials to the authentication manager, a data source is needed: <authentication-manager> <authentication-provider> <jdbc-user-service data-source-ref=\"authDataSource\" /> </provider> </authentication-manager> Two tables must be accessible using the authDataSource: one named users containing user credentials and one named authorities continuing user-role correspondences. The following queries are run by the authentication provider and must execute successfully: SELECT username, password, enabled FROM users WHERE username = ? SELECT username, authority FROM authorities WHERE username = ? Another way to provide credentials is to write a custom implementation for an authentication provider: <authentication-manager> <authentication-provider user-service-ref=\"customCredentialsProvider\" /> </authentication-manager> The provider class can delegate to a DAO implementation to retrieve principals from a database using a data source and customized queries. The information is returned into a format recognized in the application. In the following example, an instance of type UserInfo is used as a principal in the application: [commandchars=* @Repository public class CustomCredentialsProvider { private JdbcTemplate jdbcTemplate; @Autowired public void setDataSource(DataSource dataSource) { this.jdbcTemplate = new JdbcTemplate(dataSource); } public UserInfo getUserInfo(String username){ String sql = \"SELECT u.username name, u.password pass,\"+ a.authority role FROM \"+ \"users u INNER JOIN authorities a\" + on u.username=a.username WHERE \"+ \"u.enabled =1 and u.username = ?\"; UserInfo userInfo = (UserInfo)jdbcTemplate.queryForObject(sql, new Object{username}, new RowMapper<UserInfo>() { public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException { UserInfo user = new UserInfo(); user.setUsername(rs.getString(\"name\")); user.setPassword(rs.getString(\"pass\")); 341 Chapter 7 ■ Spring Web FloW user.setRole(rs.getString(\"role\")); return user; } }); return userInfo; } } //UserInfo.java public class UserInfo { private String username; private String password; private String role; //setter and getters for fields } No web.xml Configuration As the official documentation says, if Spring Security is used with Spring MVC, you need an extra empty class that extends org.springframework.security.web.context. AbstractSecurityWebApplicationInitializer, a class provided by Spring Security that ensures that the springSecurityFilterChain gets registered. Also, you need to include the Spring Security XML configuration file in the Java Configuration, as depicted in the following code sample: import org.springframework.security.web.context. AbstractSecurityWebApplicationInitializer; // Empty class needed to register the springSecurityFilterChain bean public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { } public class WebInitializer extends AbstractDispatcherServletInitializer { @Override protected WebApplicationContext createRootApplicationContext() { XmlWebApplicationContext ctx = new XmlWebApplicationContext(); ctx.setConfigLocation(\"/WEB-INF/spring/security-config.xml\"); return ctx; } @Override protected WebApplicationContext createServletApplicationContext() { XmlWebApplicationContext ctx = new XmlWebApplicationContext(); ctx.setConfigLocations(\"/WEB-INF/spring/mvc-config.xml\", \"/WEB-INF/spring/app-config.xml\", \"/WEB-INF/spring/webflow-config.xml\"); return ctx; } ... } But as Java Configuration and web initializer classes were introduced to simplify configuration and get rid of all XML, all the preceding configurations will soon be deprecated. 342 Chapter 7 ■ Spring Web FloW Spring Security Java Configuration The XML configuration style is close to its death, as Java Configuration gains popularity. So it was expected that Spring Security adapt, and they did. The Java Configuration is super-simple and intuitive. When working with Spring MVC and Spring Security to develop a working security configuration, you need to do the following:",
    "source": "extracted",
    "confidence": 1.0
  }
]